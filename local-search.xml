<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Introduction to Parallel Programming课程笔记</title>
    <link href="/MPI/Introduction%20to%20Parallel%20Programming/"/>
    <url>/MPI/Introduction%20to%20Parallel%20Programming/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Introduction-to-Parallel-Programming"><a href="#一、Introduction-to-Parallel-Programming" class="headerlink" title="一、Introduction to Parallel Programming"></a>一、<a href="https://www.futurelearn.com/courses/interactive-hands-on-introduction-to-parallel-programming/1/todo/105942">Introduction to Parallel Programming</a></h1><p>OpenMP（Open specifications for Multi Processing）是一个用于共享内存并行计算的API。</p><p>OpenMP API由三个部分组成：</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!xx\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span>&#123;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(3)</span><br>    <span class="hljs-built_in">sayHello</span>();    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>output:<br>Hello World!<br>Hello World!xx<br>Hello World!xx<br>Hello World!xx<br></code></pre></td></tr></table></figure><p>X、参考文献&#x2F;课程</p><ul><li><a href="https://www.futurelearn.com/courses/interactive-hands-on-introduction-to-parallel-programming/1/todo/105942">Introduction to Parallel Programming</a></li><li><a href="https://zhuanlan.zhihu.com/p/488116143">NUMA 的平衡和调度</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>并行编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI和Cuda学习</title>
    <link href="/MPI/MPI%20and%20Cuda/"/>
    <url>/MPI/MPI%20and%20Cuda/</url>
    
    <content type="html"><![CDATA[<p>一、基本介绍</p><p>X、参考文献</p><ul><li><a href="https://www.bilibili.com/video/BV16b4y1E74f/?spm_id_from=333.337.search-card.all.click&vd_source=fb926f3550cd847435afc066c3343d2e">（b站）CUDA在现代C++中如何运用？看这一个就够了！</a></li><li><a href="https://blog.csdn.net/Rong_Toa/article/details/77871833">Mpi与Cuda混合编程（Makefile）</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>并行编程</tag>
      
      <tag>MPI</tag>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka</title>
    <link href="/Architecture/kafka/"/>
    <url>/Architecture/kafka/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>消息驱动</title>
    <link href="/Architecture/event-streaming/"/>
    <url>/Architecture/event-streaming/</url>
    
    <content type="html"><![CDATA[<p><img src="/Architecture/event-streaming/385fb2888d6446749de2016e0cdaf521.png" alt="Kafka的通信流程梳理"></p><ol><li>怎么记录数据的类型</li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/506577165">“消息驱动、事件驱动、流 ”基础概念解析</a></li><li><a href="https://blog.csdn.net/LemonSnm/article/details/125325163">分布式消息中间件设计</a></li><li><a href="https://www.jianshu.com/p/f13844f815f0">深入理解Kafka事件流（Event Streaming）平台（一）</a></li><li><a href="https://blog.csdn.net/m0_65931372/article/details/125971395">kafka简介</a></li><li><a href="https://blog.csdn.net/pass_JMC/article/details/126716003">Kafka全面学习</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试问题</title>
    <link href="/others/problems/"/>
    <url>/others/problems/</url>
    
    <content type="html"><![CDATA[<h2 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h2><h3 id="RPC项目"><a href="#RPC项目" class="headerlink" title="RPC项目"></a>RPC项目</h3><ol><li><p>简单介绍一下这个项目***</p></li><li><p>服务的发布与获取流程***</p></li><li><p>为什么要做这个项目***</p></li><li><p>什么是RPC</p></li><li><p>一个RPC框架需要一些什么内容</p></li><li><p>这个框架和其他的RPC框架有什么区别</p></li><li><p>是否进行过性能测试</p></li><li><p>在做项目的过程中遇到过什么问题***</p></li><li><p>项目中难点哪里</p></li><li><p>项目中同步与并发是如何实现的</p></li><li><p>RPC项目是怎么设计编码的</p></li><li><p>用的什么序列化框架</p></li><li><p>简单介绍一下netty</p></li><li><p>NIO和BIO有什么区别***</p></li><li><p>什么是IO多路复用*******</p></li><li><p>select、poll、epoll有什么区别****</p></li><li><p>NIO是水平触发还是边缘触发</p></li><li><p>注册中心是用的什么做的</p></li><li><p>如何用zookeeper实现注册中心***</p></li><li><p>如何保持客户端与服务端通信***</p></li><li><p>服务变更（上下线）如何通知客户端</p></li><li><p>负载均衡如何做的</p></li><li><p>你知道一些什么负载均衡算法</p></li><li><p>CAP理论知道吗</p></li><li><p>zookeeper是AP系统还是CP系统</p></li><li><p>这个框架是AP系统还是CP系统，为什么</p></li><li><p>如何保持通信</p></li><li><p>介绍一下Reactor模型</p></li><li><p>rpc与http的区别***</p></li><li><p>zookeeper的主从状态怎么传播</p></li><li><p>zookeeper主节点宕机如何处理</p></li><li><p>服务调用是同步还是异步的</p></li><li><p>项目中用到了线程池吗，怎么用的</p></li><li><p>有服务的自动化编码过程吗？（如thrift通过idl生成api）</p></li><li><p>如何发现服务宕机</p></li></ol><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker代码开发调试 mpi环境</title>
    <link href="/Docker/docker-develop/"/>
    <url>/Docker/docker-develop/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-代码开发调试流程"><a href="#docker-代码开发调试流程" class="headerlink" title="docker 代码开发调试流程"></a><a href="https://blog.csdn.net/condom10010/article/details/126742399">docker 代码开发调试流程</a></h1><ol><li>运行docker容器(同时把本地代码挂载到容器内)</li><li>使用vscode进入容器,并打开代码,修改代码,运行和调试.</li><li>在宿主机一端,使用git管理代码.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Basics of Autotools</title>
    <link href="/others/makefile-and-configure/"/>
    <url>/others/makefile-and-configure/</url>
    
    <content type="html"><![CDATA[<p><img src="/others/makefile-and-configure/diagram.png" alt="How autotools fits together"></p><p>[^A basic overview of how the main autotools components fit together]: </p><p>在一个简单的设置中。</p><ul><li>autoconf程序从configure.in或configure.ac中产生一个configure脚本（见下文注释）。</li><li>automake程序从Makefile.am中产生一个Makefile.in。</li><li>configure脚本被运行，以便从Makefile.in文件产生一个或多个Makefile文件。</li><li>make程序使用Makefile文件来编译程序</li></ul><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://devmanual.gentoo.org/general-concepts/autotools/index.html">The Basics of Autotools</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>编译相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/Java/Design_Mode/"/>
    <url>/Java/Design_Mode/</url>
    
    <content type="html"><![CDATA[<h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><h3 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a><strong>1、开闭原则（Open Close Principle）</strong></h3><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p><p>样例一：<a href="https://blog.csdn.net/m0_54485604/article/details/113502478">六大原则之开闭原则</a></p><p>将画笔类的draw()方法的实现放入对应的形状中，则新增形状无需修改画笔类的draw()方法，只需要在类中定义自己的draw()方法即可</p><p>样例二：<a href="https://blog.csdn.net/fry3309/article/details/123582415">开闭原则（开放封闭原则）</a></p><p>子类覆盖父类中需要修改的方法，通过子类代替父类来减少修改</p><h3 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></h3><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong></p><p>样例一：<a href="https://blog.csdn.net/weixin_39327556/article/details/125268590">里氏替换原则</a></p><p>对于需要修改父类内容的子类，找到更加通用的父类（父类的超类）替代其父类</p><h3 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></h3><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><h3 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a><strong>4、接口隔离原则（Interface Segregation Principle）</strong></h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h3 id="5、迪米特法则，又称最少知道原则（Demeter-Principle）"><a href="#5、迪米特法则，又称最少知道原则（Demeter-Principle）" class="headerlink" title="5、迪米特法则，又称最少知道原则（Demeter Principle）"></a><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></h3><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h3 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a><strong>6、合成复用原则（Composite Reuse Principle）</strong></h3><h2 id="二十三种常用设计模式"><a href="#二十三种常用设计模式" class="headerlink" title="二十三种常用设计模式"></a>二十三种常用设计模式</h2><table><thead><tr><th>1</th><th>创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</th><th>工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern）</th></tr></thead><tbody><tr><td>2</td><td><strong>结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td>适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern）</td></tr><tr><td>3</td><td><strong>行为型模式</strong> 这些设计模式特别关注对象之间的通信。</td><td>责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）</td></tr><tr><td>4</td><td><strong>J2EE 模式</strong> 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td><td>MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a><strong>创建型模式</strong></h3><h4 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h4><p>创造对象时无需new对象，而是用一个factory来创建，这样不会暴露产品的创建逻辑，也可以用统一的处理方式来管理产品的新建。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Factory</span>.</span></span>make(xxx);<br><br><span class="hljs-comment">// or like Executors</span><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Factory</span>.</span></span>make<span class="hljs-constructor">A()</span>;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Factory</span>.</span></span>make<span class="hljs-constructor">B()</span>;<br></code></pre></td></tr></table></figure><p>三要素：抽象产品（Shape）、具体产品（Circle、Square、Rectangle）、具体工厂（ShapeFactory）</p><p><img src="/Java/Design_Mode/image-20221121201018165.png" alt="image-20221121201018165"></p><h4 id="模版工厂模式"><a href="#模版工厂模式" class="headerlink" title="模版工厂模式"></a>模版工厂模式</h4><p>对于普通工厂模式来说，一个工厂可以生产几个不同的产品，如果需要新增产品，则需要修改factory的逻辑，不符合开闭原则。故可以使用抽象工厂模式，一个工厂对应一个产品，新增产品的同时新增工厂即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FactoryA</span> <span class="hljs-variable">factoryA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FactoryA</span>();<br><span class="hljs-type">FactoryB</span> <span class="hljs-variable">factoryB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FactoryB</span>();<br><span class="hljs-type">Product</span> <span class="hljs-variable">product1</span> <span class="hljs-operator">=</span> factoryA.make();<br><span class="hljs-type">Product</span> <span class="hljs-variable">product2</span> <span class="hljs-operator">=</span> factoryB.make();<br></code></pre></td></tr></table></figure><p>但对于模版工厂模式每一个产品都对应一个工厂，当产品种类数目较多时，系统中会存在过多的工厂，增加了系统的开销，让系统变得过于庞大。</p><h4 id="抽象工厂模式（Abstract-Factory-Pattern）"><a href="#抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="抽象工厂模式（Abstract Factory Pattern）"></a>抽象工厂模式（Abstract Factory Pattern）</h4><p>抽象工厂模式较于模版工厂模式新增了一个产品family的概念，一个具体的工厂类对应一个产品组。</p><p><img src="/Java/Design_Mode/image-20221121204536398.png" alt="image-20221121204536398"></p><h4 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h4><ul><li><p>一个类只能有一个实例对象，该对象一般可被全局访问</p></li><li><p>饿汉式and懒汉式（上锁+双重判断保证线程安全）</p></li><li><p>用private修饰构造函数</p></li><li><p>static修饰实例对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 饿汉式 建议使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingleObject</span> &#123;<br> <br>   <span class="hljs-comment">//创建 SingleObject 的一个对象</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleObject instance = <span class="hljs-keyword">new</span> SingleObject();<br> <br>   <span class="hljs-comment">//让构造函数为 private，这样该类就不会被实例化</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleObject</span>()</span>&#123;&#125;<br> <br>   <span class="hljs-comment">//获取唯一可用的对象</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleObject <span class="hljs-title">getInstance</span>()</span>&#123;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMessage</span>()</span>&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="原型模式（Prototype-Pattern）"><a href="#原型模式（Prototype-Pattern）" class="headerlink" title="原型模式（Prototype Pattern）"></a>原型模式（Prototype Pattern）</h4><p>在保障性能的情况下重复创造对象</p><ol><li>实现Cloneable接口</li><li>调用对象clone()方法（强转）</li></ol><p>缺点如下：</p><ol><li><p>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</p></li><li><p>当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆。</p></li></ol><h4 id="建造者模式（Builder-Pattern）（todo）"><a href="#建造者模式（Builder-Pattern）（todo）" class="headerlink" title="建造者模式（Builder Pattern）（todo）"></a>建造者模式（Builder Pattern）（todo）</h4><p>使用多个简单的对象一步一步构建成一个复杂的对象</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">kfd</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">DoContact</span> <span class="hljs-built_in">object</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoContact</span>.<span class="hljs-title class_">Builder</span>(<span class="hljs-string">&quot;MChopin&quot;</span>).<span class="hljs-title function_">age</span>(<span class="hljs-number">18</span>)<br>                .<span class="hljs-title function_">address</span>(<span class="hljs-string">&quot;shanghai&quot;</span>).<span class="hljs-title function_">build</span>();<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;name=&quot;</span> + <span class="hljs-built_in">object</span>.<span class="hljs-title function_">getName</span>() + <span class="hljs-string">&quot; age=&quot;</span> + <span class="hljs-built_in">object</span>.<span class="hljs-title function_">getAge</span>()<br>                + <span class="hljs-string">&quot; address=&quot;</span> + <span class="hljs-built_in">object</span>.<span class="hljs-title function_">getAddress</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><h4 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>用户通过代理对象来调用真实对象的方法，代理类类似中介</p><h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><p>由三个部分组成：公共接口、被代理对象、代理对象</p><img src="/Java/Design_Mode/image-20221124194103417.png" alt="image-20221124194103417" style="zoom:50%;"><p>Agent中rentHouse()方法实际调用了owner中的rentHouse()方法，可以在调用的前后增加操作，如收中介费等。</p><p>优点：简单</p><p>缺点：对于类中每个方法都要创建代理方法，新增与删除方法时要同步修改代理类方法，被代理对象与代理对象耦合严重</p><h5 id="jdk代理"><a href="#jdk代理" class="headerlink" title="jdk代理"></a>jdk代理</h5><p>动态代理中的一种，一个代理类可以代理多个类</p><img src="/Java/Design_Mode/image-20221124200742966.png" alt="image-20221124200742966" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Owner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandleForHouse</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rentHouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;房东租房&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellHouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;房东卖房&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">HandleForHouse</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rentHouse</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellHouse</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyOwner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span>&#123;<br>    <span class="hljs-keyword">private</span> Object object;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyOwner</span><span class="hljs-params">(Object object)</span>&#123;<br>        <span class="hljs-built_in">this</span>.object = object;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 不同类不同处理</span><br>        System.out.println(<span class="hljs-string">&quot;xxx&quot;</span>);<br>        <span class="hljs-keyword">if</span> (proxy <span class="hljs-keyword">instanceof</span> HandleForHouse)&#123;<br>            <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;rentHouse&quot;</span>))&#123;<br>                System.out.println(<span class="hljs-string">&quot;中介收租房中介费&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;sellHouse&quot;</span>))&#123;<br>                System.out.println(<span class="hljs-string">&quot;中介收卖房中介费&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> method.invoke(object, args);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Owner</span> <span class="hljs-variable">owner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Owner</span>();<br>        <span class="hljs-type">ProxyOwner</span> <span class="hljs-variable">proxyOwner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyOwner</span>(owner);<br>        <span class="hljs-type">HandleForHouse</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> (HandleForHouse) Proxy.newProxyInstance(<br>                proxyOwner.getClass().getClassLoader(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;HandleForHouse.class&#125;,<br>                proxyOwner);<br>        test1.rentHouse();<br>        test1.sellHouse();<br>    &#125;<br>&#125;<br><br>output:<br>xxx<br>中介收租房中介费<br>房东租房<br>xxx<br>中介收卖房中介费<br>房东卖房<br></code></pre></td></tr></table></figure><h5 id="cglib代理-todo"><a href="#cglib代理-todo" class="headerlink" title="cglib代理(todo)"></a>cglib代理(todo)</h5><h4 id="装饰器模式（Decorator-Pattern）"><a href="#装饰器模式（Decorator-Pattern）" class="headerlink" title="装饰器模式（Decorator Pattern）"></a>装饰器模式（Decorator Pattern）</h4><h4 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h4><h4 id="享元模式（Flyweight-Pattern）"><a href="#享元模式（Flyweight-Pattern）" class="headerlink" title="享元模式（Flyweight Pattern）"></a>享元模式（Flyweight Pattern）</h4><h3 id="xxx"><a href="#xxx" class="headerlink" title="xxx"></a>xxx</h3><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式&#x2F;模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.runoob.com/design-pattern/design-pattern-intro.html">菜鸟教程-设计模式简介</a></li><li><a href="https://www.jianshu.com/p/a3e09071c44f">重构（Refactoring）学习笔记</a></li><li><a href="https://zhuanlan.zhihu.com/p/475486025">设计模式之【工厂模式】</a></li><li><a href="https://blog.csdn.net/yucaixiang/article/details/90379525">原型模式</a></li><li><a href="https://blog.csdn.net/ChineseSoftware/article/details/123256575">建造者模式(Builder Pattern)</a></li><li><a href="https://www.zhihu.com/question/21857130">什么是建造者模式？</a></li><li><a href="https://www.bilibili.com/read/cv14604081/">18设计模式——建造者模式详解</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
      <tag>系统架构</tag>
      
      <tag>整理总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阻塞队列（BlockingQueue）</title>
    <link href="/Java/Block-queue/"/>
    <url>/Java/Block-queue/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>实现类</th><th>特点</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>基于环形数组实现的有界阻塞队列</td></tr><tr><td>LinkedBlockingQueue</td><td>基于单链表实现的无界阻塞队列，有两个锁，可同时存取</td></tr><tr><td>LinkedBlockingDeque</td><td>基于双链表实现的无界阻塞队列，双向读写</td></tr><tr><td>DelayQueue</td><td>基于优先队列实现的延迟阻塞队列，队列中数据需要到达延迟时间才能取出</td></tr><tr><td>PriorityBlockingQueue</td><td>线程安全优先队列，底层为堆排序</td></tr><tr><td>SynchronousQueue</td><td>无缓存阻塞队列</td></tr><tr><td>LinkedTransferQueue</td><td>基于CAS和单链表实现的无界队列</td></tr></tbody></table><h2 id="二、常用方法"><a href="#二、常用方法" class="headerlink" title="二、常用方法"></a>二、常用方法</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p>以上四个方法都是将数据添加进队列</p><ul><li>add和offer，如果成功则<strong>直接（不阻塞）</strong>返回true，否则，add方法抛出IllegalStateException，而offer方法直接返回false。故对于有界的阻塞队列使用offer通常效果更佳，因为其不会抛出异常阻塞线程。</li><li>put，如果队列剩余空间不足导致加入不成功，会<strong>一直阻塞等待</strong>。</li><li>带参数offer，如果队列剩余空间不足导致加入不成功，会<strong>在时间限期内</strong>阻塞等待添加数据。</li></ul><h3 id="取出数据"><a href="#取出数据" class="headerlink" title="取出数据"></a>取出数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>E <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p>以上两个方法都是将队首数据从队列取出</p><ul><li>take如果没有数据可以取出，则会<strong>一直阻塞等待</strong>。</li><li>poll会<strong>在时间限期内</strong>阻塞等待。</li></ul><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br></code></pre></td></tr></table></figure><h3 id="批量传递数据"><a href="#批量传递数据" class="headerlink" title="批量传递数据"></a>批量传递数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">drainTo</span><span class="hljs-params">(Collection&lt;? <span class="hljs-built_in">super</span> E&gt; c)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">drainTo</span><span class="hljs-params">(Collection&lt;? <span class="hljs-built_in">super</span> E&gt; c, <span class="hljs-type">int</span> maxElements)</span>;<br></code></pre></td></tr></table></figure><p>drainTo实现将当前阻塞队列中的信息全部转移到集合c中</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>查看队列剩余容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">remainingCapacity</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>查看是否包含某个数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>;<br></code></pre></td></tr></table></figure><h2 id="三、实现类及其源码"><a href="#三、实现类及其源码" class="headerlink" title="三、实现类及其源码"></a>三、实现类及其源码</h2><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><ul><li>有界阻塞队列，底层通过Object数组以及ReentrantLock等工具实现，初始化ArrayBlockingQueue时会传入数组长度</li><li>无法存放null值</li><li>入队与出队<strong>共享同一个锁</strong></li><li><strong>while配合condition使用，等待唤醒</strong>（BlockingQueue通用）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Object[] items;<br><span class="hljs-keyword">final</span> ReentrantLock lock;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(fair);<br>    notEmpty = lock.newCondition();<br>    notFull =  lock.newCondition();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">capacity：队列容量</span><br><span class="hljs-comment">fair：是否是公平锁，默认非公平，可省略</span><br><span class="hljs-comment">c：通过集合c初始化队列数值，将c中数据全部取出放入队列中，可省略</span><br><span class="hljs-comment">⚠️</span><br><span class="hljs-comment">1. c中数据不能为null，否则会出现NullPointerException</span><br><span class="hljs-comment">2. c的长度不能大于队列容量，否则会出现IllegalArgumentException</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair, Collection&lt;? extends E&gt; c)</span> &#123; <br>     <span class="hljs-built_in">this</span>(capacity, fair);<br>      <br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>      lock.lock(); <span class="hljs-comment">// Lock only for visibility, not mutual exclusion</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">for</span> (E e : c)<br>            items[i++] = Objects.requireNonNull(e);<br>        &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>        &#125;<br>        count = i; <span class="hljs-comment">// 队列中元素个数</span><br>        putIndex = (i == capacity) ? <span class="hljs-number">0</span> : i; <span class="hljs-comment">// 下一个数据插入时存放位置</span><br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>      &#125;<br>&#125;<br><br><span class="hljs-comment">// 入队</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    items[putIndex] = e;<br>    <span class="hljs-keyword">if</span> (++putIndex == items.length) putIndex = <span class="hljs-number">0</span>;<br>    count++;<br>    notEmpty.signal(); <span class="hljs-comment">// 唤醒取数据等待队列</span><br>&#125;<br><br><span class="hljs-comment">// 出队</span><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) items[takeIndex];<br>    items[takeIndex] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="hljs-number">0</span>;<br>    count--;<br>    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-literal">null</span>)<br>      itrs.elementDequeued();<br>    notFull.signal(); <span class="hljs-comment">// 唤醒插入数据等待队列</span><br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br><br><span class="hljs-comment">//================插入数据================</span><br><span class="hljs-comment">// 插入数据，lock上锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    Objects.requireNonNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (count == items.length)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 队列满了的情况直接返回false</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        enqueue(e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Objects.requireNonNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// lockInterruptibly 与 lock比较区别在于 lockInterruptibly优先考虑响应中断，再去获取锁。 </span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (count == items.length)<br>        notFull.await(); <span class="hljs-comment">// 队列满了的情况阻塞等待</span><br>      enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//================取出数据================</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">return</span> (count == <span class="hljs-number">0</span>) ? <span class="hljs-literal">null</span> : dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>        notEmpty.await();<br>      <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><ul><li>无界阻塞队列，但也可传入capacity限定容量，默认Integer.MAX_VALUE作为最大容量（近似无界），底层通过链表以及ReentrantLock等工具实现</li><li>入队与出队<strong>分别拥有不同的锁</strong>，takeLock和putLock，故写出与取出可以同时进行</li><li>count类型为AtomicInteger，防止发生并发问题</li><li>add，offer，put，take，poll等操作实现与ArrayBlockingQueue类似</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 与ArrayBlockingQueue不同，因为添加和删除元素可以同步进行，为防止发生并发问题，此处count不能使用简单int</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(); <br><span class="hljs-keyword">transient</span> Node&lt;E&gt; head;<span class="hljs-comment">// head为哨兵节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.capacity = capacity;<br>    last = head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(<span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> &#123;<br>   last = last.next = node;<br>&#125;<br><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    Node&lt;E&gt; h = head;<br>    Node&lt;E&gt; first = h.next;<br>    h.next = h; <span class="hljs-comment">// help GC</span><br>    head = first;<br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> first.item;<br>    first.item = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><ul><li>双向队列，LinkedBlockingQueue类似，用双链表+ReentrantLock实现</li><li>用一个锁对两端的入队出队进行并发控制</li><li>linkXXX、unlinkXXX与enqueue、dequque功能及实现类似</li><li>addLFirst、addLast等同理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; prev;<br>    Node&lt;E&gt; next;<br>    Node(E x) &#123;<br>      item = x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><ul><li>带延迟的无界的阻塞队列，通过PriorityQueue（优先队列）、Delayed与ReentrantLock实现</li><li>用一个锁对PriorityQueue的入队出队进行并发控制</li><li>入队操作的add和put直接调用offer方法</li><li>出队操作返回延迟期满后的第一个元素，如果队列中没有元素或者没有延迟期满的元素，则poll操作返回null，take操作阻塞等待</li><li>使用leader线程避免大量线程在同一时间点唤醒产生大量竞争 &#x2F;&#x2F; todo：理解具体实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Delayed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Delayed&gt; &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span>; <span class="hljs-comment">// 返回剩余延迟时间</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayQueue</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Delayed</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;E&gt;();<br>  <br>  <span class="hljs-comment">// 避免大量线程在同一时间点唤醒，导致大量的竞争，影响性能</span><br>  <span class="hljs-comment">// Leader-Follower模式的变体</span><br>    <span class="hljs-keyword">private</span> Thread leader;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            q.offer(e);<br>            <span class="hljs-keyword">if</span> (q.peek() == e) &#123;<br>                leader = <span class="hljs-literal">null</span>;<br>                available.signal();<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> q.peek();<br>            <span class="hljs-keyword">return</span> (first == <span class="hljs-literal">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="hljs-number">0</span>)<br>                ? <span class="hljs-literal">null</span><br>                : q.poll();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> q.peek();<br>                <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>)<br>                    available.await();<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);<br>                    <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0L</span>)<br>                        <span class="hljs-keyword">return</span> q.poll();<br>                    first = <span class="hljs-literal">null</span>; <span class="hljs-comment">// don&#x27;t retain ref while waiting</span><br>                    <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>)<br>                        available.await();<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                        leader = thisThread;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            available.awaitNanos(delay);<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-keyword">if</span> (leader == thisThread)<br>                                leader = <span class="hljs-literal">null</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; q.peek() != <span class="hljs-literal">null</span>)<br>                available.signal();<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>  <br>     <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> q.peek();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br> <br></code></pre></td></tr></table></figure><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><ul><li>并发安全的优先队列</li><li><a href="https://www.cnblogs.com/sergeantFat/p/14492538.html">阻塞优先队列（PriorityBlockingQueue）详解</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><ul><li>容量为0的阻塞队列</li><li>基于CAS无锁算法实现</li><li><a href="https://www.jianshu.com/p/d5e2e3513ba3">12. SynchronousQueue</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><ul><li>相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。可以算是 <code>LinkedBolckingQueue</code> 和 <code>SynchronousQueue</code> 和合体</li><li>底层基于单链表实现,其内部节点分为数据结点、请求结点；基于CAS无锁算法实现</li><li><a href="https://blog.csdn.net/weixin_49561445/article/details/120599614">LinkedTransferQueue</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedTransferQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransferQueue</span>&lt;E&gt;, java.io.Serializable &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h2><ol><li><p>在线程池作为任务队列</p></li><li><p>延迟队列（DelayQueue）</p><p>场景：大批量的任务处理，比如说卖票，一次性放出太多情况下系统无法承受压力</p></li><li><p>定时任务（DelayQueue）</p></li><li><p>缓存系统的设计（DelayQueue）</p><p>一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</p></li><li><p>信息同步传递[消费线程和生产线程 1:1]（SynchronousQueue）</p><p>场景：核心线程数为0的线程池</p></li></ol><h2 id="五、参考文档"><a href="#五、参考文档" class="headerlink" title="五、参考文档"></a>五、参考文档</h2><p>本文的部分内容参考或者引用以下文章，在此表示感谢，如果有涉及知识产权的问题，请联系我及时修改。</p><ul><li>jdk-11.0.2.jdk</li><li><a href="https://blog.csdn.net/c15158032319/article/details/118636233">延迟队列DelayQueue原理</a></li><li><a href="https://www.cnblogs.com/sergeantFat/p/14492538.html">阻塞优先队列（PriorityBlockingQueue）详解</a></li><li><a href="https://www.jianshu.com/p/d5e2e3513ba3">12. SynchronousQueue</a></li><li><a href="https://blog.csdn.net/weixin_49561445/article/details/120599614">LinkedTransferQueue</a></li><li><a href="https://blog.csdn.net/csfun1/article/details/122524692">并发编程-06 BlockingQueue及应用场景详解</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库锁机制</title>
    <link href="/Mysql/locking/"/>
    <url>/Mysql/locking/</url>
    
    <content type="html"><![CDATA[<h1 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h1><ul><li>行级锁<ul><li>共享锁</li><li>排他锁</li></ul></li><li>表级锁</li><li>意向锁</li></ul><h1 id="查看锁情况"><a href="#查看锁情况" class="headerlink" title="查看锁情况"></a>查看锁情况</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">FULL</span> PROCESSLIST<br></code></pre></td></tr></table></figure><h3 id="InnoDB-1-0开始在INFORMATION-SCHEMA架构添加了三张表可以查看"><a href="#InnoDB-1-0开始在INFORMATION-SCHEMA架构添加了三张表可以查看" class="headerlink" title="InnoDB 1.0开始在INFORMATION_SCHEMA架构添加了三张表可以查看"></a>InnoDB 1.0开始在INFORMATION_SCHEMA架构添加了三张表可以查看</h3><p>INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS</p>]]></content>
    
    
    
    <tags>
      
      <tag>锁</tag>
      
      <tag>数据库</tag>
      
      <tag>MySql</tag>
      
      <tag>InnoDB存储引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程池</title>
    <link href="/Java/Thread_pool/"/>
    <url>/Java/Thread_pool/</url>
    
    <content type="html"><![CDATA[<h2 id="一、基本参数"><a href="#一、基本参数" class="headerlink" title="一、基本参数"></a>一、基本参数</h2><p>新建一个线程池实例可调用Executors的newCachedThreadPool()、newFixedThreadPool()等方法，实际上这些方法的底层都是调用的ThreadPoolExecutor的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              TimeUnit unit,</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              ThreadFactory threadFactory,</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>corePoolSize</strong>：指定线程池的核心线程数，核心线程能够一直存活在线程池中。</li><li><strong>maximumPoolSize</strong>：指定线程池能存活的最大线程数，要求maximumPoolSize &gt;&#x3D; corePoolSize，最大线程数与核心线程数的差值为线程池内临时线程的最大数目。</li><li>keepAliveTime：临时线程存活时间，<strong>临时线程</strong>在<strong>空闲</strong>超过当前时间时会被销毁。</li><li>unit：keepAliveTime的时间单位。</li><li><strong>workQueue</strong>：任务队列，被提交到线程池的尚未被执行的任务。</li><li>threadFactory：用于创建线程的线程工厂，一般使用默认工厂。 非必需传入。</li><li><strong>handler</strong>：拒绝策略，任务太多情况下使用拒绝策略处理超出任务。非必需传入。</li></ul><p>具体信息见源码解读&gt;关键参数</p><h2 id="二、线程池状态"><a href="#二、线程池状态" class="headerlink" title="二、线程池状态"></a>二、线程池状态</h2><p>线程池有五种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure><h2 id="三、执行机制"><a href="#三、执行机制" class="headerlink" title="三、执行机制"></a>三、执行机制</h2><p><img src="/Java/Thread_pool/f228f23338ef4a0ebd615b965fd94894.png" alt="线程池执行机制"></p><h2 id="四、源码解读"><a href="#四、源码解读" class="headerlink" title="四、源码解读"></a>四、源码解读</h2><h3 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h3><h4 id="1-corePoolSize"><a href="#1-corePoolSize" class="headerlink" title="1. corePoolSize"></a>1. corePoolSize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> corePoolSize;<br></code></pre></td></tr></table></figure><ul><li>volatile修饰</li><li>最小值为0</li><li>不允许超时销毁，会一直存活在线程池内，除非设置了允许核心线程超时（allowCoreThreadTimeOut &#x3D; true）</li></ul><h4 id="2-maximumPoolSize"><a href="#2-maximumPoolSize" class="headerlink" title="2. maximumPoolSize"></a>2. maximumPoolSize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> maximumPoolSize;<br></code></pre></td></tr></table></figure><ul><li>最大线程数目</li><li>超时销毁</li><li>值大于等于核心线程数目</li></ul><h4 id="3-workQueue"><a href="#3-workQueue" class="headerlink" title="3. workQueue"></a>3. workQueue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br></code></pre></td></tr></table></figure><p>The queue used for holding tasks and handing off to worker threads.  We do not require that workQueue.poll() returning null necessarily means that workQueue.isEmpty(), so rely solely on isEmpty to see if the queue is empty (which we must do for example when deciding whether to transition from SHUTDOWN to TIDYING).  This accommodates special-purpose queues such as DelayQueues for which poll() is allowed to return null even if it may later return non-null when delays expire.</p><ul><li>存放待工作线程处理的任务</li></ul><p><strong>BlockQueue的继承与实现</strong></p><p><img src="/Java/Thread_pool/image-20221021111242474.png" alt="image-20221021111242474"></p><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </p><h3 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h3><h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><h2 id="五、使用场景与优缺点"><a href="#五、使用场景与优缺点" class="headerlink" title="五、使用场景与优缺点"></a>五、使用场景与优缺点</h2><p>空间换时间</p><h2 id="六、面试与思考"><a href="#六、面试与思考" class="headerlink" title="六、面试与思考"></a>六、面试与思考</h2><ol><li><strong>线程池参数及含义。</strong></li><li><strong>向线程池提交一个任务会直接运行吗？</strong></li><li>线程池任务提交流程。</li><li>线程池是如何保持池内线程存活的。</li></ol><h2 id="七、参考文档"><a href="#七、参考文档" class="headerlink" title="七、参考文档"></a>七、参考文档</h2><p>本文的部分内容参考或者引用以下文章，在此表示感谢，如果有涉及知识产权的问题，请联系我及时修改。</p><ul><li>《实战Java高并发程序设计》</li><li><a href="https://blog.csdn.net/qq_37602560/article/details/123845442">线程池的-任务执行机制</a></li><li>jdk-11.0.2.jdk</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
      <tag>源码</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣2312. 卖木头块</title>
    <link href="/Algorithm/selling-pieces-of-wood/"/>
    <url>/Algorithm/selling-pieces-of-wood/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/selling-pieces-of-wood/description/">https://leetcode.cn/problems/selling-pieces-of-wood/description/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP</title>
    <link href="/Algorithm/KMP/"/>
    <url>/Algorithm/KMP/</url>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>字符串匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/Architecture/docker/"/>
    <url>/Architecture/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h1><h2 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h2><p>Docker是一个<strong>轻量级</strong>的可以将应用及其依赖进行打包并发布到不同操作系统的Linux<strong>容器</strong>的一种封装。Docker本身并不是容器，它是创建容器的工具，是应用容器引擎。</p><h2 id="Docker的核心概念"><a href="#Docker的核心概念" class="headerlink" title="Docker的核心概念"></a>Docker的核心概念</h2><p>• 镜像（Image）：一组应用及其依赖的打包，是一个只读的提供容器运行时所需的程序、库、资源、配置等文件以及一些为运行时准备的配置参数的环境打包。</p><p>• 容器（Container）：是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除</p><p>• 仓库（Repository）：是docker存放镜像的场所</p><h2 id="操作系统、虚拟机、容器和进程有什么区别"><a href="#操作系统、虚拟机、容器和进程有什么区别" class="headerlink" title="操作系统、虚拟机、容器和进程有什么区别"></a>操作系统、虚拟机、容器和进程有什么区别</h2><p>操作系统</p><p><img src="/Architecture/docker/v2-145c3cb904f8696ea68dbcb54b24938b_1440w.webp" alt="img"></p><h2 id="关于k8s"><a href="#关于k8s" class="headerlink" title="关于k8s"></a>关于k8s</h2><h1 id="Docker怎么用"><a href="#Docker怎么用" class="headerlink" title="Docker怎么用"></a>Docker怎么用</h1><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>本文的部分内容参考或者引用以下文章，在此表示感谢，如果有涉及知识产权的问题，请联系我及时修改。</p><ul><li><a href="https://blog.csdn.net/crazymakercircle/article/details/120747767">Docker原理（图解+秒懂+史上最全）</a></li><li><a href="https://zhuanlan.zhihu.com/p/144292368">云原生时代（四）：容器和Docker</a></li><li><a href="https://www.cnblogs.com/My-zhanglulu/p/16274319.html">什么是Docker容器?(全面了解使用)</a></li></ul><p>未完待续。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>云计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/Algorithm/Knapsack%20problem/"/>
    <url>/Algorithm/Knapsack%20problem/</url>
    
    <content type="html"><![CDATA[<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>可转换为取或者不取第i个物品的问题，递推公式为：dp[i][v]&#x3D; Max(dp[i-1][v], dp[i-1][v-c[i]] + w[i])，其中dp[i][v]为对于前i个物品有一个容量为v的背包，此时能装入的最大价值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 注：0是补充对齐的</span><br>        <span class="hljs-type">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>, V = <span class="hljs-number">5</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; v &lt;= V; v++) &#123;<br>                dp[i][v] = dp[i-<span class="hljs-number">1</span>][v];<br>                <span class="hljs-keyword">if</span>(v &gt;= c[i])&#123;<br>                    dp[i][v] = Math.max(dp[i][v], dp[i-<span class="hljs-number">1</span>][v-c[i]] + w[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            System.out.println(Arrays.toString(dp[i]));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">output：<br><span class="hljs-string">[0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 2]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 2]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 3]</span><br><span class="hljs-string">[0, 0, 2, 4, 4, 6]</span><br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span>[] dp2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[V+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> V; v &gt;= c[i] ; v--) &#123;<br>    dp2[v] = Math.max(dp2[v-c[i]]+w[i],dp2[v]);<br>  &#125;<br>  System.out.println(Arrays.toString(dp2));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 2]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 2]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 3]</span><br><span class="hljs-string">[0, 0, 2, 4, 4, 6]</span><br></code></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li><a href="https://leetcode-cn.com/problems/target-sum/">目标和</a>：转化问题以后为0-1背包方案数问题。</li><li><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a>：转化后为0-1背包可行性问题。</li><li><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后一块石头的重量 II</a>：转化后为0-1背包最小值问题。</li></ul><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><ul><li><p><input checked disabled type="checkbox"> <a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a>：完全背包最小值</p></li><li><p><input checked disabled type="checkbox"> <a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a>：完全背包最小值</p></li></ul><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><ul><li><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">01 字符构成最多的字符串</a>：多维费用的 0-1 背包最大值，两个背包大小：0和1的数量</li><li><a href="https://leetcode-cn.com/problems/profitable-schemes/">盈利计划</a>：多维费用的 0-1 背包最大值</li></ul><h2 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h2><h2 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h2><ul><li><a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/">掷骰子的N种方法</a>：每一组是一个骰子，每个骰子只能拿一个体积为1到6的物品</li></ul><h2 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h2><h2 id="背包问题求方案数"><a href="#背包问题求方案数" class="headerlink" title="背包问题求方案数"></a>背包问题求方案数</h2><ul><li><input disabled type="checkbox"> <a href="https://leetcode.cn/problems/coin-change-ii/">零钱兑换 II</a>：完全背包方案数</li><li><input disabled type="checkbox"> <a href="https://leetcode-cn.com/problems/combination-sum-iv/">组合总和 Ⅳ</a>：考虑物品顺序的完全背包方案数。每个物品可以重复拿，有几种装满背包的方案？</li></ul><h2 id="背包问题求具体方案"><a href="#背包问题求具体方案" class="headerlink" title="背包问题求具体方案"></a>背包问题求具体方案</h2><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li><a href="https://github.com/tianyicui/pack">背包问题九讲 2.0 beta1.2 崔添翼 (Tianyi Cui)*</a></li><li><a href="https://blog.csdn.net/e891377/article/details/117639203">LeetCode背包问题—题目列表</a></li></ul><p>未完待续。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统IO详解</title>
    <link href="/OS/IO/"/>
    <url>/OS/IO/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>IO</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
