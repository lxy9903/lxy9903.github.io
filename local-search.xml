<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>post</title>
    <link href="/MPI/Introduction-to-Parallel-Programming/OpenMP/"/>
    <url>/MPI/Introduction-to-Parallel-Programming/OpenMP/</url>
    
    <content type="html"><![CDATA[<h1 id="第二周、OpenMP"><a href="#第二周、OpenMP" class="headerlink" title="第二周、OpenMP"></a>第二周、OpenMP</h1><h2 id="第一节、Getting-started-with-OpenMP"><a href="#第一节、Getting-started-with-OpenMP" class="headerlink" title="第一节、Getting started with OpenMP"></a>第一节、Getting started with OpenMP</h2><h3 id="一、Welcome-to-Week-2"><a href="#一、Welcome-to-Week-2" class="headerlink" title="一、Welcome to Week 2"></a>一、Welcome to Week 2</h3><p>OpenMP是一个共享内存的线程编程模型，可以用来逐步升级现有的代码以实现并行执行。升级后的代码仍然可以进行串行编译。这是OpenMP的一个很大的特点，它让你有机会检查并行执行是否提供了与串行版本相同的结果。为了更好地理解自动并行化，我们首先要看一下运行时函数。在简单的OpenMP程序中通常不需要这些函数。我们将介绍一些基本的编译器或pragma指令和变量的范围，以了解对内存的线程访问逻辑。</p><p>工作共享指令和线程的同步将在几个例子中讨论。如何从线程中收集结果，将用常见的减少条款来说明。在本周结束时，我们将介绍有趣的基于任务的并行化方法。不要忘了用练习来做实验，因为这些是你主要的学习机会。让我们开始吧。 本周的结构受到了HLRS OpenMP课程的启发（礼尚往来。Rolf Rabenseifner（HLRS））。</p><h3 id="二、Runtime-functions"><a href="#二、Runtime-functions" class="headerlink" title="二、Runtime functions"></a>二、Runtime functions</h3><p>运行时函数（Runtime functions）的目的是管理或修改我们想在代码中使用的并行进程。它们随OpenMP库而来。</p><p>对于C++和C，你可以添加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> &lt;omp.h</span><br></code></pre></td></tr></table></figure><p>头文件到你的代码的开头，然后这个库包括所有你需要的和你想使用的标准运行时函数。我们今天将在教程中使用的函数可以从成绩单中的链接或资源中获取。</p><ul><li>要设置所需的线程数，使用</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_set_num_threads</span><span class="hljs-params">(n)</span></span><br></code></pre></td></tr></table></figure><p>例如，如果你想用12个线程来并行化你的程序，你可以用函数指定程序中的线程数，比如说</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_set_num_threads</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span><br></code></pre></td></tr></table></figure><ul><li>要返回当前的线程数，请使用</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_get_num_threads</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><ul><li>要返回这个线程的ID，使用</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_get_thread_num</span><span class="hljs-params">()</span></span> <br></code></pre></td></tr></table></figure><ul><li>To return <code>true</code> if inside parallel region, use</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_in_parallel</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>如果它被指定在一个平行区域内，该函数返回true。如果不是，也就是说，如果它被指定在串行区域内，它将返回false。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>Let’s observe the following example.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">omp_set_num_threads</span>(num_threads);<br>    <span class="hljs-type">int</span> rank;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>    &#123;<br>        rank = <span class="hljs-built_in">omp_get_thread_num</span>();<br>        <span class="hljs-type">int</span> nr_threads = <span class="hljs-built_in">omp_get_num_threads</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am thread %i of %i threads\n&quot;</span>,<br>        rank,<br>        nr_threads);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>花点时间，试着理解上面的代码中发生了什么。</p><ul><li><p>预期的输出是什么？rank和nr_threads的值是多少？</p><p>I am thread 0 of 4 threads</p><p>I am thread 1 of 4 threads</p><p>I am thread 2 of 4 threads</p><p>I am thread 3 of 4 threads</p></li><li><p>输出总是一样的吗？线程的打印顺序是什么？</p><p>不一样，打印顺序应该随机</p></li><li><p>如果我们把线程的数量改为12，会发生什么？</p><p>会打印十二次</p><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221127203248794.png" alt="image-20221127203248794"></p></li></ul><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>使用私有变量设置线程数</p><h3 id="三、Variables-and-constructs"><a href="#三、Variables-and-constructs" class="headerlink" title="三、Variables and constructs"></a>三、Variables and constructs</h3><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>接下来我们要看的是环境变量。与运行时函数相反，环境变量不是在代码中使用的，而是在环境中指定的，在那里你正在编译和运行你的代码。环境变量的目的是为了在运行时控制并行程序的执行。由于这些变量不是在代码中指定的，你可以在编译和运行你的程序之前，例如在Linux终端指定它们。让我们来看看三个最常见的环境变量：</p><ul><li><p><strong>指定要使用的线程数</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">OMP_NUM_THREADS</span>=4<br></code></pre></td></tr></table></figure></li><li><p><strong>指定线程应该放在哪个CPU上，可以使用</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">OMP_PLACES</span> <br></code></pre></td></tr></table></figure></li><li><p><strong>要显示OpenMP的版本和环境，使用</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">OMP_DISPLAY_ENV</span>  <br></code></pre></td></tr></table></figure><h4 id="Parallel-constructs"><a href="#Parallel-constructs" class="headerlink" title="Parallel constructs"></a>Parallel constructs</h4><p>并行结构是使用OpenMP时的基本结构。所以，每个线程基本上都同时执行平行区域内的相同语句，正如你在这张图片上看到的。</p><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221128153335944.png" alt="image-20221128153335944"></p><p>所以，首先我们有一个主线程，执行代码的串行部分。然后我们来到了一个pragma omp语句。我们在这里可以看到，主线程首先遇到了这个omp结构，并创建了多个线程，也就是我们所说的并行运行的从线程。随后，主线程和从线程在彼此之间划分了任务。最后，我们指定了一个隐含的障碍，所以当达到这个障碍时，线程结束，我们等待所有线程完成执行。在这之后，当所有的线程都完成了执行，我们回到主线程，最终恢复代码的执行。当然，在这一步骤中，从属线程已经消失了，因为它们已经完成了自己的任务。</p><p>在C语言中，这个隐含的屏障被指定为</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>&#123;<br>...<br> &#125;<br></code></pre></td></tr></table></figure><p>Let’s observe the following code.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>  <span class="hljs-built_in">omp_set_num_threads</span>(num_threads);<br>  <span class="hljs-type">int</span> rank;<br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>  &#123;<br>  rank = <span class="hljs-built_in">omp_get_thread_num</span>();<br>  <span class="hljs-type">int</span> nr_threads = <span class="hljs-built_in">omp_get_num_threads</span>();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am thread %i of %i threads\n&quot;</span>,<br>   rank,<br>   nr_threads);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="四、Clauses-and-directive-format"><a href="#四、Clauses-and-directive-format" class="headerlink" title="四、Clauses and directive format"></a>四、Clauses and directive format</h3><h4 id="Directive-format（指令格式）"><a href="#Directive-format（指令格式）" class="headerlink" title="Directive format（指令格式）"></a>Directive format（指令格式）</h4><p>到目前为止，我们只是指定了一个并行区域，并且代码是以串行方式执行的。现在我们将继续前进，看看OpenMP的指令。使用指令的格式如下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp directive_name [clause[clause]...]</span><br></code></pre></td></tr></table></figure><p>我们已经看到并使用了pragma omp parallel，它是一个并行执行区域的指令。在这种格式中，我们也有一些子句，以指定不同的参数。例如，私有变量是指对每个线程都是私有的变量，而共享变量是指对所有线程共享的变量，任何线程都可以访问和修改它。</p><p>我们将在下面的小节中更多地探讨这些条款。现在，我们将学习一下条件语句。与任何编程语言类似，OpenMP也有条件语句。因此，举例来说，我们也可以在OpenMP中以如下方式指定一个if语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _OPENMP</span><br><span class="hljs-comment">//block of code to be executed if code was compiled with OpenMP, for example</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Number of threads: %d&quot;</span>, omp_get_num_threads);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">//block of code to be executed if code was compiled without OpenMP</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>下面的例子说明了条件编译的使用。通过OpenMP编译，_OPENMP被定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> rank;<br>  <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _OPENMP</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(4) private(rank)</span><br>  &#123;<br>    rank = <span class="hljs-built_in">omp_get_thread_num</span>();<br>    <span class="hljs-type">int</span> nr_threads = <span class="hljs-built_in">omp_get_num_threads</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am thread %i of %i threads\n&quot;</span>,<br>     rank,<br>     nr_threads);<br>  &#125;<br>  <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This program is not compiled with OpenMP\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><blockquote><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ gcc example.c<br>This program is not compiled with OpenMP<br><br>$ gcc -fopenmp example.c<br>I am thread<span class="hljs-number"> 3 </span>of<span class="hljs-number"> 4 </span>threads<br>I am thread<span class="hljs-number"> 2 </span>of<span class="hljs-number"> 4 </span>threads<br>I am thread<span class="hljs-number"> 1 </span>of<span class="hljs-number"> 4 </span>threads<br>I am thread<span class="hljs-number"> 0 </span>of<span class="hljs-number"> 4 </span>threads<br></code></pre></td></tr></table></figure></blockquote></blockquote><h4 id="Clauses（条款）"><a href="#Clauses（条款）" class="headerlink" title="Clauses（条款）"></a>Clauses（条款）</h4><p>我们刚刚学习的指令格式</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp directive_name [clause[clause]...]</span><br></code></pre></td></tr></table></figure><p>是OpenMP的一个重要的关键字，我们把它放在代码的开头，放在我们想让并行区域开始的那一行，然后我们提到指令名称和子句。在本小节中，我们将学习条款。</p><p>基本上有两种条款，即：私有或共享。一个私有变量将是一个对每个线程都是私有的变量。</p><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221128155745412.png" alt="image-20221128155745412"></p><p>So, we execute, e.g.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> A;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(A)</span><br>&#123;<br>    A=<span class="hljs-built_in">omp_get_thread_num</span>();<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们在C代码中定义了一个整数A。然后我们定义了OpenMP指令，omp parallel和private A。因此，这里发生的情况是，任何时候我们都会得到一个新的线程，这个变量A将被单独分配给每个线程。这意味着，A的值将与线程的数量有关。因此，在第一个线程中，它将是0，在第二个线程中，这个变量的值将是1，因为这将是线程的ID，在第三个线程中的值将是2，以此类推。我们可以清楚地看到，这些变量基本上是私有的，这意味着它们存在于每个线程中。这意味着，第一个线程中的变量A（0）不能被第二个线程中的变量A（1）访问。所以，这就推断出这个变量对我们程序中的每个单独的线程来说基本上是私有的。当然，与此相反的是共享变量。如果我们指定一个变量是共享变量，这将标志着该变量将在线程之间共享。如果我们在并行区域之外指定该变量，那么就在</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br></code></pre></td></tr></table></figure><p>这个变量将被每个线程访问。举例来说，如果我们有一个for循环，并且我们在每次迭代中都向它添加一个数字，我们可以直接指定它为一个共享变量。在这种情况下，每当任何线程更新共享变量时，它都会向其中添加数字。这是一种使用for循环的适当方式，我们将在下面的小节中看到。 因此，总结一下，私有和共享的区别：私有变量只对一个线程可用，不能被其他任何线程访问，而共享变量不仅可以被程序中的每个线程访问，而且还可以被每个线程同时更新。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> num_threads = <span class="hljs-number">10</span>;<br>  <span class="hljs-built_in">omp_set_num_threads</span>(num_threads);<br><br>  <span class="hljs-type">int</span> private_var = <span class="hljs-number">1000</span>;<br>  <span class="hljs-type">int</span> shared_var = <span class="hljs-number">5000</span>;<br>  <span class="hljs-type">int</span> rank;<br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(private_var, rank) shared(shared_var)</span><br>  &#123;<br>    rank = <span class="hljs-built_in">omp_get_thread_num</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread ID is: %d\n&quot;</span>, rank);  <br>    private_var = private_var + num_threads;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of private_var is: %d\n&quot;</span>, private_var);<br>    shared_var = shared_var + num_threads;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of shared_var is: %d\n&quot;</span>, shared_var);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的代码并观察输出。当被不同的线程访问时，私有和共享变量的值如何变化？当被多个线程修改时，共享变量的值是否增加？为什么？</p><p>被不同线程访问时私有变量private_var初始值不变，共享变量初始值shared_var会改变。</p><p><strong>多个线程修改时，共享变量的值不一定增加，可能发生并发修改and修改丢失。</strong>❌</p><p>这里可能还存在一个竞赛条件。并行区域内的变量的写入和立即读取是一个写-读竞赛条件。两个或多个线程访问同一个共享变量并对其进行修改，这些访问是不同步的。我们将在并行区域练习中看到一个更清晰的竞赛条件的例子。</p><p>！！结果显示，并没有发生并发问题</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">5</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5010</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">8</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5020</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5030</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5040</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">9</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5050</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">2</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5060</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">6</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5070</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">4</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5080</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">3</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5090</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">7</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5100</span><br></code></pre></td></tr></table></figure><h3 id="五、Clauses"><a href="#五、Clauses" class="headerlink" title="五、Clauses"></a>五、Clauses</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">omp_set_num_threads</span>(num_threads);<br><br>    <span class="hljs-type">int</span> private_var = <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">int</span> shared_var = <span class="hljs-number">5000</span>;<br>    <span class="hljs-type">int</span> rank;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(private_var) shared(shared_var)</span><br>    &#123;<br>        rank = <span class="hljs-built_in">omp_get_thread_num</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread ID is: %d\n&quot;</span>, rank);  <br>        private_var = private_var + num_threads;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of private_var is: %d\n&quot;</span>, private_var);<br>        shared_var = shared_var + num_threads;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of shared_var is: %d\n&quot;</span>, shared_var);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>花点时间，试着理解上面的代码中发生了什么。</p><ul><li><p>当被不同的线程访问时，私有和共享变量的值如何变化？</p><p>被不同线程访问时私有变量private_var初始值不变（<strong>为0！</strong>），共享变量初始值shared_var会改变。</p></li><li><p>当被多个线程修改时，共享变量的值是否增加？为什么？</p><p><strong>多个线程修改时，共享变量的值不一定增加，可能发生并发修改and修改丢失？</strong></p><p><strong>运行没有出现这个现象，但是助教在评论中提到了会出现race condition</strong> </p></li><li><p>当被多个线程修改时，私有变量的值是否会增加？</p></li></ul><p>现在去做练习，试一试，检查你的答案是否正确。</p><h3 id="六、Parallel-region"><a href="#六、Parallel-region" class="headerlink" title="六、Parallel region"></a>六、Parallel region</h3><p>在这个练习中，你将得到练习使用基本的运行时函数、指令格式、并行结构和条款，这些都是我们到目前为止学到的。</p><p>这个练习的代码在Jupyter笔记本的以下说明中。你将从这个提供的Hello world模板开始。预期的输出是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    i = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world %d\n&quot;</span>, i );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><ol><li>进入练习，使用其中一个运行时函数将所需的线程数设置为4。✅</li><li>使用其中一个运行时函数将变量i设置为该线程的ID。✅</li><li>添加一个并行区域，使代码并行运行。✅</li><li>在包含OpenMP头文件和使用运行时函数时，添加OpenMP条件条款。✅</li></ol><p>在你运行这个程序之前，你认为会发生什么？ 现在，运行该程序并观察输出。你可以将线程数改为12个或其他，观察输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">%%file exercise.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br><br>    i = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">12</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _OPENMP</span><br>    <span class="hljs-built_in">omp_set_num_threads</span>(num_threads);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel </span><br>    &#123;<br>        i = <span class="hljs-built_in">omp_get_thread_num</span>();<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world openmp %d\n&quot;</span>, i );<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world gcc %d\n&quot;</span>, i );<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221128210815541.png" alt="image-20221128210815541"></p><ol><li>为变量i的并行区域添加一个私有子句。</li></ol><p>会发生什么？观察输出的差异。为什么输出会不同？检查你是否得到一个竞赛条件。</p><p>竞赛条件(Race condition):</p><ul><li>两个线程访问同一个共享变量，并且至少有一个线程修改了该变量，并且访问没有同步化。</li><li>程序的结果取决于团队中各线程的时间。</li><li>这是由非故意的数据共享造成的。</li></ul><p><strong>不要担心你是否总是得到正确的输出，因为编译器可能在每个线程上使用一个私有寄存器，而不是直接写入内存中</strong></p><ul><li>If compiled with OpenMP, the program should output »hello world« and the ID of each thread.</li></ul><h2 id="第二节、Worksharing-directives（工作共享指令）"><a href="#第二节、Worksharing-directives（工作共享指令）" class="headerlink" title="第二节、Worksharing directives（工作共享指令）"></a>第二节、Worksharing directives（工作共享指令）</h2><h3 id="一、Which-thread-executes-which-statement-or-operation"><a href="#一、Which-thread-executes-which-statement-or-operation" class="headerlink" title="一、Which thread executes which statement or operation?"></a>一、Which thread executes which statement or operation?</h3><p>在下面的步骤中，我们要学习如何真正地平行组织我们的工作。请分享你对我们如何实现这一目标的想法。</p><p>你知道有哪些可能的并行组织工作的方法吗？如何在线程之间分配操作？有什么方法可以控制线程的顺序吗？</p><h3 id="二、OpenMP-constructs"><a href="#二、OpenMP-constructs" class="headerlink" title="二、OpenMP constructs"></a>二、OpenMP constructs</h3><h4 id="Worksharing-constructs（工作共享结构）"><a href="#Worksharing-constructs（工作共享结构）" class="headerlink" title="Worksharing constructs（工作共享结构）"></a>Worksharing constructs（工作共享结构）</h4><p>工作共享结构将代码区域的执行在团队线程的不同成员之间进行划分。这些结构不启动新的线程，它们被动态地包围在并行区域内。工作共享结构体的一些例子是。</p><ul><li>sections</li><li>for</li><li>task</li><li>single</li></ul><h4 id="Section-construct"><a href="#Section-construct" class="headerlink" title="Section construct"></a>Section construct</h4><p>我们首先将看到一个使用section结构的代码例子，我们可以通过指令性的section来指定它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp sections</span><br>    &#123;<br>      <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>      &#123;<br>        <span class="hljs-built_in">function_1</span>();<span class="hljs-comment">// a=... b=...</span><br>      &#125;<br>      <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>      &#123; <br>        <span class="hljs-built_in">function_2</span>();<span class="hljs-comment">// c=... d=...</span><br>      &#125;<br>    &#125;<br>&#125;<span class="hljs-comment">// end of parallel</span><br></code></pre></td></tr></table></figure><p>当我们使用section结构时，多个代码块被并行执行。当我们指定章节并将一个任务放入其中时，这个特定的任务将在一个线程中执行。然后，当我们进入另一个部分时，它将在不同的线程中执行其任务。这样，我们就可以在pragma omp并行代码中添加这些部分，为每个线程指定一个部分，这些部分将在每个单独的线程中执行。</p><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221128212103284.png" alt="image-20221128212103284"></p><p>在上面的示例代码中，我们可以看到，在这一节中，我们指定了变量a和b。当这段代码被执行时，一个新的线程会带着这些变量产生，同样的，变量c和d也被指定在不同的一节中，因此也在不同的线程中。</p><p>Eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp">%%file sections.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Function 1 done by thread %d \n&quot;</span> , <span class="hljs-built_in">omp_get_thread_num</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j != <span class="hljs-number">2</span>; j++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Function 2 done by thread %d \n&quot;</span> , <span class="hljs-built_in">omp_get_thread_num</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>; <span class="hljs-comment">//number of threads</span><br>    <span class="hljs-built_in">omp_set_num_threads</span>(n);<br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp sections</span><br>        &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>            &#123;<br>                <span class="hljs-built_in">function_1</span>();<br>            &#125;<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>            &#123; <br>                <span class="hljs-built_in">function_2</span>();<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br>output:<br>Function <span class="hljs-number">2</span> done by thread <span class="hljs-number">0</span> <br>Function <span class="hljs-number">2</span> done by thread <span class="hljs-number">0</span> <br>Function <span class="hljs-number">1</span> done by thread <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="For-construct"><a href="#For-construct" class="headerlink" title="For construct"></a>For construct</h4><p>在计算机科学中，for-loop是一个指定迭代的控制流语句。这使得代码可以被反复执行。这样的任务，动作相似，多次执行，也可以被并行化。在OpenMP中，我们可以使用#pragma omp中的for结构。简单地说，for结构可以被看作是一个并行化的for循环。我们可以将for结构指定为</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#pragma omp for <span class="hljs-comment">[clause<span class="hljs-comment">[<span class="hljs-comment">[,]</span>clause]</span>...]</span><br></code></pre></td></tr></table></figure><p>这里我们也是以pragma omp开始，后面是for关键字，我们可以再次使用不同的子句，即私有的、共享的等等。相应的for-loop必须有一个规范的形状。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (int i<span class="hljs-operator">=</span>it<span class="hljs-comment">; i&lt;M; i++)</span><br></code></pre></td></tr></table></figure><p>由于每个迭代器默认是一个私有变量，并且只由一个线程共享，所以迭代器在循环体中不会被修改。如果它被每个线程访问，我们的for-loop就会被破坏。</p><p>除了private，我们还有一些其他的子句。比如说。</p><ul><li>schedule。它对循环的迭代如何在线程之间分配进行分类。</li><li>collapse(n)。n个循环的迭代被折叠成一个更大的迭代空间。</li></ul><p>我们可以看到代码中使用for结构的一个例子。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(f)</span><br>&#123;<br>    f=<span class="hljs-number">10</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>        a[i] = b[i]*f;<br>    &#125; <span class="hljs-comment">// end of for</span><br>&#125; <span class="hljs-comment">// end of parallel</span><br></code></pre></td></tr></table></figure><p>我们用pragma omp parallel开始，然后是名为f的私有变量。然后我们用pragma omp for构造，接着是一个从0到10的for循环（10次不同的迭代）。然后，私有变量f在每个线程中都是固定的，列表a被并行更新。这是因为每个数组需要的索引都是不同的。所以，每个线程只能访问数组的一个地方，允许我们并行更新这个列表。</p><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221128212831945.png" alt="image-20221128212831945"></p><p>在这里我们可以看到，如果我们在两个线程上工作，有10个迭代，那么这些迭代将被分成两个线程，分别从0到4和5到9。列表a上的每个地方都将被自己更新，由于迭代器是相互独立的，它们只修改一个地方，所以我们可以很容易地更新列表a的每个地方。</p><p>Eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file forloop.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>; <span class="hljs-comment">//number of threads</span><br>    omp_set_num_threads(n);<br><span class="hljs-type">int</span>* iterations; <span class="hljs-comment">//count iterations for each thread</span><br>iterations = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span> (n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br><span class="hljs-type">int</span> f = <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">//set array values to 0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> loop = <span class="hljs-number">0</span>; loop &lt; n; loop++)<br>&#123;<br>    iterations[loop] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel shared(iterations, f)</span><br>&#123;    <br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; f; i++)<br>    &#123;<br>        iterations[omp_get_thread_num()]++;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> loop = <span class="hljs-number">0</span>; loop &lt; n; loop++)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, iterations[loop]);<br>&#125;<br><br><span class="hljs-built_in">free</span>(iterations);  <br>&#125;<br><br>output:<br><span class="hljs-number">25</span> <span class="hljs-number">25</span> <span class="hljs-number">25</span> <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><h4 id="pragma-omp-single"><a href="#pragma-omp-single" class="headerlink" title="#pragma omp single"></a>#pragma omp single</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file single.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>; <span class="hljs-comment">//number of threads</span><br>    omp_set_num_threads(n);<br>    <span class="hljs-type">int</span> sum1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> sum2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> f = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel shared(sum1, sum2)</span><br>    &#123;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; f; i++)<br>        &#123;<br>            sum1 += <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread_id = %d sum1 = %d\n&quot;</span>, omp_get_thread_num(),sum1);<br><br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp single</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The first sum is %d\n&quot;</span>, sum1);<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; f; i++)<br>        &#123;<br>            sum2 += <span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread_id = %d sum2 = %d\n&quot;</span>, omp_get_thread_num(),sum2);<br><br>        &#125;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp single</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The second sum is %d\n&quot;</span>, sum2);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br>output:<span class="hljs-comment">// sum2的最终值每次会发生变化，应该是都发生了并发问题</span><br>thread_id = <span class="hljs-number">0</span> sum1 = <span class="hljs-number">1</span><br>thread_id = <span class="hljs-number">0</span> sum1 = <span class="hljs-number">5</span><br>thread_id = <span class="hljs-number">0</span> sum1 = <span class="hljs-number">6</span><br>thread_id = <span class="hljs-number">1</span> sum1 = <span class="hljs-number">3</span><br>thread_id = <span class="hljs-number">1</span> sum1 = <span class="hljs-number">7</span><br>thread_id = <span class="hljs-number">1</span> sum1 = <span class="hljs-number">8</span><br>thread_id = <span class="hljs-number">2</span> sum1 = <span class="hljs-number">4</span><br>thread_id = <span class="hljs-number">2</span> sum1 = <span class="hljs-number">9</span><br>thread_id = <span class="hljs-number">3</span> sum1 = <span class="hljs-number">2</span><br>thread_id = <span class="hljs-number">3</span> sum1 = <span class="hljs-number">10</span><br>The first sum is <span class="hljs-number">10</span><br>thread_id = <span class="hljs-number">3</span> sum2 = <span class="hljs-number">2</span><br>thread_id = <span class="hljs-number">0</span> sum2 = <span class="hljs-number">4</span><br>thread_id = <span class="hljs-number">1</span> sum2 = <span class="hljs-number">2</span><br>thread_id = <span class="hljs-number">3</span> sum2 = <span class="hljs-number">6</span><br>thread_id = <span class="hljs-number">1</span> sum2 = <span class="hljs-number">8</span><br>thread_id = <span class="hljs-number">1</span> sum2 = <span class="hljs-number">10</span><br>thread_id = <span class="hljs-number">0</span> sum2 = <span class="hljs-number">12</span><br>thread_id = <span class="hljs-number">0</span> sum2 = <span class="hljs-number">14</span><br>thread_id = <span class="hljs-number">2</span> sum2 = <span class="hljs-number">2</span><br>thread_id = <span class="hljs-number">2</span> sum2 = <span class="hljs-number">16</span><br>The second sum is <span class="hljs-number">16</span><br>  <br><br></code></pre></td></tr></table></figure><h4 id="pragma-omp-task（todo"><a href="#pragma-omp-task（todo" class="headerlink" title="#pragma omp task（todo"></a>#pragma omp task（todo</h4><p>Task 用于指定某一段程序，并放置在任务池中，由进程池中的空闲的进程执行该任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file task.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">2</span>; <span class="hljs-comment">//number of threads</span><br>    omp_set_num_threads(n);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>    &#123;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp single</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A &quot;</span>);<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp task</span><br>            &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;race &quot;</span>);&#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp task</span><br>            &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;car &quot;</span>);&#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br>output：<br>A race car <br></code></pre></td></tr></table></figure><h2 id="第三节、Synchronization"><a href="#第三节、Synchronization" class="headerlink" title="第三节、Synchronization"></a>第三节、Synchronization</h2><p>在并行编程中，有时在处理并行运行的多个线程时，我们希望暂停线程的执行，而一次只运行一个线程。这是用所谓的障碍物实现的。同步可以通过两种方式实现，即通过隐式屏障或显式屏障。</p><h1 id="X、参考文献-x2F-课程"><a href="#X、参考文献-x2F-课程" class="headerlink" title="X、参考文献&#x2F;课程"></a>X、参考文献&#x2F;课程</h1><ul><li><a href="https://www.futurelearn.com/courses/interactive-hands-on-introduction-to-parallel-programming/1/todo/105942">Introduction to Parallel Programming</a></li><li><a href="https://zhuanlan.zhihu.com/p/488116143">NUMA 的平衡和调度</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MPI</category>
      
      <category>Introduction-to-Parallel-Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction to Parallel Programming课程笔记</title>
    <link href="/MPI/Introduction-to-Parallel-Programming/Introduction/"/>
    <url>/MPI/Introduction-to-Parallel-Programming/Introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="第一周、Introduction-to-Parallel-Programming"><a href="#第一周、Introduction-to-Parallel-Programming" class="headerlink" title="第一周、Introduction to Parallel Programming"></a>第一周、<a href="https://www.futurelearn.com/courses/interactive-hands-on-introduction-to-parallel-programming/1/todo/105942">Introduction to Parallel Programming</a></h1><h2 id="第一节、Intro-to-parallel-programming"><a href="#第一节、Intro-to-parallel-programming" class="headerlink" title="第一节、Intro to parallel programming"></a>第一节、Intro to parallel programming</h2><h3 id="一、Hello-World"><a href="#一、Hello-World" class="headerlink" title="一、Hello World!"></a>一、Hello World!</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!xx\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span>&#123;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(3)</span><br>    <span class="hljs-built_in">sayHello</span>();    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>output:<br>Hello World!<br>Hello World!xx<br>Hello World!xx<br>Hello World!xx<br></code></pre></td></tr></table></figure><h2 id="第二节、OpenMP-overview"><a href="#第二节、OpenMP-overview" class="headerlink" title="第二节、OpenMP overview"></a>第二节、OpenMP overview</h2><h3 id="一、Brief-intro-to-OpenMP"><a href="#一、Brief-intro-to-OpenMP" class="headerlink" title="一、Brief intro to OpenMP"></a>一、Brief intro to OpenMP</h3><p>OpenMP（Open specifications for Multi Processing）是一个用于共享内存并行计算的API。</p><p>OpenMP API由三个部分组成：</p><ul><li>Compiler Directives（编译器指令）</li><li>Runtime Library Routines（运行时库程序）</li><li>Environment Variables（环境变量）</li></ul><h4 id="编译器指令"><a href="#编译器指令" class="headerlink" title="编译器指令"></a>编译器指令</h4><p>编译器指令是以源代码中的注释形式出现的，只有在指定了适当的编译器标志时，才会在编译时被考虑进去。我们在以下方面使用OpenMP编译器：</p><ul><li>spawning a parallel region（催生一个并行区域）</li><li>dividing blocks of code among threads（在线程之间划分代码块）</li><li>distributing loop iterations between threads（在线程之间分配循环迭代）</li><li>serializing sections of code（串行化代码段）</li><li>synchronization of work among threads（线程之间的工作同步化）</li></ul><p>语法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sentinel</span> directive-name<span class="hljs-meta"> [clause, ...]</span><br></code></pre></td></tr></table></figure><h4 id="运行时库程序"><a href="#运行时库程序" class="headerlink" title="运行时库程序"></a>运行时库程序</h4><p>These routines can be used for:</p><ul><li>setting and querying:<ul><li>number of threads</li><li>dynamic threads feature</li><li>nested parallelism</li></ul></li><li>querying:<ul><li>thread ID</li><li>thread ancestor’s identifier</li><li>thread team size</li><li>wall clock time and resolution</li><li>a parallel region and its level</li></ul></li><li>setting, initializing and terminating:<ul><li>locks</li><li>nested locks</li></ul></li></ul><p>C&#x2F;C++中所有的运行库例程都是子程序，例如，C中查询线程数的运行库例程是一个子程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">omp_get_num_threads</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span><br></code></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>OpenMP环境变量可以通过以下方式在运行时控制并行代码的执行：</p><ul><li>setting:<ul><li>number of threads</li><li>thread stack size</li><li>thread wait policy</li><li>maximum levels of nested parallelism</li></ul></li><li>specifying how loop interations are divided</li><li>binding threads to processors</li><li>enabling&#x2F;disabling:<ul><li>nested parallelism</li><li>dynamic threads</li></ul></li></ul><p>OpenMP环境变量的设置与其他环境变量一样，取决于所使用的shell，例如，你可以在bash中设置OpenMP线程的数量。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">OMP_NUM_THREADS</span>=2<br></code></pre></td></tr></table></figure><p>在csh中则用：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setenv</span> OMP_NUM_THREADS <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="用OpenMP指令编译代码"><a href="#用OpenMP指令编译代码" class="headerlink" title="用OpenMP指令编译代码"></a>用OpenMP指令编译代码</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc hello_world.c -o hello_world -fopenmp<br></code></pre></td></tr></table></figure><p>编译器与对应的编译器标志</p><table><thead><tr><th align="left">Vendor&#x2F;Provider</th><th align="left">Compiler</th><th align="left">Flag</th></tr></thead><tbody><tr><td align="left">GNU</td><td align="left"><code>gcc</code></td><td align="left"><code>-fopenmp</code></td></tr><tr><td align="left"></td><td align="left"><code>g++</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>g77</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>gfortran</code></td><td align="left"></td></tr><tr><td align="left">Intel</td><td align="left"><code>icc</code></td><td align="left"><code>-openmp</code></td></tr><tr><td align="left"></td><td align="left"><code>icpc</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>ifort</code></td><td align="left"></td></tr><tr><td align="left">PGI</td><td align="left"><code>pgcc</code></td><td align="left"><code>-mp</code></td></tr><tr><td align="left"></td><td align="left"><code>pgCC</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>pgf77</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>pgf90</code></td><td align="left"></td></tr></tbody></table><h3 id="二、OpenMP-memory-programming-and-execution-model"><a href="#二、OpenMP-memory-programming-and-execution-model" class="headerlink" title="二、OpenMP memory, programming and execution model"></a>二、OpenMP memory, programming and execution model</h3><p>OpenMP是基于<strong>多处理器或多核机器的共享内存模型</strong>。共享内存类型可以是统一内存访问（UMA）或非统一内存访问（NUMA）。<strong>在OpenMP中，程序完全通过使用线程来完成并行化</strong>，即所谓的基于线程的并行化。</p><p>OpenMP是一种进行 “自动 “并行化的简单方法。实际上，OpenMP是一个显式编程模型，它为用户提供了对并行化的完全控制。尽管从严格意义上讲不是自动的，但并行化只是通过在一个串行程序中插入编译器指令来实现，从而 “自动 “将其转化为一个并行程序</p><p>OpenMP的执行模型的基础是并行执行的<strong>fork-join模型</strong>。</p><p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/hero_f5b1f9fd-0077-43e0-88b-aef0edbf468f.png" alt="OpenMP fork-join"></p><p>OpenMP 术语表:</p><table><thead><tr><th align="left">Term</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">OpenMP thread</td><td align="left">一个由OpenMP指定的运行中的进程</td></tr><tr><td align="left">thread team</td><td align="left">一组合作完成任务的线程</td></tr><tr><td align="left">master thread</td><td align="left">协调各线程的主线程</td></tr><tr><td align="left">thread safety</td><td align="left">指的是多线程的正确执行</td></tr><tr><td align="left">OpenMP directive</td><td align="left">OpenMP编译器的代码行，用于OpenMP的编译器</td></tr><tr><td align="left">construct</td><td align="left">一个OpenMP可执行指令</td></tr><tr><td align="left">clause</td><td align="left">控制执行过程中变量的范围</td></tr></tbody></table><h3 id="三、For-loop"><a href="#三、For-loop" class="headerlink" title="三、For loop"></a>三、For loop</h3><p>在这个例子中，你将学习如何在C语言中使用OpenMP construct（指令名）进行向量加法。</p><p>数组求和示例：&#x2F;&#x2F; 注：parallel和for取名随意，可删？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel shared(a,b,c,chunk) private(i)</span><br>  &#123;<br><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for schedule(dynamic,chunk) nowait</span><br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i &lt;= N; i++)<br>    c[i] = a[i] + b[i];<br><br>  &#125;  <span class="hljs-comment">/* end of parallel section */</span><br></code></pre></td></tr></table></figure><p>让我们详细解释一下这段代码。</p><ul><li>在parallel construct中<ul><li>shared(a,b,c,chunk)子句表示数组a、b、c和变量chunk将被所有线程共享。</li><li>private(i)子句表示变量i对每个线程都是私有的，每个线程都有自己的唯一副本。</li></ul></li><li>在for construct中<ul><li>子句schedule(dynamic,chunk)表示for循环的迭代将按chunk大小动态分布。</li><li>子句nowait表示线程在完成各自的工作后将不进行同步。</li></ul></li></ul><p>完整示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file vector_add.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE 202</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N     2021</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span>&#123;<br><br><span class="hljs-type">int</span> i, chunk;<br><span class="hljs-type">int</span> a[N], b[N], c[N];<br><br><span class="hljs-comment">/* Some initializations */</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i &lt;= N; i++)&#123;<br>  a[i] = i ;<br>  b[i] = <span class="hljs-number">2020</span> - a[i];<br>&#125;<br>chunk = CHUNKSIZE;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel shared(a,b,c,chunk) private(i)</span><br>  &#123;<br><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for schedule(dynamic,chunk) nowait</span><br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i &lt;= N; i++)<br>    c[i] = a[i] + b[i];<br><br>  &#125;  <span class="hljs-comment">/* end of parallel section */</span><br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= N; i++)&#123;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">101</span> == <span class="hljs-number">0</span>)<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d + %d = %d\n&quot;</span>, a[i], b[i], c[i]);<br>    &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>output:<br><span class="hljs-number">101</span> + <span class="hljs-number">1919</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">202</span> + <span class="hljs-number">1818</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">303</span> + <span class="hljs-number">1717</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">404</span> + <span class="hljs-number">1616</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">505</span> + <span class="hljs-number">1515</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">606</span> + <span class="hljs-number">1414</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">707</span> + <span class="hljs-number">1313</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">808</span> + <span class="hljs-number">1212</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">909</span> + <span class="hljs-number">1111</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1010</span> + <span class="hljs-number">1010</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1111</span> + <span class="hljs-number">909</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1212</span> + <span class="hljs-number">808</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1313</span> + <span class="hljs-number">707</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1414</span> + <span class="hljs-number">606</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1515</span> + <span class="hljs-number">505</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1616</span> + <span class="hljs-number">404</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1717</span> + <span class="hljs-number">303</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1818</span> + <span class="hljs-number">202</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1919</span> + <span class="hljs-number">101</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">2020</span> + <span class="hljs-number">0</span> = <span class="hljs-number">2020</span><br></code></pre></td></tr></table></figure><h3 id="四、Quiz-Intro-to-OpenMP"><a href="#四、Quiz-Intro-to-OpenMP" class="headerlink" title="四、Quiz: Intro to OpenMP"></a>四、Quiz: Intro to OpenMP</h3><p><strong>关于OpenMP执行模型的哪些说法是正确的？</strong><br>线程只能存在于单个进程的资源中。❌<br>线程可以存在于多个进程的资源中。✅<br>线程的最大数量等于处理器核的数量乘以每核可用的线程。✅<br>要使用的线程数不能由用户定义。❌<br>一个主线程是平行执行的，直到遇到第一个顺序区域构造。❌<br>一个主线程是按顺序执行的，直到遇到第一个并行区域结构。✅</p><p><strong>将OpenMP程序的可用线程数设置为4，哪个是正确的方法？</strong><br>在一个OpenMP程序中，使用库函数mp_get_num_threads(4)，在主函数的开始部分将线程数设置为4。❌<br>在一个OpenMP程序中，使用库函数num_threads(4)在主函数的开头将线程数设置为4。❌<br>在bash中，export OMP_NUM_THREADS&#x3D;4。✅<br>在一个OpenMP程序中，使用库函数omp_max_threads(4)在主函数的开始部分将线程数设置为4。❌</p><h2 id="第三节、MPI-overview"><a href="#第三节、MPI-overview" class="headerlink" title="第三节、MPI overview"></a>第三节、MPI overview</h2><h3 id="一、Brief-intro-to-MPI"><a href="#一、Brief-intro-to-MPI" class="headerlink" title="一、Brief intro to MPI"></a>一、Brief intro to MPI</h3><p>消息传递接口（MPI）是一个为开发者和用户提供的消息传递库的规范。<strong>MPI主要解决并行消息传递编程模型</strong>。存在许多开源的MPI实现，它们被用于开发可移植和可扩展的大规模并行应用。</p><p>两个最常用的MPI库实现以及Linux系统的相应编译器：</p><table><thead><tr><th align="left">MPI library</th><th align="left">Language</th><th align="left">Compiler</th></tr></thead><tbody><tr><td align="left">MVAPICH2</td><td align="left">C</td><td align="left"><code>mpicc</code></td></tr><tr><td align="left"></td><td align="left">C++</td><td align="left"><code>mpicxx</code></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>mpic++</code></td></tr><tr><td align="left"></td><td align="left">Fortran</td><td align="left"><code>mpif77</code></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>mpif90</code></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>mpifort</code></td></tr><tr><td align="left">Open MPI</td><td align="left">C</td><td align="left"><code>mpicc</code></td></tr><tr><td align="left"></td><td align="left">C++</td><td align="left"><code>mpiCC</code></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>mpic++</code></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>mpicxx</code></td></tr><tr><td align="left"></td><td align="left">Fortran</td><td align="left"><code>mpif77</code></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>mpif90</code></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>mpifort</code></td></tr></tbody></table><p>消息传递编程范式可以用以下几点来描述。</p><ul><li>数据分布在处理器（核）之间</li><li>每个处理器（核）同时对不同的数据进行操作</li><li>处理器（核）可能需要彼此互动</li></ul><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125161210210.png" alt="image-20221125161210210" style="zoom:50%;"><p>MPI程序中的每个处理器（核）都运行一个子程序，这个子程序在每个处理器（核）上通常是相同的。每个子程序的变量都有相同的名称，但位置和数据不同（分布式内存），即所有变量都是私有的。处理器（核）通过特殊的发送和接收程序（消息传递）进行通信。MPI提供点对点以及集体通信。</p><p><strong>在MPI中，点对点操作通常涉及在两个且仅有两个不同的MPI任务之间进行切换。</strong></p><p>一个任务执行发送操作，而另一个任务执行匹配的接收操作。<br>有不同的发送和接收功能，用于不同的目的，如：</p><ul><li>阻塞式发送&#x2F;阻塞式接收</li><li>非阻塞式发送&#x2F;非阻塞式接收</li><li>缓冲式发送</li><li>联合发送&#x2F;接收</li><li>准备发送</li></ul><h3 id="二、Messages-and-communication"><a href="#二、Messages-and-communication" class="headerlink" title="二、Messages and communication"></a>二、Messages and communication</h3><p>MPI中的通信类型一般与涉及的进程数量有关。最简单的消息传递形式是点对点通信，即一个进程向另一个进程发送消息。在集体通信中，一次有几个进程参与。这种通信有3类：<strong>同步、数据移动和集体计算</strong>。关于操作的完成，存在两种类型：<strong>阻塞和非阻塞操作</strong>。</p><p>信息是在子程序之间移动的数据包。<br><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125162120271.png" alt="image-20221125162120271" style="zoom:50%;"></p><p>一个消息传递系统的必要信息如下。</p><ul><li>数据大小和类型</li><li>发送或接收数据的指针</li><li>发送过程和接收过程，即等级</li><li>消息的标签</li><li>通信器，即MPI_COMM_WORLD</li></ul><h4 id="点对点通信"><a href="#点对点通信" class="headerlink" title="点对点通信"></a>点对点通信</h4><p>这种类型与两个进程之间的通信有关。源进程向目的进程发送一个消息。进程由它们在通信器中的等级来识别。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125162442247.png" alt="image-20221125162442247" style="zoom:50%;"><p><strong>发送和接收信息的阻塞例程（仅在操作完成后返回）。</strong><br>MPI_Send(…)<br>MPI_Recv(…)</p><p><strong>用于发送和接收消息的非阻塞例程（立即返回并允许子程序执行其他工作）。</strong><br>MPI_Isend(…)<br>MPI_Irecv(…)</p><h4 id="集体通信"><a href="#集体通信" class="headerlink" title="集体通信"></a>集体通信</h4><p>集体操作有以下类型：</p><p><strong>同步</strong>：进程等待，直到该组的所有成员都达到同步点<br><strong>数据移动</strong>：广播、分散&#x2F;收集、所有对所有<br><strong>集体计算（还原）</strong>：组中的一个成员从其他成员那里收集数据，并对这些数据进行操作（最小、最大、加、乘……）。</p><p>几个集体通信例子：</p><ol><li><em>Broadcast</em>（广播）<br>广播可以通过使用MPI_Bcast(…)来完成。一个进程向一个通信器中的所有进程发送相同的数据。它可以用来向所有进程发送用户输入或参数。广播的通信模式在下图中描述。</li></ol><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125162702891.png" alt="image-20221125162702891" style="zoom:50%;"><ol start="2"><li><em>Scatter</em>（散射）<br>散射可以通过使用MPI_Scatter(…)来完成。这个操作涉及到一个根进程向通信器中的所有进程发送数据。MPI_Bcast和MPI_Scatter的区别如下。<br>MPI_Bcast向所有进程发送同一条数据<br>MPI_Scatter向不同的进程发送大块的数据：在调用之后，发送方将不同部分发送给所有的进程。</li></ol><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125162753139.png" alt="image-20221125162753139" style="zoom:50%;"><ol start="3"><li><p><em>Gather</em>（聚集）<br>Gather可以通过使用MPI_Gather(…)来完成。这个操作是Scatter的逆向操作：它从许多进程中获取元素，并将它们聚集到一个单一的进程中。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125163927595.png" alt="image-20221125163927595" style="zoom:50%;"></li><li><p><em>Reduce</em><br>减少可以通过使用MPI_Reduce(…)来完成。这个操作在每个进程上接收一个输入元素的数组，并向根进程返回一个输出元素的数组。输出元素包含还原的结果。下面的图片描述了总和还原，即一个有四个整数类型元素的数组被还原成一个有一个元素的数组，包含源数组的元素之和。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125164418123.png" alt="image-20221125164418123" style="zoom:50%;"></li></ol><h3 id="三、Programming-point-of-view"><a href="#三、Programming-point-of-view" class="headerlink" title="三、Programming point of view"></a>三、Programming point of view</h3><p>在这一节，我们将介绍MPI程序的结构，如何编译它们，最后是如何运行它们。</p><h4 id="MPI程序结构"><a href="#MPI程序结构" class="headerlink" title="MPI程序结构"></a>MPI程序结构</h4><p>一个典型的C&#x2F;C++中的MPI程序有如下结构（见下图）：</p><ul><li>包含一个MPI头</li><li>变量和函数的声明，定义原型等。</li><li>带有的主程序。<ul><li>串行代码</li><li>并行代码：MPI环境的初始化，MPI代码（工作、调用等），MPI环境的终止</li></ul></li></ul><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125164615916.png" alt="image-20221125164615916" style="zoom:50%;"><p>An MPI program in C is something like:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>  MPI_Init(<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br><br>  MPI_Xxxxxx(parameter, ...);<br><br>  MPI_Finalize();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个通用的例子中，头文件&lt;mpi.h&gt;被包括在内。MPI是用MPI_Init()初始化的，这个例程必须在任何其他MPI例程之前调用。所有的MPI函数或例程的格式都是MPI_Xxxxxx(参数，…)。MPI是通过MPI_Finalize()来最终确定的。这个例程必须由所有进程最后调用。在它之后，不得再调用任何MPI调用。</p><h4 id="MPI程序的编译"><a href="#MPI程序的编译" class="headerlink" title="MPI程序的编译"></a>MPI程序的编译</h4><p>必须使用支持MPI的合适的编译器或特殊的MPI编译器进行编译，例如，可以使用：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>mpicc hello_world.c -o hello_world<br></code></pre></td></tr></table></figure><p>来编译mpi程序</p><h4 id="运行MPI程序"><a href="#运行MPI程序" class="headerlink" title="运行MPI程序"></a>运行MPI程序</h4><p>要在num个进程（处理器）中运行一个MPI程序prg，应该使用以下命令。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ mpirun -<span class="hljs-built_in">np</span> <span class="hljs-built_in">num</span> ./prg<br></code></pre></td></tr></table></figure><p>例如，如上节所示产生的可执行文件可以用4个进程（处理器）来运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mpirun -np 4 ./hello_world</span><br></code></pre></td></tr></table></figure><h3 id="四、MPI-Hello-World"><a href="#四、MPI-Hello-World" class="headerlink" title="四、MPI Hello World!"></a>四、MPI Hello World!</h3><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125171557174.png" alt="image-20221125171557174" style="zoom:50%;"><h3 id="五、Quiz-Intro-to-MPI"><a href="#五、Quiz-Intro-to-MPI" class="headerlink" title="五、Quiz: Intro to MPI"></a>五、Quiz: Intro to MPI</h3><p><strong>关于MPI中的点对点通信和集体通信，哪些说法是正确的？</strong><br>在点对点通信中，只有两个处理器参与。✅<br>在点对点通信中，许多处理器可以参与。❌<br>集体通信可以是一对一，一对多，多对一，或多对多的处理器。❌<br>集体通信可以从一个到多个，许多到一个，或许多到许多处理器。✅</p><h2 id="第四节、Accelerators-overview"><a href="#第四节、Accelerators-overview" class="headerlink" title="第四节、Accelerators overview"></a>第四节、Accelerators overview</h2><h3 id="一、Graphics-accelerators"><a href="#一、Graphics-accelerators" class="headerlink" title="一、Graphics accelerators"></a>一、Graphics accelerators</h3><p>图形加速器或图形处理单元（GPU）是具有许多高度并行处理单元（也称为流式多处理器）和非常高带宽内存的设备。有了这两个特点，它们与传统的处理器（CPU）不同。除了它们最初的用途，即用于密集型3D图形渲染（图形应用）外，另一个用途是用于GPGPU（通用图形处理器）计算（科学和工程应用）。</p><p>GPU在高性能计算（HPC）领域的应用越来越多，因为与传统的处理器相比，它们的功率效率要高得多（在超级计算机Top500名单中，Top10中有7个集群使用GPU）。例如，最快的最有效的集群是Perlmutter，它目前在世界超级计算机Top500名单上排名第5（基于Flops的性能指标，即每秒浮点运算），但也在Green500名单上排名第7（基于Flops&#x2F;watt的功率效率指标，即每瓦特每秒浮点运算）。</p><p>在通用计算方面，GPU被称为密集计算任务的加速器。与CPU相比，GPU的主要优势是更大的计算能力和高带宽内存，但另一方面，GPU也以延迟问题而闻名。因此，高效计算算法利用了 “两全其美 “的方法。GPU用于并行任务并实现吞吐性能，而CPU则用于串行任务和低延迟访问。因此，GPU可以被看作是CPU的协处理器，如下图所示。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221127193047421.png" alt="image-20221127193047421" style="zoom:50%;"><p>计算加速可以通过以下方式实现。</p><ul><li>现有的GPU应用程序</li><li>GPU库</li><li>基于指令的方法（如OpenMP和OpenACC）</li><li>特殊编程语言或扩展（如CUDA和OpenCL）。</li></ul><h3 id="二、GPU-Hello-World"><a href="#二、GPU-Hello-World" class="headerlink" title="二、GPU Hello World"></a>二、GPU Hello World</h3><p>被放到GPU上的并行代码是在所谓的内核中运行的。在CUDA C中，我们用__global__前缀来定义一个内核，例如，对于 “Hello World!”的例子，我们可以定义以下内核hello()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以从CPU端调用这个内核，作为一个普通的函数，使用三叉戟语法&lt;&lt;&lt;…&gt;&gt;，例如：。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hello</span>&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&gt;&gt;&gt;();<br></code></pre></td></tr></table></figure><p>在这个语法中，第一个数字表示块的数量，第二个数字表示块中线程的数量，也就是说，在上面的例子中，我们定义了1个有4个线程的块，在一个GPU上并行运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file hello_world.cu<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br>__global__ <span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-comment">// launch the kernel</span><br>    hello&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&gt;&gt;&gt;();<br> <br>    <span class="hljs-comment">// force the printf()s to flush</span><br>    cudaDeviceSynchronize();<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/cuda-10.1/</span>bin:<span class="hljs-variable">$&#123;PATH&#125;</span> nvcc -o hello_cuda_C hello_world.cu &amp;&amp; ./hello_cuda_C<br></code></pre></td></tr></table></figure><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">output:<br>Hello World!<br>Hello World!<br>Hello World!<br>Hello World!<br></code></pre></td></tr></table></figure><h1 id="第二周、OpenMP"><a href="#第二周、OpenMP" class="headerlink" title="第二周、OpenMP"></a>第二周、OpenMP</h1><h2 id="第一节、Getting-started-with-OpenMP"><a href="#第一节、Getting-started-with-OpenMP" class="headerlink" title="第一节、Getting started with OpenMP"></a>第一节、Getting started with OpenMP</h2><h3 id="一、Welcome-to-Week-2"><a href="#一、Welcome-to-Week-2" class="headerlink" title="一、Welcome to Week 2"></a>一、Welcome to Week 2</h3><p>OpenMP是一个共享内存的线程编程模型，可以用来逐步升级现有的代码以实现并行执行。升级后的代码仍然可以进行串行编译。这是OpenMP的一个很大的特点，它让你有机会检查并行执行是否提供了与串行版本相同的结果。为了更好地理解自动并行化，我们首先要看一下运行时函数。在简单的OpenMP程序中通常不需要这些函数。我们将介绍一些基本的编译器或pragma指令和变量的范围，以了解对内存的线程访问逻辑。</p><p>工作共享指令和线程的同步将在几个例子中讨论。如何从线程中收集结果，将用常见的减少条款来说明。在本周结束时，我们将介绍有趣的基于任务的并行化方法。不要忘了用练习来做实验，因为这些是你主要的学习机会。让我们开始吧。<br>本周的结构受到了HLRS OpenMP课程的启发（礼尚往来。Rolf Rabenseifner（HLRS））。</p><h3 id="二、Runtime-functions"><a href="#二、Runtime-functions" class="headerlink" title="二、Runtime functions"></a>二、Runtime functions</h3><p>运行时函数（Runtime functions）的目的是管理或修改我们想在代码中使用的并行进程。它们随OpenMP库而来。</p><p>对于C++和C，你可以添加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> &lt;omp.h</span><br></code></pre></td></tr></table></figure><p>头文件到你的代码的开头，然后这个库包括所有你需要的和你想使用的标准运行时函数。我们今天将在教程中使用的函数可以从成绩单中的链接或资源中获取。</p><ul><li>要设置所需的线程数，使用</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_set_num_threads</span><span class="hljs-params">(n)</span></span><br></code></pre></td></tr></table></figure><p>例如，如果你想用12个线程来并行化你的程序，你可以用函数指定程序中的线程数，比如说</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_set_num_threads</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span><br></code></pre></td></tr></table></figure><ul><li>要返回当前的线程数，请使用</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_get_num_threads</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><ul><li>要返回这个线程的ID，使用</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_get_thread_num</span><span class="hljs-params">()</span></span> <br></code></pre></td></tr></table></figure><ul><li>To return <code>true</code> if inside parallel region, use</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_in_parallel</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>如果它被指定在一个平行区域内，该函数返回true。如果不是，也就是说，如果它被指定在串行区域内，它将返回false。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>Let’s observe the following example.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>    omp_set_num_threads(num_threads);<br>    <span class="hljs-type">int</span> rank;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>    &#123;<br>        rank = omp_get_thread_num();<br>        <span class="hljs-type">int</span> nr_threads = omp_get_num_threads();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am thread %i of %i threads\n&quot;</span>,<br>        rank,<br>        nr_threads);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>花点时间，试着理解上面的代码中发生了什么。</p><ul><li><p>预期的输出是什么？rank和nr_threads的值是多少？</p><p>I am thread 0 of 4 threads</p><p>I am thread 1 of 4 threads</p><p>I am thread 2 of 4 threads</p><p>I am thread 3 of 4 threads</p></li><li><p>输出总是一样的吗？线程的打印顺序是什么？</p><p>不一样，打印顺序应该随机</p></li><li><p>如果我们把线程的数量改为12，会发生什么？</p><p>会打印十二次</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221127203248794.png" alt="image-20221127203248794" style="zoom:50%;"></li></ul><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>使用私有变量设置线程数</p><h3 id="三、Variables-and-constructs"><a href="#三、Variables-and-constructs" class="headerlink" title="三、Variables and constructs"></a>三、Variables and constructs</h3><h4 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h4><p>接下来我们要看的是环境变量。与运行时函数相反，环境变量不是在代码中使用的，而是在环境中指定的，在那里你正在编译和运行你的代码。环境变量的目的是为了在运行时控制并行程序的执行。由于这些变量不是在代码中指定的，你可以在编译和运行你的程序之前，例如在Linux终端指定它们。让我们来看看三个最常见的环境变量：</p><ul><li><strong>指定要使用的线程数</strong></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">OMP_NUM_THREADS</span>=4<br></code></pre></td></tr></table></figure><ul><li><strong>指定线程应该放在哪个CPU上，可以使用</strong></li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">OMP_PLACES</span> <br></code></pre></td></tr></table></figure><ul><li><strong>要显示OpenMP的版本和环境，使用</strong></li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">OMP_DISPLAY_ENV</span>  <br></code></pre></td></tr></table></figure><h4 id="Parallel-constructs"><a href="#Parallel-constructs" class="headerlink" title="Parallel constructs"></a>Parallel constructs</h4><p>并行结构是使用OpenMP时的基本结构。所以，每个线程基本上都同时执行平行区域内的相同语句，正如你在这张图片上看到的。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221128153335944.png" alt="image-20221128153335944" style="zoom:50%;"><p>所以，首先我们有一个主线程，执行代码的串行部分。然后我们来到了一个pragma omp语句。我们在这里可以看到，主线程首先遇到了这个omp结构，并创建了多个线程，也就是我们所说的并行运行的从线程。随后，主线程和从线程在彼此之间划分了任务。最后，我们指定了一个隐含的障碍，所以当达到这个障碍时，线程结束，我们等待所有线程完成执行。在这之后，当所有的线程都完成了执行，我们回到主线程，最终恢复代码的执行。当然，在这一步骤中，从属线程已经消失了，因为它们已经完成了自己的任务。</p><p>在C语言中，这个隐含的屏障被指定为</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>&#123;<br>...<br> &#125;<br></code></pre></td></tr></table></figure><p>Let’s observe the following code.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span> <br>&#123;<br>  <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>  omp_set_num_threads(num_threads);<br>  <span class="hljs-type">int</span> rank;<br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>  &#123;<br>  rank = omp_get_thread_num();<br>  <span class="hljs-type">int</span> nr_threads = omp_get_num_threads();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am thread %i of %i threads\n&quot;</span>,<br> rank,<br> nr_threads);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、Clauses-and-directive-format"><a href="#四、Clauses-and-directive-format" class="headerlink" title="四、Clauses and directive format"></a>四、Clauses and directive format</h3><h4 id="Directive-format（指令格式）"><a href="#Directive-format（指令格式）" class="headerlink" title="Directive format（指令格式）"></a>Directive format（指令格式）</h4><p>到目前为止，我们只是指定了一个并行区域，并且代码是以串行方式执行的。现在我们将继续前进，看看OpenMP的指令。使用指令的格式如下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp directive_name [clause[clause]...]</span><br></code></pre></td></tr></table></figure><p>我们已经看到并使用了pragma omp parallel，它是一个并行执行区域的指令。在这种格式中，我们也有一些子句，以指定不同的参数。例如，私有变量是指对每个线程都是私有的变量，而共享变量是指对所有线程共享的变量，任何线程都可以访问和修改它。</p><p>我们将在下面的小节中更多地探讨这些条款。现在，我们将学习一下条件语句。与任何编程语言类似，OpenMP也有条件语句。因此，举例来说，我们也可以在OpenMP中以如下方式指定一个if语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _OPENMP</span><br><span class="hljs-comment">//block of code to be executed if code was compiled with OpenMP, for example</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Number of threads: %d&quot;</span>, omp_get_num_threads);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">//block of code to be executed if code was compiled without OpenMP</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>下面的例子说明了条件编译的使用。通过OpenMP编译，_OPENMP被定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span> <br>&#123;<br>  <span class="hljs-type">int</span> rank;<br>  <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _OPENMP</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(4) private(rank)</span><br>  &#123;<br>    rank = omp_get_thread_num();<br>    <span class="hljs-type">int</span> nr_threads = omp_get_num_threads();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am thread %i of %i threads\n&quot;</span>,<br>   rank,<br>   nr_threads);<br>  &#125;<br>  <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This program is not compiled with OpenMP\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><blockquote><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ gcc example.c<br>This program is not compiled with OpenMP<br><br>$ gcc -fopenmp example.c<br>I am thread<span class="hljs-number"> 3 </span>of<span class="hljs-number"> 4 </span>threads<br>I am thread<span class="hljs-number"> 2 </span>of<span class="hljs-number"> 4 </span>threads<br>I am thread<span class="hljs-number"> 1 </span>of<span class="hljs-number"> 4 </span>threads<br>I am thread<span class="hljs-number"> 0 </span>of<span class="hljs-number"> 4 </span>threads<br></code></pre></td></tr></table></figure></blockquote></blockquote><h4 id="Clauses（条款）"><a href="#Clauses（条款）" class="headerlink" title="Clauses（条款）"></a>Clauses（条款）</h4><p>我们刚刚学习的指令格式</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp directive_name [clause[clause]...]</span><br></code></pre></td></tr></table></figure><p>是OpenMP的一个重要的关键字，我们把它放在代码的开头，放在我们想让并行区域开始的那一行，然后我们提到指令名称和子句。在本小节中，我们将学习条款。</p><p>基本上有两种条款，即：私有或共享。一个私有变量将是一个对每个线程都是私有的变量。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221128155745412.png" alt="image-20221128155745412" style="zoom:50%;"><p>So, we execute, e.g.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> A;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(A)</span><br>&#123;<br>    A=<span class="hljs-built_in">omp_get_thread_num</span>();<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们在C代码中定义了一个整数A。然后我们定义了OpenMP指令，omp parallel和private A。因此，这里发生的情况是，任何时候我们都会得到一个新的线程，这个变量A将被单独分配给每个线程。这意味着，A的值将与线程的数量有关。因此，在第一个线程中，它将是0，在第二个线程中，这个变量的值将是1，因为这将是线程的ID，在第三个线程中的值将是2，以此类推。我们可以清楚地看到，这些变量基本上是私有的，这意味着它们存在于每个线程中。这意味着，第一个线程中的变量A（0）不能被第二个线程中的变量A（1）访问。所以，这就推断出这个变量对我们程序中的每个单独的线程来说基本上是私有的。当然，与此相反的是共享变量。如果我们指定一个变量是共享变量，这将标志着该变量将在线程之间共享。如果我们在并行区域之外指定该变量，那么就在</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br></code></pre></td></tr></table></figure><p>这个变量将被每个线程访问。举例来说，如果我们有一个for循环，并且我们在每次迭代中都向它添加一个数字，我们可以直接指定它为一个共享变量。在这种情况下，每当任何线程更新共享变量时，它都会向其中添加数字。这是一种使用for循环的适当方式，我们将在下面的小节中看到。<br>因此，总结一下，私有和共享的区别：私有变量只对一个线程可用，不能被其他任何线程访问，而共享变量不仅可以被程序中的每个线程访问，而且还可以被每个线程同时更新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span> <br>&#123;<br>  <span class="hljs-type">int</span> num_threads = <span class="hljs-number">10</span>;<br>  omp_set_num_threads(num_threads);<br><br>  <span class="hljs-type">int</span> private_var = <span class="hljs-number">1000</span>;<br>  <span class="hljs-type">int</span> shared_var = <span class="hljs-number">5000</span>;<br>  <span class="hljs-type">int</span> rank;<br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(private_var, rank) shared(shared_var)</span><br>  &#123;<br>    rank = omp_get_thread_num();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread ID is: %d\n&quot;</span>, rank);  <br>    private_var = private_var + num_threads;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of private_var is: %d\n&quot;</span>, private_var);<br>    shared_var = shared_var + num_threads;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of shared_var is: %d\n&quot;</span>, shared_var);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的代码并观察输出。当被不同的线程访问时，私有和共享变量的值如何变化？当被多个线程修改时，共享变量的值是否增加？为什么？</p><p>被不同线程访问时私有变量private_var初始值不变，共享变量初始值shared_var会改变。</p><p><strong>多个线程修改时，共享变量的值不一定增加，可能发生并发修改and修改丢失。</strong>❌</p><p>这里可能还存在一个竞赛条件。并行区域内的变量的写入和立即读取是一个写-读竞赛条件。两个或多个线程访问同一个共享变量并对其进行修改，这些访问是不同步的。我们将在并行区域练习中看到一个更清晰的竞赛条件的例子。</p><p>！！结果显示，并没有发生并发问题</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">5</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5010</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">8</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5020</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5030</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5040</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">9</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5050</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">2</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5060</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">6</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5070</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">4</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5080</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">3</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5090</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">7</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5100</span><br></code></pre></td></tr></table></figure><h3 id="五、Clauses"><a href="#五、Clauses" class="headerlink" title="五、Clauses"></a>五、Clauses</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>    omp_set_num_threads(num_threads);<br><br>    <span class="hljs-type">int</span> private_var = <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">int</span> shared_var = <span class="hljs-number">5000</span>;<br>    <span class="hljs-type">int</span> rank;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(private_var) shared(shared_var)</span><br>    &#123;<br>        rank = omp_get_thread_num();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread ID is: %d\n&quot;</span>, rank);  <br>        private_var = private_var + num_threads;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of private_var is: %d\n&quot;</span>, private_var);<br>        shared_var = shared_var + num_threads;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of shared_var is: %d\n&quot;</span>, shared_var);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>花点时间，试着理解上面的代码中发生了什么。</p><ul><li><p>当被不同的线程访问时，私有和共享变量的值如何变化？</p><p>被不同线程访问时私有变量private_var初始值不变（<strong>为0！</strong>），共享变量初始值shared_var会改变。</p></li><li><p>当被多个线程修改时，共享变量的值是否增加？为什么？</p><p><strong>多个线程修改时，共享变量的值不一定增加，可能发生并发修改and修改丢失？</strong></p><p><strong>运行没有出现这个现象，但是助教在评论中提到了会出现race condition</strong> </p></li><li><p>当被多个线程修改时，私有变量的值是否会增加？</p></li></ul><p>现在去做练习，试一试，检查你的答案是否正确。</p><h3 id="六、Parallel-region"><a href="#六、Parallel-region" class="headerlink" title="六、Parallel region"></a>六、Parallel region</h3><p>在这个练习中，你将得到练习使用基本的运行时函数、指令格式、并行结构和条款，这些都是我们到目前为止学到的。</p><p>这个练习的代码在Jupyter笔记本的以下说明中。你将从这个提供的Hello world模板开始。预期的输出是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    i = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world %d\n&quot;</span>, i );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><ol><li>进入练习，使用其中一个运行时函数将所需的线程数设置为4。✅</li><li>使用其中一个运行时函数将变量i设置为该线程的ID。✅</li><li>添加一个并行区域，使代码并行运行。✅</li><li>在包含OpenMP头文件和使用运行时函数时，添加OpenMP条件条款。✅</li></ol><p>在你运行这个程序之前，你认为会发生什么？<br>现在，运行该程序并观察输出。你可以将线程数改为12个或其他，观察输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file exercise.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br><br>    i = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">12</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _OPENMP</span><br>    omp_set_num_threads(num_threads);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel </span><br>    &#123;<br>        i = omp_get_thread_num();<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world openmp %d\n&quot;</span>, i );<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world gcc %d\n&quot;</span>, i );<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221128210815541.png" alt="image-20221128210815541" style="zoom:50%;"><ol><li>为变量i的并行区域添加一个私有子句。</li></ol><p>会发生什么？观察输出的差异。为什么输出会不同？检查你是否得到一个竞赛条件。</p><p>竞赛条件(Race condition):</p><ul><li>两个线程访问同一个共享变量，并且至少有一个线程修改了该变量，并且访问没有同步化。</li><li>程序的结果取决于团队中各线程的时间。</li><li>这是由非故意的数据共享造成的。</li></ul><p><strong>不要担心你是否总是得到正确的输出，因为编译器可能在每个线程上使用一个私有寄存器，而不是直接写入内存中</strong></p><ul><li>If compiled with OpenMP, the program should output »hello world« and the ID of each thread.</li></ul><h2 id="第二节、Worksharing-directives（工作共享指令）"><a href="#第二节、Worksharing-directives（工作共享指令）" class="headerlink" title="第二节、Worksharing directives（工作共享指令）"></a>第二节、Worksharing directives（工作共享指令）</h2><h3 id="一、Which-thread-executes-which-statement-or-operation"><a href="#一、Which-thread-executes-which-statement-or-operation" class="headerlink" title="一、Which thread executes which statement or operation?"></a>一、Which thread executes which statement or operation?</h3><p>在下面的步骤中，我们要学习如何真正地平行组织我们的工作。请分享你对我们如何实现这一目标的想法。</p><p>你知道有哪些可能的并行组织工作的方法吗？如何在线程之间分配操作？有什么方法可以控制线程的顺序吗？</p><h3 id="二、OpenMP-constructs"><a href="#二、OpenMP-constructs" class="headerlink" title="二、OpenMP constructs"></a>二、OpenMP constructs</h3><h4 id="Worksharing-constructs（工作共享结构）"><a href="#Worksharing-constructs（工作共享结构）" class="headerlink" title="Worksharing constructs（工作共享结构）"></a>Worksharing constructs（工作共享结构）</h4><p>工作共享结构将代码区域的执行在团队线程的不同成员之间进行划分。这些结构不启动新的线程，它们被动态地包围在并行区域内。工作共享结构体的一些例子是。</p><ul><li>sections</li><li>for</li><li>task</li><li>single</li></ul><h4 id="Section-construct"><a href="#Section-construct" class="headerlink" title="Section construct"></a>Section construct</h4><p>我们首先将看到一个使用section结构的代码例子，我们可以通过指令性的section来指定它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp sections</span><br>    &#123;<br>      <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>      &#123;<br>        function_1();<span class="hljs-comment">// a=... b=...</span><br>      &#125;<br>      <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>      &#123; <br>        function_2();<span class="hljs-comment">// c=... d=...</span><br>      &#125;<br>    &#125;<br>&#125;<span class="hljs-comment">// end of parallel</span><br></code></pre></td></tr></table></figure><p>当我们使用section结构时，多个代码块被并行执行。当我们指定章节并将一个任务放入其中时，这个特定的任务将在一个线程中执行。然后，当我们进入另一个部分时，它将在不同的线程中执行其任务。这样，我们就可以在pragma omp并行代码中添加这些部分，为每个线程指定一个部分，这些部分将在每个单独的线程中执行。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221128212103284.png" alt="image-20221128212103284" style="zoom:50%;"><p>在上面的示例代码中，我们可以看到，在这一节中，我们指定了变量a和b。当这段代码被执行时，一个新的线程会带着这些变量产生，同样的，变量c和d也被指定在不同的一节中，因此也在不同的线程中。</p><p>Eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file sections.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">function_1</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Function 1 done by thread %d \n&quot;</span> , omp_get_thread_num());<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">function_2</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j != <span class="hljs-number">2</span>; j++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Function 2 done by thread %d \n&quot;</span> , omp_get_thread_num());<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>; <span class="hljs-comment">//number of threads</span><br>    omp_set_num_threads(n);<br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp sections</span><br>        &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>            &#123;<br>                function_1();<br>            &#125;<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>            &#123; <br>                function_2();<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br>output:<br>Function <span class="hljs-number">2</span> done by thread <span class="hljs-number">0</span> <br>Function <span class="hljs-number">2</span> done by thread <span class="hljs-number">0</span> <br>Function <span class="hljs-number">1</span> done by thread <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="For-construct"><a href="#For-construct" class="headerlink" title="For construct"></a>For construct</h4><p>在计算机科学中，for-loop是一个指定迭代的控制流语句。这使得代码可以被反复执行。这样的任务，动作相似，多次执行，也可以被并行化。在OpenMP中，我们可以使用#pragma omp中的for结构。简单地说，for结构可以被看作是一个并行化的for循环。我们可以将for结构指定为</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#pragma omp for <span class="hljs-comment">[clause<span class="hljs-comment">[<span class="hljs-comment">[,]</span>clause]</span>...]</span><br></code></pre></td></tr></table></figure><p>这里我们也是以pragma omp开始，后面是for关键字，我们可以再次使用不同的子句，即私有的、共享的等等。相应的for-loop必须有一个规范的形状。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (int i<span class="hljs-operator">=</span>it<span class="hljs-comment">; i&lt;M; i++)</span><br></code></pre></td></tr></table></figure><p>由于每个迭代器默认是一个私有变量，并且只由一个线程共享，所以迭代器在循环体中不会被修改。如果它被每个线程访问，我们的for-loop就会被破坏。</p><p>除了private，我们还有一些其他的子句。比如说。</p><ul><li>schedule。它对循环的迭代如何在线程之间分配进行分类。</li><li>collapse(n)。n个循环的迭代被折叠成一个更大的迭代空间。</li></ul><p>我们可以看到代码中使用for结构的一个例子。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(f)</span><br>&#123;<br>    f=<span class="hljs-number">10</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>        a[i] = b[i]*f;<br>    &#125; <span class="hljs-comment">// end of for</span><br>&#125; <span class="hljs-comment">// end of parallel</span><br></code></pre></td></tr></table></figure><p>我们用pragma omp parallel开始，然后是名为f的私有变量。然后我们用pragma omp for构造，接着是一个从0到10的for循环（10次不同的迭代）。然后，私有变量f在每个线程中都是固定的，列表a被并行更新。这是因为每个数组需要的索引都是不同的。所以，每个线程只能访问数组的一个地方，允许我们并行更新这个列表。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221128212831945.png" alt="image-20221128212831945" style="zoom:50%;"><p>在这里我们可以看到，如果我们在两个线程上工作，有10个迭代，那么这些迭代将被分成两个线程，分别从0到4和5到9。列表a上的每个地方都将被自己更新，由于迭代器是相互独立的，它们只修改一个地方，所以我们可以很容易地更新列表a的每个地方。</p><p>Eg:</p><pre><code class="hljs">%%file forloop.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;omp.h&gt;int main()&#123;    int n = 4; //number of threads    omp_set_num_threads(n);int* iterations; //count iterations for each threaditerations = (int *) malloc (n*sizeof(int));int f = 100;//set array values to 0for(int loop = 0; loop &lt; n; loop++)&#123;    iterations[loop] = 0;&#125;#pragma omp parallel shared(iterations, f)&#123;        #pragma omp for     for (int i = 0; i &lt; f; i++)    &#123;        iterations[omp_get_thread_num()]++;    &#125;&#125;for(int loop = 0; loop &lt; n; loop++)&#123;    printf(&quot;%d &quot;, iterations[loop]);&#125;free(iterations);&#125;</code></pre><h1 id="X、参考文献-x2F-课程"><a href="#X、参考文献-x2F-课程" class="headerlink" title="X、参考文献&#x2F;课程"></a>X、参考文献&#x2F;课程</h1><ul><li><a href="https://www.futurelearn.com/courses/interactive-hands-on-introduction-to-parallel-programming/1/todo/105942">Introduction to Parallel Programming</a></li><li>[NUMA 的平衡和调度](</li></ul>]]></content>
    
    
    <categories>
      
      <category>MPI</category>
      
      <category>Introduction-to-Parallel-Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并行编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI和Cuda学习</title>
    <link href="/MPI/MPI%20and%20Cuda/"/>
    <url>/MPI/MPI%20and%20Cuda/</url>
    
    <content type="html"><![CDATA[<p>一、基本介绍</p><p>X、参考文献</p><ul><li><a href="https://www.bilibili.com/video/BV16b4y1E74f/?spm_id_from=333.337.search-card.all.click&vd_source=fb926f3550cd847435afc066c3343d2e">（b站）CUDA在现代C++中如何运用？看这一个就够了！</a></li><li><a href="https://blog.csdn.net/Rong_Toa/article/details/77871833">Mpi与Cuda混合编程（Makefile）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MPI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
      <tag>CUDA</tag>
      
      <tag>并行编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka</title>
    <link href="/Architecture/kafka/"/>
    <url>/Architecture/kafka/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>消息驱动</title>
    <link href="/Architecture/event-streaming/"/>
    <url>/Architecture/event-streaming/</url>
    
    <content type="html"><![CDATA[<p><img src="/Architecture/event-streaming/385fb2888d6446749de2016e0cdaf521.png" alt="Kafka的通信流程梳理"></p><ol><li>怎么记录数据的类型</li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/506577165">“消息驱动、事件驱动、流 ”基础概念解析</a></li><li><a href="https://blog.csdn.net/LemonSnm/article/details/125325163">分布式消息中间件设计</a></li><li><a href="https://www.jianshu.com/p/f13844f815f0">深入理解Kafka事件流（Event Streaming）平台（一）</a></li><li><a href="https://blog.csdn.net/m0_65931372/article/details/125971395">kafka简介</a></li><li><a href="https://blog.csdn.net/pass_JMC/article/details/126716003">Kafka全面学习</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试问题</title>
    <link href="/others/problems/"/>
    <url>/others/problems/</url>
    
    <content type="html"><![CDATA[<p><strong>每个问题请展开五到十分钟的回答</strong></p><h2 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h2><h3 id="RPC项目"><a href="#RPC项目" class="headerlink" title="RPC项目"></a>RPC项目</h3><ol><li><p>简单介绍一下这个项目***</p></li><li><p>服务的发布与获取流程***</p></li><li><p>为什么要做这个项目***</p></li><li><p>什么是RPC</p></li><li><p>一个RPC框架需要一些什么内容</p></li><li><p>这个框架和其他的RPC框架有什么区别</p></li><li><p>是否进行过性能测试</p></li><li><p>在做项目的过程中遇到过什么问题***</p></li><li><p>项目中难点哪里</p></li><li><p>项目中同步与并发是如何实现的</p></li><li><p>RPC项目是怎么设计编码的</p></li><li><p>用的什么序列化框架</p></li><li><p>简单介绍一下netty</p></li><li><p>NIO和BIO有什么区别***</p></li><li><p>什么是IO多路复用*******</p></li><li><p>select、poll、epoll有什么区别****</p></li><li><p>NIO是水平触发还是边缘触发</p></li><li><p>注册中心是用的什么做的</p></li><li><p>如何用zookeeper实现注册中心***</p></li><li><p>如何保持客户端与服务端通信***</p></li><li><p>服务变更（上下线）如何通知客户端</p></li><li><p>负载均衡如何做的</p></li><li><p>你知道一些什么负载均衡算法</p></li><li><p>CAP理论知道吗</p></li><li><p>zookeeper是AP系统还是CP系统</p></li><li><p>这个框架是AP系统还是CP系统，为什么</p></li><li><p>如何保持通信</p></li><li><p>介绍一下Reactor模型</p></li><li><p>rpc与http的区别***</p></li><li><p>zookeeper的主从状态怎么传播</p></li><li><p>zookeeper主节点宕机如何处理</p></li><li><p>服务调用是同步还是异步的</p></li><li><p>项目中用到了线程池吗，怎么用的</p></li><li><p>有服务的自动化编码过程吗？（如thrift通过idl生成api）</p></li><li><p>如何发现服务宕机</p></li></ol><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol><li><p>进程和线程区别</p></li><li><p>什么是协程，与进程和线程有什么区别</p></li><li><p>操作系统层面怎么判断是否发生了死锁</p><p>资源分配图and gdb</p></li><li><p>进程调度策略</p></li><li><p>死锁概念：什么是死锁，产生原因，必要条件，死锁检测等</p></li><li><p>操作系统5种IO模型 and java3种IO模型</p></li><li><p>操作系统的虚拟内存机制（从虚拟地址空间到物理地址空间怎么做到的？底层？地址翻译？）</p></li><li><p>引用空指针会导致segment fault，此时操作系统背后做了什么？</p></li><li><p>知道mmap嘛？</p><p>1）调用mmap是将文件的内容拷贝到进程的地址空间去了嘛？</p><p>2）mmap涉及磁盘的IO么？</p><p>3）mmap映射动作，会去读映射的文件嘛？</p><p>4）mmap操作会返回一个指针，访问指针会发生什么？</p></li><li><p>什么是缺页异常</p></li><li><p>遍历数组和链表性能为什么差那么多（缓存行相关概念）</p></li><li><p>使用fprintf时操作系统做了什么？（c++）</p></li><li><p>什么是线程安全？</p></li><li><p>什么情况会导致线程不安全</p></li><li><p>可执行文件加载到内存中，描述地址分配情况（可执行程序的空间分布）</p></li><li><p>动态库和静态库的区别（动态库优点）（c++）</p></li><li><p>进程间通信方式</p></li><li><p>缓存溢出概念</p></li><li><p>linux命令，网络端口占用</p></li><li><p>进程的组成</p></li><li><p>进程切换哪些资源需要保存</p></li><li><p>线程和协程的切换需要内核态的参与吗？具体描述</p></li><li><p>什么是叶表？为什么要有页表？</p></li><li><p>虚拟内存</p></li><li><p>进程间通信、线程间通信的方式</p></li><li><p>cache line大小</p></li><li><p>进程&#x2F;线程&#x2F;协程上下文切换，数据有哪些，是一样的嘛？</p></li><li><p>如何malloc申请1G，那这1G是立即可以使用的嘛？（c++）</p></li><li><p>哪些情况下，会从用户态切换到内核态</p></li><li><p>如果在协程上做了阻塞IO，会有什么问题？</p></li><li><p>计算机怎么存储浮点数</p></li><li><p>计算机怎么存储负数</p></li><li><p>原码、反码、补码</p></li><li><p>a &#x3D; b + c</p><p>1）变量怎么获取数据，操作系统寻址过程</p><p>2）怎么由操作系统提交到CPU执行</p></li><li><p>虚拟地址</p><p>1）概念</p><p>2）如何转换</p></li><li><p>段式管理和页式管理</p></li><li><p>MMU如何进行翻译-&gt;页表结构&#x2F;多级页表</p></li><li><p>源代码到可执行文件的过程</p></li><li><p>进程间同步手段（提到了互斥锁，问不同进程怎么访问同一个互斥锁）</p></li><li><p>静态库与动态库优缺点</p></li><li><p>堆栈写爆了</p></li><li><p>socket和管道区别</p></li><li><p>局部性原理会在计算机的哪些机制下生效</p></li><li><p>Linux文件系统的权限模型设计</p></li><li><p>对于目录来说，执行权限有哪些</p></li><li><p>多线程开发注意点</p></li><li><p>epoll使用限制&#x2F;缺点</p></li><li><p>Linux下有epoll，Windows下有么？</p></li><li><p>协程最终是附着在进程还是线程？</p></li><li><p>协程为什么比线程快？为什么支持高并发</p></li><li><p>线程上下文切换的开销体现在哪？</p></li><li><p>进程&#x2F;线程上下文切换，哪些数据需要切换？切换之后数据保存在哪里？</p></li><li><p>两个线程交替打印1至100</p></li><li><p>线程有几种状态</p></li><li><p>怎么让一个线程销毁？</p></li><li><p>如何主动关闭一个线程？</p></li><li><p>什么是零拷贝？</p></li><li><p>mmap和sendfile有什么区别？</p></li><li><p>变量分配在堆和栈有什么区别么？</p></li><li><p>分页的页面大小，可以改么？怎么改？</p></li><li><p>页面置换算法</p></li><li><p>CPU密集和IO密集</p></li><li><p>提高服务器并发能力的方法论</p></li><li><p>Linux使用哪种方法进行进程调度</p></li><li><p>阻塞IO和非阻塞IO</p></li><li><p>同步和异步</p></li><li><p>中断、陷阱</p></li></ol><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol><li><p>TCP三次握手过程</p></li><li><p>HTTP中GET和POST区别</p></li><li><p>TCP与UDP区别</p></li><li><p>IO多路复用</p></li><li><p>介绍一下select，优缺点</p></li><li><p>epoll种LT与ET区别</p></li><li><p>epoll基本原理</p></li><li><p>epoll中红黑树和链表怎么协作？</p><p>1）如何从红黑树到双向链表？</p><p>2）节点会同时存在红黑树和链表里面嘛？</p></li><li><p>浏览器输入baidu.com发生了什么</p><p>1）IP头部中，源IP和目的IP怎么填？（内容）</p><p>2）MAC头部中，源MAC地址和目的MAC怎么填？（主机怎么判断，同局域网和不同局域网）</p><p>3）路由器如何转发，会对包进行何种改变？</p><p>4）交换机会做什么改动？</p></li><li><p>http和https区别</p></li><li><p>http https双重加密</p></li><li><p>TCP四次挥手</p></li><li><p>TCP协议如何保证可靠传输</p></li><li><p>TCP网络拥塞算法</p></li><li><p>Linux有多少个端口可用？是否可能被占满？</p></li><li><p>cookie和session区别，使用场景</p><p>（17～29阿里云二面）</p></li><li><p>HTTP协议里面内容（比如什么字段决定传输的内容，文本&#x2F;图片？）</p></li><li><p>OSI的七层和五层协议的区别，为什么实际用的是五层协议</p></li><li><p>wireshark和tcpdump抓包</p></li><li><p>如何判断包是否是乱序的？</p></li><li><p>随机序列号对应于头部哪个字段</p></li><li><p>如何传输大报文？（5000数据，但MTU只有1500）</p></li><li><p>第一个报文和第二个报文头的字段说一下</p></li><li><p>会有IP分片嘛？IP头部</p></li><li><p>应用层传输UDP报文，过程说一下，和TCP有什么区别嘛？怎么进行分割的？</p></li><li><p>IP哪个字段确定是否分片？</p></li><li><p>多个报文如何进行合并（组成发送的数据）</p></li><li><p>IP层路由默认路由没有了，会影响上网或访问同一局域网的机器嘛？</p></li><li><p>同一个子网下，但是没有MAC地址，会出现什么情况</p></li><li><p>http状态码</p></li><li><p>cookie不同网站是否可以共享，为什么</p></li><li><p>广播地址是什么意思</p></li><li><p>子网掩码</p></li><li><p>mac地址特点</p></li><li><p>socket情况下，tcp三次握手如何连接</p></li><li><p>tcp报文格式</p></li><li><p>socket函数bind，listen，connect</p></li><li><p>四元组为什么服务器端只需要建立一个端口</p></li><li><p>socket的文件描述符</p></li><li><p>socket缓冲区</p></li><li><p>socket缓冲区什么时候建立：每个socket被创建后，无论使用的是TCP协议还是UDP协议，都会创建自己的接收缓冲区和发送缓冲区。</p></li><li><p>客户端和服务器通过HTTP进行通信服务器任何人都可以访问，需要甄别出我认可的客户端</p></li><li><p>滑动窗口&#x2F;拥塞窗口为了解决什么问题（滑动窗口和拥塞窗口都是为了解决发送量的问题，那最终又谁决定？）</p></li><li><p>HTTP能用UDP传输嘛？</p></li><li><p>http1.0，http1.1，http2.0，http3.0，https分别有什么</p></li><li><p>select和epoll区别</p></li><li><p>全连接队列中的socket怎么消费</p></li><li><p>ICMP协议</p><p>1）设计是为了做哪些事情</p><p>2）除了ping还知道哪些？</p></li><li><p>IP头部中flag字段</p></li><li><p>IP分片的作用，哪个常见的命令是通过分片实现？</p></li><li><p>CLOSE_WAIT状态</p><p>1）发生在什么时候？</p><p>2）什么时候结束</p><p>3）出现了很多这个状态，原因</p></li><li><p>TIME_WAIT状态</p><p>1）发生在什么时候？</p><p>2）什么时候结束</p><p>3）为什么需要这个状态</p><p>4）出现了很多这个状态</p></li><li><p>怎么设置socket保持长连接</p></li><li><p>keepalive作用</p><p>1）不主动CLOSE也不会断开，为什么还需要这个状态</p><p>2）什么情况下需要主动断开连接（内部通讯）</p></li><li><p>OSI七层模型</p></li><li><p>netty的io多路复用是怎么实现</p></li><li><p>连接和IO事件是如何流转的（reactor模型）</p></li><li><p>日常生活中tcp和udp</p></li><li><p>TCP编程的注意点</p><p>1）发送1000个字节，如何区分这1000个字节？（哪里是1000个字节结束）</p><p>2）TCP客户端通信，如何识别报文，怎么定义报文长度，怎么发送及接收？</p><p>3）两者通信，想要一次性收到1000字节，但每次只收到了1字节，怎么处理？</p></li><li><p>HTTP和socket</p></li><li><p>HTTPS通信过程（SSL握手过程）</p></li><li><p>如何判断是否是一个子网？</p></li><li><p>子网掩码怎么获取</p></li><li><p>HTTP报文格式（常见的Header）</p></li><li><p>TCP头部信息</p></li><li><p>IP头部包含信息</p></li><li><p>HTTP头部</p><p>1）返回文件和返回图片的差异-&gt;想问content-type</p><p>2）显示图片而非下载-&gt;想问content-type</p></li><li><p>TCP建立连接的步骤</p></li><li><p>同步和异步的模型有哪些？</p></li><li><p>滑动窗口的调节算法</p></li><li><p>TCP和UDP调用connect区别</p></li><li><p>TCP&#x2F;UDP调用connet后，会真正的发送网络包嘛？</p></li><li><p>判断路由是否畅通的机制，使用TCP&#x2F;UDP</p></li><li><p>HTTP队头阻塞</p></li><li><p>TCP和UDP哪种速度更快，延时更低</p></li><li><p>Reactor和Proacte模式</p><p>1）为什么用这个？</p><p>2）并发性能</p></li><li><p>select监听文件描述符上限可以修改么？怎么修改</p></li><li><p>空轮训问题，NIO的空轮询bug是什么？netty是如何解决NIO空轮询bug的？</p></li><li><p>套接字通信的大致步骤</p></li><li><p>数据链路层有哪些协议</p></li><li><p>IPV4，IPV5和IPV6</p><p>1）含义</p><p>2）多少位</p></li><li><p>为什么绝大部分还在用IPV4而不是IPV6</p></li><li><p>网络攻击：SYN攻击</p></li><li><p>如何检测和解决SYN攻击</p></li><li><p>TCP超时重传时间如何计算？</p></li><li><p>复位报文（RST）</p></li><li><p>TCP定时器</p></li></ol><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2>]]></content>
    
    
    <categories>
      
      <category>others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker代码开发调试 mpi环境</title>
    <link href="/Docker/docker-develop/"/>
    <url>/Docker/docker-develop/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-代码开发调试流程"><a href="#docker-代码开发调试流程" class="headerlink" title="docker 代码开发调试流程"></a><a href="https://blog.csdn.net/condom10010/article/details/126742399">docker 代码开发调试流程</a></h1><ol><li>运行docker容器(同时把本地代码挂载到容器内)</li><li>使用vscode进入容器,并打开代码,修改代码,运行和调试.</li><li>在宿主机一端,使用git管理代码.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Basics of Autotools</title>
    <link href="/others/makefile-and-configure/"/>
    <url>/others/makefile-and-configure/</url>
    
    <content type="html"><![CDATA[<p><img src="/others/makefile-and-configure/diagram.png" alt="How autotools fits together"></p><p>[^A basic overview of how the main autotools components fit together]: </p><p>在一个简单的设置中。</p><ul><li>autoconf程序从configure.in或configure.ac中产生一个configure脚本（见下文注释）。</li><li>automake程序从Makefile.am中产生一个Makefile.in。</li><li>configure脚本被运行，以便从Makefile.in文件产生一个或多个Makefile文件。</li><li>make程序使用Makefile文件来编译程序</li></ul><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://devmanual.gentoo.org/general-concepts/autotools/index.html">The Basics of Autotools</a></p>]]></content>
    
    
    <categories>
      
      <category>others</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>编译相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/Java/Design_Mode/"/>
    <url>/Java/Design_Mode/</url>
    
    <content type="html"><![CDATA[<h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><h3 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a><strong>1、开闭原则（Open Close Principle）</strong></h3><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p><p>样例一：<a href="https://blog.csdn.net/m0_54485604/article/details/113502478">六大原则之开闭原则</a></p><p>将画笔类的draw()方法的实现放入对应的形状中，则新增形状无需修改画笔类的draw()方法，只需要在类中定义自己的draw()方法即可</p><p>样例二：<a href="https://blog.csdn.net/fry3309/article/details/123582415">开闭原则（开放封闭原则）</a></p><p>子类覆盖父类中需要修改的方法，通过子类代替父类来减少修改</p><h3 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></h3><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong></p><p>样例一：<a href="https://blog.csdn.net/weixin_39327556/article/details/125268590">里氏替换原则</a></p><p>对于需要修改父类内容的子类，找到更加通用的父类（父类的超类）替代其父类</p><h3 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></h3><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><h3 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a><strong>4、接口隔离原则（Interface Segregation Principle）</strong></h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h3 id="5、迪米特法则，又称最少知道原则（Demeter-Principle）"><a href="#5、迪米特法则，又称最少知道原则（Demeter-Principle）" class="headerlink" title="5、迪米特法则，又称最少知道原则（Demeter Principle）"></a><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></h3><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h3 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a><strong>6、合成复用原则（Composite Reuse Principle）</strong></h3><h2 id="二十三种常用设计模式"><a href="#二十三种常用设计模式" class="headerlink" title="二十三种常用设计模式"></a>二十三种常用设计模式</h2><table><thead><tr><th>1</th><th>创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</th><th>工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern）</th></tr></thead><tbody><tr><td>2</td><td><strong>结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td>适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern）</td></tr><tr><td>3</td><td><strong>行为型模式</strong> 这些设计模式特别关注对象之间的通信。</td><td>责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）</td></tr><tr><td>4</td><td><strong>J2EE 模式</strong> 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td><td>MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a><strong>创建型模式</strong></h3><h4 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h4><p>创造对象时无需new对象，而是用一个factory来创建，这样不会暴露产品的创建逻辑，也可以用统一的处理方式来管理产品的新建。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Factory</span>.</span></span>make(xxx);<br><br><span class="hljs-comment">// or like Executors</span><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Factory</span>.</span></span>make<span class="hljs-constructor">A()</span>;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Factory</span>.</span></span>make<span class="hljs-constructor">B()</span>;<br></code></pre></td></tr></table></figure><p>三要素：抽象产品（Shape）、具体产品（Circle、Square、Rectangle）、具体工厂（ShapeFactory）</p><p><img src="/Java/Design_Mode/image-20221121201018165.png" alt="image-20221121201018165"></p><h4 id="模版工厂模式"><a href="#模版工厂模式" class="headerlink" title="模版工厂模式"></a>模版工厂模式</h4><p>对于普通工厂模式来说，一个工厂可以生产几个不同的产品，如果需要新增产品，则需要修改factory的逻辑，不符合开闭原则。故可以使用抽象工厂模式，一个工厂对应一个产品，新增产品的同时新增工厂即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FactoryA</span> <span class="hljs-variable">factoryA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FactoryA</span>();<br><span class="hljs-type">FactoryB</span> <span class="hljs-variable">factoryB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FactoryB</span>();<br><span class="hljs-type">Product</span> <span class="hljs-variable">product1</span> <span class="hljs-operator">=</span> factoryA.make();<br><span class="hljs-type">Product</span> <span class="hljs-variable">product2</span> <span class="hljs-operator">=</span> factoryB.make();<br></code></pre></td></tr></table></figure><p>但对于模版工厂模式每一个产品都对应一个工厂，当产品种类数目较多时，系统中会存在过多的工厂，增加了系统的开销，让系统变得过于庞大。</p><h4 id="抽象工厂模式（Abstract-Factory-Pattern）"><a href="#抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="抽象工厂模式（Abstract Factory Pattern）"></a>抽象工厂模式（Abstract Factory Pattern）</h4><p>抽象工厂模式较于模版工厂模式新增了一个产品family的概念，一个具体的工厂类对应一个产品组。</p><p><img src="/Java/Design_Mode/image-20221121204536398.png" alt="image-20221121204536398"></p><h4 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h4><ul><li><p>一个类只能有一个实例对象，该对象一般可被全局访问</p></li><li><p>饿汉式and懒汉式（上锁+双重判断保证线程安全）</p></li><li><p>用private修饰构造函数</p></li><li><p>static修饰实例对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 饿汉式 建议使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingleObject</span> &#123;<br> <br>   <span class="hljs-comment">//创建 SingleObject 的一个对象</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleObject instance = <span class="hljs-keyword">new</span> SingleObject();<br> <br>   <span class="hljs-comment">//让构造函数为 private，这样该类就不会被实例化</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleObject</span>()</span>&#123;&#125;<br> <br>   <span class="hljs-comment">//获取唯一可用的对象</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleObject <span class="hljs-title">getInstance</span>()</span>&#123;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMessage</span>()</span>&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="原型模式（Prototype-Pattern）"><a href="#原型模式（Prototype-Pattern）" class="headerlink" title="原型模式（Prototype Pattern）"></a>原型模式（Prototype Pattern）</h4><p>在保障性能的情况下重复创造对象</p><ol><li>实现Cloneable接口</li><li>调用对象clone()方法（强转）</li></ol><p>缺点如下：</p><ol><li><p>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</p></li><li><p>当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆。</p></li></ol><h4 id="建造者模式（Builder-Pattern）（todo）"><a href="#建造者模式（Builder-Pattern）（todo）" class="headerlink" title="建造者模式（Builder Pattern）（todo）"></a>建造者模式（Builder Pattern）（todo）</h4><p>使用多个简单的对象一步一步构建成一个复杂的对象</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">kfd</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">DoContact</span> <span class="hljs-built_in">object</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoContact</span>.<span class="hljs-title class_">Builder</span>(<span class="hljs-string">&quot;MChopin&quot;</span>).<span class="hljs-title function_">age</span>(<span class="hljs-number">18</span>)<br>                .<span class="hljs-title function_">address</span>(<span class="hljs-string">&quot;shanghai&quot;</span>).<span class="hljs-title function_">build</span>();<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;name=&quot;</span> + <span class="hljs-built_in">object</span>.<span class="hljs-title function_">getName</span>() + <span class="hljs-string">&quot; age=&quot;</span> + <span class="hljs-built_in">object</span>.<span class="hljs-title function_">getAge</span>()<br>                + <span class="hljs-string">&quot; address=&quot;</span> + <span class="hljs-built_in">object</span>.<span class="hljs-title function_">getAddress</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><h4 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>用户通过代理对象来调用真实对象的方法，代理类类似中介</p><h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><p>由三个部分组成：公共接口、被代理对象、代理对象</p><img src="/Java/Design_Mode/image-20221124194103417.png" alt="image-20221124194103417" style="zoom:50%;"><p>Agent中rentHouse()方法实际调用了owner中的rentHouse()方法，可以在调用的前后增加操作，如收中介费等。</p><p>优点：简单</p><p>缺点：对于类中每个方法都要创建代理方法，新增与删除方法时要同步修改代理类方法，被代理对象与代理对象耦合严重</p><h5 id="jdk代理"><a href="#jdk代理" class="headerlink" title="jdk代理"></a>jdk代理</h5><p>动态代理中的一种，一个代理类可以代理多个类</p><img src="/Java/Design_Mode/image-20221124200742966.png" alt="image-20221124200742966" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Owner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandleForHouse</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rentHouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;房东租房&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellHouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;房东卖房&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">HandleForHouse</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rentHouse</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellHouse</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyOwner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span>&#123;<br>    <span class="hljs-keyword">private</span> Object object;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyOwner</span><span class="hljs-params">(Object object)</span>&#123;<br>        <span class="hljs-built_in">this</span>.object = object;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 不同类不同处理</span><br>        System.out.println(<span class="hljs-string">&quot;xxx&quot;</span>);<br>        <span class="hljs-keyword">if</span> (proxy <span class="hljs-keyword">instanceof</span> HandleForHouse)&#123;<br>            <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;rentHouse&quot;</span>))&#123;<br>                System.out.println(<span class="hljs-string">&quot;中介收租房中介费&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;sellHouse&quot;</span>))&#123;<br>                System.out.println(<span class="hljs-string">&quot;中介收卖房中介费&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> method.invoke(object, args);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Owner</span> <span class="hljs-variable">owner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Owner</span>();<br>        <span class="hljs-type">ProxyOwner</span> <span class="hljs-variable">proxyOwner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyOwner</span>(owner);<br>        <span class="hljs-type">HandleForHouse</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> (HandleForHouse) Proxy.newProxyInstance(<br>                proxyOwner.getClass().getClassLoader(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;HandleForHouse.class&#125;,<br>                proxyOwner);<br>        test1.rentHouse();<br>        test1.sellHouse();<br>    &#125;<br>&#125;<br><br>output:<br>xxx<br>中介收租房中介费<br>房东租房<br>xxx<br>中介收卖房中介费<br>房东卖房<br></code></pre></td></tr></table></figure><h5 id="cglib代理-todo"><a href="#cglib代理-todo" class="headerlink" title="cglib代理(todo)"></a>cglib代理(todo)</h5><h4 id="装饰器模式（Decorator-Pattern）"><a href="#装饰器模式（Decorator-Pattern）" class="headerlink" title="装饰器模式（Decorator Pattern）"></a>装饰器模式（Decorator Pattern）</h4><p>装饰器模式通过装饰类在不改变现有类结构的情况下对其添加新的功能，装饰类包装现有类。</p><p>由一下几个部分组成：</p><p>被装饰对象接口、被装饰对象、装饰器抽象类、装饰器具体实现</p><img src="/Java/Design_Mode/image-20221125210720349.png" alt="image-20221125210720349" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Clothes</span> <span class="hljs-variable">clothes</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeautifulClothes</span>();<br>        <span class="hljs-type">Decorator</span> <span class="hljs-variable">decorator1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoratorImplRed</span>(clothes);<br>        <span class="hljs-type">Decorator</span> <span class="hljs-variable">decorator2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoratorImplBlue</span>(clothes);<br>        decorator1.dress();<br>        decorator2.dress();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 被装饰对象接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Clothes</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dress</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 被装饰对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BeautifulClothes</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Clothes</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dress</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;穿漂亮衣服～&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 装饰器抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Clothes</span>&#123;<br>    <span class="hljs-keyword">private</span> Clothes clothes;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Clothes clothes)</span>&#123;<br>        <span class="hljs-built_in">this</span>.clothes = clothes;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dress</span><span class="hljs-params">()</span> &#123;<br>        clothes.dress();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 装饰器具体实现1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorImplRed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecoratorImplRed</span><span class="hljs-params">(Clothes clothes)</span> &#123;<br>        <span class="hljs-built_in">super</span>(clothes);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dress</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;红色装饰品&quot;</span>);<br>        <span class="hljs-built_in">super</span>.dress();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 装饰器具体实现2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorImplBlue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecoratorImplBlue</span><span class="hljs-params">(Clothes clothes)</span> &#123;<br>        <span class="hljs-built_in">super</span>(clothes);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dress</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;蓝色装饰品&quot;</span>);<br>        <span class="hljs-built_in">super</span>.dress();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h4><h4 id="享元模式（Flyweight-Pattern）"><a href="#享元模式（Flyweight-Pattern）" class="headerlink" title="享元模式（Flyweight Pattern）"></a>享元模式（Flyweight Pattern）</h4><h3 id="xxx"><a href="#xxx" class="headerlink" title="xxx"></a>xxx</h3><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式&#x2F;模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.runoob.com/design-pattern/design-pattern-intro.html">菜鸟教程-设计模式简介</a></li><li><a href="https://www.jianshu.com/p/a3e09071c44f">重构（Refactoring）学习笔记</a></li><li><a href="https://zhuanlan.zhihu.com/p/475486025">设计模式之【工厂模式】</a></li><li><a href="https://blog.csdn.net/yucaixiang/article/details/90379525">原型模式</a></li><li><a href="https://blog.csdn.net/ChineseSoftware/article/details/123256575">建造者模式(Builder Pattern)</a></li><li><a href="https://www.zhihu.com/question/21857130">什么是建造者模式？</a></li><li><a href="https://www.bilibili.com/read/cv14604081/">18设计模式——建造者模式详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
      <tag>系统架构</tag>
      
      <tag>整理总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阻塞队列（BlockingQueue）</title>
    <link href="/Java/Block-queue/"/>
    <url>/Java/Block-queue/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>实现类</th><th>特点</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>基于环形数组实现的有界阻塞队列</td></tr><tr><td>LinkedBlockingQueue</td><td>基于单链表实现的无界阻塞队列，有两个锁，可同时存取</td></tr><tr><td>LinkedBlockingDeque</td><td>基于双链表实现的无界阻塞队列，双向读写</td></tr><tr><td>DelayQueue</td><td>基于优先队列实现的延迟阻塞队列，队列中数据需要到达延迟时间才能取出</td></tr><tr><td>PriorityBlockingQueue</td><td>线程安全优先队列，底层为堆排序</td></tr><tr><td>SynchronousQueue</td><td>无缓存阻塞队列</td></tr><tr><td>LinkedTransferQueue</td><td>基于CAS和单链表实现的无界队列</td></tr></tbody></table><h2 id="二、常用方法"><a href="#二、常用方法" class="headerlink" title="二、常用方法"></a>二、常用方法</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p>以上四个方法都是将数据添加进队列</p><ul><li>add和offer，如果成功则<strong>直接（不阻塞）</strong>返回true，否则，add方法抛出IllegalStateException，而offer方法直接返回false。故对于有界的阻塞队列使用offer通常效果更佳，因为其不会抛出异常阻塞线程。</li><li>put，如果队列剩余空间不足导致加入不成功，会<strong>一直阻塞等待</strong>。</li><li>带参数offer，如果队列剩余空间不足导致加入不成功，会<strong>在时间限期内</strong>阻塞等待添加数据。</li></ul><h3 id="取出数据"><a href="#取出数据" class="headerlink" title="取出数据"></a>取出数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>E <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p>以上两个方法都是将队首数据从队列取出</p><ul><li>take如果没有数据可以取出，则会<strong>一直阻塞等待</strong>。</li><li>poll会<strong>在时间限期内</strong>阻塞等待。</li></ul><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br></code></pre></td></tr></table></figure><h3 id="批量传递数据"><a href="#批量传递数据" class="headerlink" title="批量传递数据"></a>批量传递数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">drainTo</span><span class="hljs-params">(Collection&lt;? <span class="hljs-built_in">super</span> E&gt; c)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">drainTo</span><span class="hljs-params">(Collection&lt;? <span class="hljs-built_in">super</span> E&gt; c, <span class="hljs-type">int</span> maxElements)</span>;<br></code></pre></td></tr></table></figure><p>drainTo实现将当前阻塞队列中的信息全部转移到集合c中</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>查看队列剩余容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">remainingCapacity</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>查看是否包含某个数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>;<br></code></pre></td></tr></table></figure><h2 id="三、实现类及其源码"><a href="#三、实现类及其源码" class="headerlink" title="三、实现类及其源码"></a>三、实现类及其源码</h2><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><ul><li>有界阻塞队列，底层通过Object数组以及ReentrantLock等工具实现，初始化ArrayBlockingQueue时会传入数组长度</li><li>无法存放null值</li><li>入队与出队<strong>共享同一个锁</strong></li><li><strong>while配合condition使用，等待唤醒</strong>（BlockingQueue通用）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Object[] items;<br><span class="hljs-keyword">final</span> ReentrantLock lock;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(fair);<br>    notEmpty = lock.newCondition();<br>    notFull =  lock.newCondition();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">capacity：队列容量</span><br><span class="hljs-comment">fair：是否是公平锁，默认非公平，可省略</span><br><span class="hljs-comment">c：通过集合c初始化队列数值，将c中数据全部取出放入队列中，可省略</span><br><span class="hljs-comment">⚠️</span><br><span class="hljs-comment">1. c中数据不能为null，否则会出现NullPointerException</span><br><span class="hljs-comment">2. c的长度不能大于队列容量，否则会出现IllegalArgumentException</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair, Collection&lt;? extends E&gt; c)</span> &#123; <br>     <span class="hljs-built_in">this</span>(capacity, fair);<br>      <br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>      lock.lock(); <span class="hljs-comment">// Lock only for visibility, not mutual exclusion</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">for</span> (E e : c)<br>            items[i++] = Objects.requireNonNull(e);<br>        &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>        &#125;<br>        count = i; <span class="hljs-comment">// 队列中元素个数</span><br>        putIndex = (i == capacity) ? <span class="hljs-number">0</span> : i; <span class="hljs-comment">// 下一个数据插入时存放位置</span><br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>      &#125;<br>&#125;<br><br><span class="hljs-comment">// 入队</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    items[putIndex] = e;<br>    <span class="hljs-keyword">if</span> (++putIndex == items.length) putIndex = <span class="hljs-number">0</span>;<br>    count++;<br>    notEmpty.signal(); <span class="hljs-comment">// 唤醒取数据等待队列</span><br>&#125;<br><br><span class="hljs-comment">// 出队</span><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) items[takeIndex];<br>    items[takeIndex] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="hljs-number">0</span>;<br>    count--;<br>    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-literal">null</span>)<br>      itrs.elementDequeued();<br>    notFull.signal(); <span class="hljs-comment">// 唤醒插入数据等待队列</span><br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br><br><span class="hljs-comment">//================插入数据================</span><br><span class="hljs-comment">// 插入数据，lock上锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    Objects.requireNonNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (count == items.length)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 队列满了的情况直接返回false</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        enqueue(e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Objects.requireNonNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// lockInterruptibly 与 lock比较区别在于 lockInterruptibly优先考虑响应中断，再去获取锁。 </span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (count == items.length)<br>        notFull.await(); <span class="hljs-comment">// 队列满了的情况阻塞等待</span><br>      enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//================取出数据================</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">return</span> (count == <span class="hljs-number">0</span>) ? <span class="hljs-literal">null</span> : dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>        notEmpty.await();<br>      <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><ul><li>无界阻塞队列，但也可传入capacity限定容量，默认Integer.MAX_VALUE作为最大容量（近似无界），底层通过链表以及ReentrantLock等工具实现</li><li>入队与出队<strong>分别拥有不同的锁</strong>，takeLock和putLock，故写出与取出可以同时进行</li><li>count类型为AtomicInteger，防止发生并发问题</li><li>add，offer，put，take，poll等操作实现与ArrayBlockingQueue类似</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 与ArrayBlockingQueue不同，因为添加和删除元素可以同步进行，为防止发生并发问题，此处count不能使用简单int</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(); <br><span class="hljs-keyword">transient</span> Node&lt;E&gt; head;<span class="hljs-comment">// head为哨兵节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.capacity = capacity;<br>    last = head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(<span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> &#123;<br>   last = last.next = node;<br>&#125;<br><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    Node&lt;E&gt; h = head;<br>    Node&lt;E&gt; first = h.next;<br>    h.next = h; <span class="hljs-comment">// help GC</span><br>    head = first;<br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> first.item;<br>    first.item = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><ul><li>双向队列，LinkedBlockingQueue类似，用双链表+ReentrantLock实现</li><li>用一个锁对两端的入队出队进行并发控制</li><li>linkXXX、unlinkXXX与enqueue、dequque功能及实现类似</li><li>addLFirst、addLast等同理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; prev;<br>    Node&lt;E&gt; next;<br>    Node(E x) &#123;<br>      item = x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><ul><li>带延迟的无界的阻塞队列，通过PriorityQueue（优先队列）、Delayed与ReentrantLock实现</li><li>用一个锁对PriorityQueue的入队出队进行并发控制</li><li>入队操作的add和put直接调用offer方法</li><li>出队操作返回延迟期满后的第一个元素，如果队列中没有元素或者没有延迟期满的元素，则poll操作返回null，take操作阻塞等待</li><li>使用leader线程避免大量线程在同一时间点唤醒产生大量竞争 &#x2F;&#x2F; todo：理解具体实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Delayed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Delayed&gt; &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span>; <span class="hljs-comment">// 返回剩余延迟时间</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayQueue</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Delayed</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;E&gt;();<br>  <br>  <span class="hljs-comment">// 避免大量线程在同一时间点唤醒，导致大量的竞争，影响性能</span><br>  <span class="hljs-comment">// Leader-Follower模式的变体</span><br>    <span class="hljs-keyword">private</span> Thread leader;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            q.offer(e);<br>            <span class="hljs-keyword">if</span> (q.peek() == e) &#123;<br>                leader = <span class="hljs-literal">null</span>;<br>                available.signal();<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> q.peek();<br>            <span class="hljs-keyword">return</span> (first == <span class="hljs-literal">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="hljs-number">0</span>)<br>                ? <span class="hljs-literal">null</span><br>                : q.poll();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> q.peek();<br>                <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>)<br>                    available.await();<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);<br>                    <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0L</span>)<br>                        <span class="hljs-keyword">return</span> q.poll();<br>                    first = <span class="hljs-literal">null</span>; <span class="hljs-comment">// don&#x27;t retain ref while waiting</span><br>                    <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>)<br>                        available.await();<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                        leader = thisThread;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            available.awaitNanos(delay);<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-keyword">if</span> (leader == thisThread)<br>                                leader = <span class="hljs-literal">null</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; q.peek() != <span class="hljs-literal">null</span>)<br>                available.signal();<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>  <br>     <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> q.peek();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br> <br></code></pre></td></tr></table></figure><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><ul><li>并发安全的优先队列</li><li><a href="https://www.cnblogs.com/sergeantFat/p/14492538.html">阻塞优先队列（PriorityBlockingQueue）详解</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><ul><li>容量为0的阻塞队列</li><li>基于CAS无锁算法实现</li><li><a href="https://www.jianshu.com/p/d5e2e3513ba3">12. SynchronousQueue</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><ul><li>相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。可以算是 <code>LinkedBolckingQueue</code> 和 <code>SynchronousQueue</code> 和合体</li><li>底层基于单链表实现,其内部节点分为数据结点、请求结点；基于CAS无锁算法实现</li><li><a href="https://blog.csdn.net/weixin_49561445/article/details/120599614">LinkedTransferQueue</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedTransferQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransferQueue</span>&lt;E&gt;, java.io.Serializable &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h2><ol><li><p>在线程池作为任务队列</p></li><li><p>延迟队列（DelayQueue）</p><p>场景：大批量的任务处理，比如说卖票，一次性放出太多情况下系统无法承受压力</p></li><li><p>定时任务（DelayQueue）</p></li><li><p>缓存系统的设计（DelayQueue）</p><p>一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</p></li><li><p>信息同步传递[消费线程和生产线程 1:1]（SynchronousQueue）</p><p>场景：核心线程数为0的线程池</p></li></ol><h2 id="五、参考文档"><a href="#五、参考文档" class="headerlink" title="五、参考文档"></a>五、参考文档</h2><p>本文的部分内容参考或者引用以下文章，在此表示感谢，如果有涉及知识产权的问题，请联系我及时修改。</p><ul><li>jdk-11.0.2.jdk</li><li><a href="https://blog.csdn.net/c15158032319/article/details/118636233">延迟队列DelayQueue原理</a></li><li><a href="https://www.cnblogs.com/sergeantFat/p/14492538.html">阻塞优先队列（PriorityBlockingQueue）详解</a></li><li><a href="https://www.jianshu.com/p/d5e2e3513ba3">12. SynchronousQueue</a></li><li><a href="https://blog.csdn.net/weixin_49561445/article/details/120599614">LinkedTransferQueue</a></li><li><a href="https://blog.csdn.net/csfun1/article/details/122524692">并发编程-06 BlockingQueue及应用场景详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库锁机制</title>
    <link href="/Mysql/locking/"/>
    <url>/Mysql/locking/</url>
    
    <content type="html"><![CDATA[<h1 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h1><ul><li>行级锁<ul><li>共享锁</li><li>排他锁</li></ul></li><li>表级锁</li><li>意向锁</li></ul><h1 id="查看锁情况"><a href="#查看锁情况" class="headerlink" title="查看锁情况"></a>查看锁情况</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">FULL</span> PROCESSLIST<br></code></pre></td></tr></table></figure><h3 id="InnoDB-1-0开始在INFORMATION-SCHEMA架构添加了三张表可以查看"><a href="#InnoDB-1-0开始在INFORMATION-SCHEMA架构添加了三张表可以查看" class="headerlink" title="InnoDB 1.0开始在INFORMATION_SCHEMA架构添加了三张表可以查看"></a>InnoDB 1.0开始在INFORMATION_SCHEMA架构添加了三张表可以查看</h3><p>INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS</p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>锁</tag>
      
      <tag>数据库</tag>
      
      <tag>MySql</tag>
      
      <tag>InnoDB存储引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程池</title>
    <link href="/Java/Thread_pool/"/>
    <url>/Java/Thread_pool/</url>
    
    <content type="html"><![CDATA[<h2 id="一、基本参数"><a href="#一、基本参数" class="headerlink" title="一、基本参数"></a>一、基本参数</h2><p>新建一个线程池实例可调用Executors的newCachedThreadPool()、newFixedThreadPool()等方法，实际上这些方法的底层都是调用的ThreadPoolExecutor的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              TimeUnit unit,</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              ThreadFactory threadFactory,</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>corePoolSize</strong>：指定线程池的核心线程数，核心线程能够一直存活在线程池中。</li><li><strong>maximumPoolSize</strong>：指定线程池能存活的最大线程数，要求maximumPoolSize &gt;&#x3D; corePoolSize，最大线程数与核心线程数的差值为线程池内临时线程的最大数目。</li><li>keepAliveTime：临时线程存活时间，<strong>临时线程</strong>在<strong>空闲</strong>超过当前时间时会被销毁。</li><li>unit：keepAliveTime的时间单位。</li><li><strong>workQueue</strong>：任务队列，被提交到线程池的尚未被执行的任务。</li><li>threadFactory：用于创建线程的线程工厂，一般使用默认工厂。 非必需传入。</li><li><strong>handler</strong>：拒绝策略，任务太多情况下使用拒绝策略处理超出任务。非必需传入。</li></ul><p>具体信息见源码解读&gt;关键参数</p><h2 id="二、线程池状态"><a href="#二、线程池状态" class="headerlink" title="二、线程池状态"></a>二、线程池状态</h2><p>线程池有五种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure><h2 id="三、执行机制"><a href="#三、执行机制" class="headerlink" title="三、执行机制"></a>三、执行机制</h2><p><img src="/Java/Thread_pool/f228f23338ef4a0ebd615b965fd94894.png" alt="线程池执行机制"></p><h2 id="四、源码解读"><a href="#四、源码解读" class="headerlink" title="四、源码解读"></a>四、源码解读</h2><h3 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h3><h4 id="1-corePoolSize"><a href="#1-corePoolSize" class="headerlink" title="1. corePoolSize"></a>1. corePoolSize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> corePoolSize;<br></code></pre></td></tr></table></figure><ul><li>volatile修饰</li><li>最小值为0</li><li>不允许超时销毁，会一直存活在线程池内，除非设置了允许核心线程超时（allowCoreThreadTimeOut &#x3D; true）</li></ul><h4 id="2-maximumPoolSize"><a href="#2-maximumPoolSize" class="headerlink" title="2. maximumPoolSize"></a>2. maximumPoolSize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> maximumPoolSize;<br></code></pre></td></tr></table></figure><ul><li>最大线程数目</li><li>超时销毁</li><li>值大于等于核心线程数目</li></ul><h4 id="3-workQueue"><a href="#3-workQueue" class="headerlink" title="3. workQueue"></a>3. workQueue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br></code></pre></td></tr></table></figure><p>The queue used for holding tasks and handing off to worker threads.  We do not require that workQueue.poll() returning null necessarily means that workQueue.isEmpty(), so rely solely on isEmpty to see if the queue is empty (which we must do for example when deciding whether to transition from SHUTDOWN to TIDYING).  This accommodates special-purpose queues such as DelayQueues for which poll() is allowed to return null even if it may later return non-null when delays expire.</p><ul><li>存放待工作线程处理的任务</li></ul><p><strong>BlockQueue的继承与实现</strong></p><p><img src="/Java/Thread_pool/image-20221021111242474.png" alt="image-20221021111242474"></p><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </p><h3 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h3><h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><h2 id="五、使用场景与优缺点"><a href="#五、使用场景与优缺点" class="headerlink" title="五、使用场景与优缺点"></a>五、使用场景与优缺点</h2><p>空间换时间</p><h2 id="六、面试与思考"><a href="#六、面试与思考" class="headerlink" title="六、面试与思考"></a>六、面试与思考</h2><ol><li><strong>线程池参数及含义。</strong></li><li><strong>向线程池提交一个任务会直接运行吗？</strong></li><li>线程池任务提交流程。</li><li>线程池是如何保持池内线程存活的。</li></ol><h2 id="七、参考文档"><a href="#七、参考文档" class="headerlink" title="七、参考文档"></a>七、参考文档</h2><p>本文的部分内容参考或者引用以下文章，在此表示感谢，如果有涉及知识产权的问题，请联系我及时修改。</p><ul><li>《实战Java高并发程序设计》</li><li><a href="https://blog.csdn.net/qq_37602560/article/details/123845442">线程池的-任务执行机制</a></li><li>jdk-11.0.2.jdk</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
      <tag>源码</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣2312. 卖木头块</title>
    <link href="/Algorithm/selling-pieces-of-wood/"/>
    <url>/Algorithm/selling-pieces-of-wood/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/selling-pieces-of-wood/description/">https://leetcode.cn/problems/selling-pieces-of-wood/description/</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP</title>
    <link href="/Algorithm/KMP/"/>
    <url>/Algorithm/KMP/</url>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>字符串匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/Architecture/docker/"/>
    <url>/Architecture/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h1><h2 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h2><p>Docker是一个<strong>轻量级</strong>的可以将应用及其依赖进行打包并发布到不同操作系统的Linux<strong>容器</strong>的一种封装。Docker本身并不是容器，它是创建容器的工具，是应用容器引擎。</p><h2 id="Docker的核心概念"><a href="#Docker的核心概念" class="headerlink" title="Docker的核心概念"></a>Docker的核心概念</h2><p>• 镜像（Image）：一组应用及其依赖的打包，是一个只读的提供容器运行时所需的程序、库、资源、配置等文件以及一些为运行时准备的配置参数的环境打包。</p><p>• 容器（Container）：是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除</p><p>• 仓库（Repository）：是docker存放镜像的场所</p><h2 id="操作系统、虚拟机、容器和进程有什么区别"><a href="#操作系统、虚拟机、容器和进程有什么区别" class="headerlink" title="操作系统、虚拟机、容器和进程有什么区别"></a>操作系统、虚拟机、容器和进程有什么区别</h2><p>操作系统</p><p><img src="/Architecture/docker/v2-145c3cb904f8696ea68dbcb54b24938b_1440w.webp" alt="img"></p><h2 id="关于k8s"><a href="#关于k8s" class="headerlink" title="关于k8s"></a>关于k8s</h2><h1 id="Docker怎么用"><a href="#Docker怎么用" class="headerlink" title="Docker怎么用"></a>Docker怎么用</h1><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>本文的部分内容参考或者引用以下文章，在此表示感谢，如果有涉及知识产权的问题，请联系我及时修改。</p><ul><li><a href="https://blog.csdn.net/crazymakercircle/article/details/120747767">Docker原理（图解+秒懂+史上最全）</a></li><li><a href="https://zhuanlan.zhihu.com/p/144292368">云原生时代（四）：容器和Docker</a></li><li><a href="https://www.cnblogs.com/My-zhanglulu/p/16274319.html">什么是Docker容器?(全面了解使用)</a></li></ul><p>未完待续。。。</p>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>云计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/Algorithm/Knapsack%20problem/"/>
    <url>/Algorithm/Knapsack%20problem/</url>
    
    <content type="html"><![CDATA[<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>可转换为取或者不取第i个物品的问题，递推公式为：dp[i][v]&#x3D; Max(dp[i-1][v], dp[i-1][v-c[i]] + w[i])，其中dp[i][v]为对于前i个物品有一个容量为v的背包，此时能装入的最大价值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 注：0是补充对齐的</span><br>        <span class="hljs-type">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>, V = <span class="hljs-number">5</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; v &lt;= V; v++) &#123;<br>                dp[i][v] = dp[i-<span class="hljs-number">1</span>][v];<br>                <span class="hljs-keyword">if</span>(v &gt;= c[i])&#123;<br>                    dp[i][v] = Math.max(dp[i][v], dp[i-<span class="hljs-number">1</span>][v-c[i]] + w[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            System.out.println(Arrays.toString(dp[i]));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">output：<br><span class="hljs-string">[0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 2]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 2]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 3]</span><br><span class="hljs-string">[0, 0, 2, 4, 4, 6]</span><br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span>[] dp2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[V+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> V; v &gt;= c[i] ; v--) &#123;<br>    dp2[v] = Math.max(dp2[v-c[i]]+w[i],dp2[v]);<br>  &#125;<br>  System.out.println(Arrays.toString(dp2));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 2]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 2]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 3]</span><br><span class="hljs-string">[0, 0, 2, 4, 4, 6]</span><br></code></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li><a href="https://leetcode-cn.com/problems/target-sum/">目标和</a>：转化问题以后为0-1背包方案数问题。</li><li><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a>：转化后为0-1背包可行性问题。</li><li><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后一块石头的重量 II</a>：转化后为0-1背包最小值问题。</li></ul><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><ul><li><p><input checked disabled type="checkbox"> <a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a>：完全背包最小值</p></li><li><p><input checked disabled type="checkbox"> <a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a>：完全背包最小值</p></li></ul><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><ul><li><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">01 字符构成最多的字符串</a>：多维费用的 0-1 背包最大值，两个背包大小：0和1的数量</li><li><a href="https://leetcode-cn.com/problems/profitable-schemes/">盈利计划</a>：多维费用的 0-1 背包最大值</li></ul><h2 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h2><h2 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h2><ul><li><a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/">掷骰子的N种方法</a>：每一组是一个骰子，每个骰子只能拿一个体积为1到6的物品</li></ul><h2 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h2><h2 id="背包问题求方案数"><a href="#背包问题求方案数" class="headerlink" title="背包问题求方案数"></a>背包问题求方案数</h2><ul><li><input disabled type="checkbox"> <a href="https://leetcode.cn/problems/coin-change-ii/">零钱兑换 II</a>：完全背包方案数</li><li><input disabled type="checkbox"> <a href="https://leetcode-cn.com/problems/combination-sum-iv/">组合总和 Ⅳ</a>：考虑物品顺序的完全背包方案数。每个物品可以重复拿，有几种装满背包的方案？</li></ul><h2 id="背包问题求具体方案"><a href="#背包问题求具体方案" class="headerlink" title="背包问题求具体方案"></a>背包问题求具体方案</h2><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li><a href="https://github.com/tianyicui/pack">背包问题九讲 2.0 beta1.2 崔添翼 (Tianyi Cui)*</a></li><li><a href="https://blog.csdn.net/e891377/article/details/117639203">LeetCode背包问题—题目列表</a></li></ul><p>未完待续。。。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统IO详解</title>
    <link href="/OS/IO/"/>
    <url>/OS/IO/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
