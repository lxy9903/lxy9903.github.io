<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MPI混合OpenMP编程入门</title>
    <link href="/MPI/MPI+OpenMP/"/>
    <url>/MPI/MPI+OpenMP/</url>
    
    <content type="html"><![CDATA[<h2 id="混合编程"><a href="#混合编程" class="headerlink" title="混合编程"></a>混合编程</h2><p><strong>代码：</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mpi.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;omp.h&quot;</span></span><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>*argv[])<br>&#123;<br>    <span class="hljs-type">int</span> my_rank,numprocs,thread_id,nthreads;<br>    <span class="hljs-built_in">MPI_Init</span>(&amp;argc,&amp;argv);<br>    <span class="hljs-built_in">MPI_Comm_size</span>(<span class="hljs-built_in">MPI_COMM_WORLD</span>,&amp;numprocs);<br>    <span class="hljs-built_in">MPI_Comm_rank</span>(<span class="hljs-built_in">MPI_COMM_WORLD</span>,&amp;my_rank);<br>    <span class="hljs-type">int</span> hostname;<br>    <span class="hljs-type">char</span> hostbuffer[<span class="hljs-number">256</span>];<br>    hostname = gethostname(hostbuffer, <span class="hljs-keyword">sizeof</span>(hostbuffer));<br>    omp_set_num_threads(<span class="hljs-number">4</span>);<br>  <br>     <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(thread_id, nthreads)</span><br>    &#123;<br>        thread_id=omp_get_thread_num();<br>        nthreads=omp_get_num_threads();<br>        printf(<span class="hljs-string">&quot;Hello,The World!from thread number %d (on %d)for the MPI process number %d (on %d) %s\n&quot;</span>,thread_id, nthreads, my_rank, numprocs, hostbuffer);<br>    &#125;<br>    <span class="hljs-built_in">MPI_Finalize</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// mpicc demo2.c -o demo2 -fopenmp</span><br><span class="hljs-comment">// mpirun -np 6 ./demo2</span><br><br></code></pre></td></tr></table></figure><p><strong>编译：</strong></p><p>mpicc demo2.c -o demo2 -fopenmp</p><p><strong>分发：</strong></p><p>scp demo2 lxy@slave2:~&#x2F;code&#x2F;mpi_test&#x2F;demo2</p><p><strong>运行：</strong></p><p>mpiexec –hostfile host -np 4 demo2</p><p><strong>结果：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">0</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">0</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) slave1<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">2</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">0</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) slave1<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">3</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">0</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) slave1<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">0</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">1</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) slave1<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">1</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">1</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) slave1<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">3</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">1</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) slave1<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">2</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">1</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) slave1<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">0</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">2</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) localhost.localdomain<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">1</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">2</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) localhost.localdomain<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">1</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">0</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) slave1<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">0</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">3</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) localhost.localdomain<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">2</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">3</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) localhost.localdomain<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">1</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">3</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) localhost.localdomain<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">2</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">2</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) localhost.localdomain<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">3</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">2</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) localhost.localdomain<br><span class="hljs-attribute">Hello</span>,The World!from thread number <span class="hljs-number">3</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>)for the MPI process number <span class="hljs-number">3</span> (<span class="hljs-literal">on</span> <span class="hljs-number">4</span>) localhost.localdomain<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/weixin_43996701/article/details/117704832">MPI和OpenMP混合编程并行计算–入门程序</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MPI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
      <tag>OpenMP</tag>
      
      <tag>混合编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多台服务器运行mpi代码</title>
    <link href="/MPI/hello%20world/"/>
    <url>/MPI/hello%20world/</url>
    
    <content type="html"><![CDATA[<h2 id="安装mpi"><a href="#安装mpi" class="headerlink" title="安装mpi"></a>安装mpi</h2><p>可参考：</p><ul><li><a href="https://blog.csdn.net/m0_49448331/article/details/128041491">ubuntu下安装openMPI</a></li><li><a href="http://t.zoukankan.com/xingkongyihao-p-9733260.html">ubuntu下安装openMPI2</a></li></ul><h2 id="hello-word"><a href="#hello-word" class="headerlink" title="hello word"></a>hello word</h2><ol><li>准备代码</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino">%%file hello.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> rank, size;<br>    <span class="hljs-built_in">MPI_Init</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;rank);<br>    <span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;size);<br>    <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am process %i out of %i.\n&quot;</span>, rank, size);<br>    <span class="hljs-built_in">MPI_Finalize</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>编译</p><p>mpicc -o hello hello.c </p></li><li><p>运行</p><p>mpirun -np 4 hello</p></li><li><p>结果</p></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">I</span> am process <span class="hljs-number">1</span> out of <span class="hljs-number">4</span>.<br><span class="hljs-attribute">I</span> am process <span class="hljs-number">3</span> out of <span class="hljs-number">4</span>.<br><span class="hljs-attribute">Hello</span> world!<br><span class="hljs-attribute">I</span> am process <span class="hljs-number">0</span> out of <span class="hljs-number">4</span>.<br><span class="hljs-attribute">I</span> am process <span class="hljs-number">2</span> out of <span class="hljs-number">4</span>.<br></code></pre></td></tr></table></figure><h2 id="多台服务器运行mpi代码"><a href="#多台服务器运行mpi代码" class="headerlink" title="多台服务器运行mpi代码"></a>多台服务器运行mpi代码</h2><ol><li><p>设置免密钥</p><p>可参考：xxx</p></li><li><p>在每个服务器安装同样版本的mpi，并在同一个目录下存放相同代码（编译后可执行文件即可），并编译</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> rank, size;<br>    MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br>    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);<br>    <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> hostbuffer[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">int</span> hostname;<br>    hostname = gethostname(hostbuffer, <span class="hljs-keyword">sizeof</span>(hostbuffer));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am process %i out of %i in %s\n&quot;</span>, rank, size, hostbuffer);<br>    MPI_Finalize();<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>运行</li></ol><p>​1）命令：mpirun -np 4 -host slave1:2 -host slave2:2 hello</p><p>​2）通过host文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">%%file host<br>slave1  <span class="hljs-attribute">slots</span>=2<br>slave2  <span class="hljs-attribute">slots</span>=2<br></code></pre></td></tr></table></figure><p>​命令：mpiexec –hostfile host -np 4 hello2</p><ol start="4"><li><p>结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Hello</span> world!<br><span class="hljs-attribute">I</span> am process <span class="hljs-number">0</span> out of <span class="hljs-number">4</span> in slave1<br><span class="hljs-attribute">I</span> am process <span class="hljs-number">1</span> out of <span class="hljs-number">4</span> in slave1<br><span class="hljs-attribute">I</span> am process <span class="hljs-number">2</span> out of <span class="hljs-number">4</span> in localhost.localdomain<br><span class="hljs-attribute">I</span> am process <span class="hljs-number">3</span> out of <span class="hljs-number">4</span> in localhost.localdomain<br></code></pre></td></tr></table></figure></li></ol><h2 id="问题（暂未解决）"><a href="#问题（暂未解决）" class="headerlink" title="问题（暂未解决）"></a>问题（暂未解决）</h2><p>slave1能顺利运行，slave2不能多节点启动</p><p>export PATH&#x3D;”$PATH:&#x2F;home&#x2F;zyf&#x2F;openmpi&#x2F;bin”<br>export LD_LIBRARY_PATH&#x3D;”$LD_LIBRARY_PATH:&#x2F;home&#x2F;zyf&#x2F;openmpi&#x2F;lib&#x2F;“</p><p>⚠️：<a href="https://blog.csdn.net/YFaris/article/details/120812209">https://blog.csdn.net/YFaris/article/details/120812209</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://t.zoukankan.com/devilmaycry812839668-p-15107935.html">多网卡系统下如何使用tcp协议实现MPI的分布式多机运行（mpi的实现使用openmpi）</a></p><p><a href="https://javaforall.cn/184663.html">集群机器搭建多节点MPI运行环境</a></p>]]></content>
    
    
    <categories>
      
      <category>MPI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
      <tag>并行编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令——查看cpu相关</title>
    <link href="/Documentation/Linux/"/>
    <url>/Documentation/Linux/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="lscpu"><a href="#lscpu" class="headerlink" title="lscpu"></a>lscpu</h4></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">lxy@xxx</span> <span class="hljs-string">~</span>]<span class="hljs-string">$</span> <span class="hljs-string">lscpu</span><br><span class="hljs-attr">Architecture:</span>        <span class="hljs-string">x86_64</span><br><span class="hljs-string">CPU</span> <span class="hljs-string">op-mode(s):</span>      <span class="hljs-number">32</span><span class="hljs-string">-bit,</span> <span class="hljs-number">64</span><span class="hljs-string">-bit</span> <br><span class="hljs-attr">Byte Order:</span>          <span class="hljs-string">Little</span> <span class="hljs-string">Endian</span>  <span class="hljs-comment">#字节序：小端</span><br><span class="hljs-string">CPU(s):</span>              <span class="hljs-number">12</span><span class="hljs-comment">#逻辑cpu数</span><br><span class="hljs-string">On-line</span> <span class="hljs-string">CPU(s)</span> <span class="hljs-attr">list:</span> <span class="hljs-number">0</span><span class="hljs-number">-11</span><br><span class="hljs-string">Thread(s)</span> <span class="hljs-attr">per core:</span>  <span class="hljs-number">1</span><span class="hljs-comment">#每个核心的线程数</span><br><span class="hljs-string">Core(s)</span> <span class="hljs-attr">per socket:</span>  <span class="hljs-number">6</span>  <span class="hljs-comment">#每个cpu的核心数</span><br><span class="hljs-string">Socket(s):</span>           <span class="hljs-number">2</span><span class="hljs-comment">#cpu插槽数</span><br><span class="hljs-string">NUMA</span> <span class="hljs-string">node(s):</span>        <span class="hljs-number">2</span><br><span class="hljs-attr">Vendor ID:</span>           <span class="hljs-string">GenuineIntel</span><br><span class="hljs-attr">CPU family:</span>          <span class="hljs-number">6</span><br><span class="hljs-attr">Model:</span>               <span class="hljs-number">85</span><br><span class="hljs-attr">Model name:</span>          <span class="hljs-string">Intel(R)</span> <span class="hljs-string">Xeon(R)</span> <span class="hljs-string">Bronze</span> <span class="hljs-number">3204 </span><span class="hljs-string">CPU</span> <span class="hljs-string">@</span> <span class="hljs-number">1.</span><span class="hljs-string">90GHz</span><br><span class="hljs-attr">Stepping:</span>            <span class="hljs-number">7</span><br><span class="hljs-attr">CPU MHz:</span>             <span class="hljs-number">800.278</span><br><span class="hljs-attr">CPU max MHz:</span>         <span class="hljs-number">1900.0000</span><br><span class="hljs-attr">CPU min MHz:</span>         <span class="hljs-number">800.0000</span><br><span class="hljs-attr">BogoMIPS:</span>            <span class="hljs-number">3800.00</span><br><span class="hljs-attr">Virtualization:</span>      <span class="hljs-string">VT-x</span><br><span class="hljs-attr">L1d cache:</span>           <span class="hljs-string">32K</span> <span class="hljs-comment">#数据缓存</span><br><span class="hljs-attr">L1i cache:</span>           <span class="hljs-string">32K</span><span class="hljs-comment">#指令缓存</span><br><span class="hljs-attr">L2 cache:</span>            <span class="hljs-string">1024K</span><br><span class="hljs-attr">L3 cache:</span>            <span class="hljs-string">8448K</span><br><span class="hljs-string">NUMA</span> <span class="hljs-string">node0</span> <span class="hljs-string">CPU(s):</span>   <span class="hljs-number">0</span><span class="hljs-string">,2,4,6,8,10</span><br><span class="hljs-string">NUMA</span> <span class="hljs-string">node1</span> <span class="hljs-string">CPU(s):</span>   <span class="hljs-number">1</span><span class="hljs-string">,3,5,7,9,11</span><br></code></pre></td></tr></table></figure><ul><li><h4 id="cat-x2F-proc-x2F-cpuinfo"><a href="#cat-x2F-proc-x2F-cpuinfo" class="headerlink" title="cat &#x2F;proc&#x2F;cpuinfo"></a>cat &#x2F;proc&#x2F;cpuinfo</h4></li></ul>]]></content>
    
    
    <categories>
      
      <category>Document</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Document</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI Continued</title>
    <link href="/MPI/Introduction-to-Parallel-Programming/MPI%20Continued/"/>
    <url>/MPI/Introduction-to-Parallel-Programming/MPI%20Continued/</url>
    
    <content type="html"><![CDATA[<h2 id="第一节、Advanced-communication-in-MPI"><a href="#第一节、Advanced-communication-in-MPI" class="headerlink" title="第一节、Advanced communication in MPI"></a>第一节、<strong>Advanced communication in MPI</strong></h2><h3 id="一、Welcome-to-Week-4"><a href="#一、Welcome-to-Week-4" class="headerlink" title="一、Welcome to Week 4"></a>一、Welcome to Week 4</h3><p>在本周，我们将介绍一些高级MPI主题，当你问自己如何做得更好时，你可能会发现这些主题很有用。<br>一个更好的并行化方法是<strong>将计算和通信与非阻塞通信重叠</strong>起来。另一个问题是，我们是否可以<strong>用MPI和OpenMP减少内存，用混合或单边的方法获得速度</strong>？当事情变得很大时，我们希望把它们和我们自己的派生类型结合在一起，这样可以简化编程。在本周结束时，我们将研究一下文件的并行编写，可以用它来代替通过MPI收集结果。还有一些高级的MPI主题，我们不会在这里详细介绍，它们是其他PRACE课程的一部分。</p><h3 id="二、Non-Blocking-communications"><a href="#二、Non-Blocking-communications" class="headerlink" title="二、Non-Blocking communications"></a>二、Non-Blocking communications</h3><p>我们在上一周看到，MPI中的通信类型可以用两个参数来划分，即根据参与的进程数量来划分。</p><ul><li>点对点通信</li><li>集体通信</li></ul><p>而另一种划分方式则是与操作的完成情况有关，即。</p><ul><li>阻塞性操作</li><li>非阻塞性操作</li></ul><p>在我们之前学习的通信模式中，我们已经看到了一些问题，直到现在。例如，在环形的例子中，我们有一个循环分布的进程，我们想沿着环形发送消息，我们意识到，阻塞式例程在某种程度上不适合于此。问题是，对于第二个或第三个进程来说，为了真正接收到一些东西，它将不得不等待消息被发送到第一个进程，以此类推。所以，很明显，我们正在失去时间，而且没有产生一个好的并行应用。</p><img src="/MPI/Introduction-to-Parallel-Programming/MPI%20Continued/image-20221210105123759.png" alt="image-20221210105123759" style="zoom:50%;"><p>在使用阻塞例程时，当我们对代码进行剖析时，经常会出现我们之前讨论过的死锁问题，也就是说，要么有一些已发送的数据我们从未收到，要么反之亦然。尽管这种情况可以解决，然而，还有一个更复杂的问题会出现。假设在前面的例子中，如果我们会使用阻塞式通信来做。在这种情况下，我们基本上会把我们的代码序列化（见下图），我们可以看到一些进程需要等待；我们的资源被浪费了。这就明确了需要一些其他的聪明的方法来通过这个环来发送消息，而不需要那么多的等待时间，这就是非阻塞通信发挥作用的地方了。</p><img src="/MPI/Introduction-to-Parallel-Programming/MPI%20Continued/image-20221210105331732.png" alt="image-20221210105331732" style="zoom:50%;"><p>正如我们在上一周已经看到的，那个非阻塞例程立即返回，并允许子程序执行其他工作，所以我们可以在两者之间做一些工作，这很有用，因为，例如，我们可以发送一个消息，做一些操作，然后我们可以接收消息。所以，这三个部分在非阻塞式通信中是必不可少的。</p><p>所以，非阻塞式通信分为三个阶段。</p><ul><li>第一阶段显然是启动非阻塞通信。我们将用大写的I来区分所有非阻塞的命令，这意味着立即。因此，在MPI和下划线之后，将立即出现大写的I：MPI_Isend和MPI_Irecv。这些协议将看起来像。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">MPI_Isend</span> (<span class="hljs-type">void</span> *buf, <span class="hljs-type">int</span> count, <span class="hljs-built_in">MPI_Datatype</span> datatype, <span class="hljs-type">int</span> dest, <span class="hljs-type">int</span> tag, <span class="hljs-built_in">MPI_Comm</span> comm, <span class="hljs-built_in">MPI_Request</span> *request);<br></code></pre></td></tr></table></figure><p>​and</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">MPI_Irecv</span> (<span class="hljs-type">void</span> *buf, <span class="hljs-type">int</span> count, <span class="hljs-built_in">MPI_Datatype</span> datatype, <span class="hljs-type">int</span> source, <span class="hljs-type">int</span> tag, <span class="hljs-built_in">MPI_Comm</span> comm, <span class="hljs-built_in">MPI_Request</span> *request);<br></code></pre></td></tr></table></figure><p> 然后我们可以做一些其他的工作，因为当我们使用这个例程的时候，它并没有阻挡我们，所以我们可以在这之后做一些操作。然而，稍后我们实际上要检查消息是否已经被收到。</p><p>为了完成这个最后阶段，我们需要等待非阻塞通信的完成，我们通过调用MPI_Wait函数来完成这个任务。这就完成了整个过程。这个请求只是MPI中类似于status的另一个结构，所以我们只是把它定义为类似于status，然后把指针放在那里。这个函数的原型看起来像。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">MPI_Wait</span> (<span class="hljs-built_in">MPI_Request</span> *request, <span class="hljs-built_in">MPI_Status</span> *status);<br></code></pre></td></tr></table></figure><p>在下面两个例子的帮助下，我们将更清楚地理解这一点。</p><img src="/MPI/Introduction-to-Parallel-Programming/MPI%20Continued/image-20221210105602570.png" alt="image-20221210105602570" style="zoom:50%;"><p>在这个例子中，我们假设所有的进程都想沿环路分享一些信息。如图所示，进程0想向1发送一些信息，6想向0发送一些信息，以此类推。这里的想法是，首先我们初始化非阻塞的发送，然后我们发送信息。所以，主要是我们启动非阻塞发送到右边的邻居。正如我们所知道的，在非阻塞通信中，在我们完成了这些之后，我们可以做一些工作。在我们的例子中，我们将通过经典的接收函数来接收消息。所以，在这个环形的例子中，接收来自左邻右舍的信息。最后，我们必须调用MPI_Wait函数，以检查一切是否已经完成，并使非阻塞性发送完成。</p><p>也许你已经清楚地看到，从根本上说，在这个环形的例子中，非阻塞性帮助了我们，所以每个进程都可以开始发送，但同时，我们仍然可以做其他事情。</p><p>以类似的方式，我们可以启动非阻塞的接收。所以在我们的环形例子中，这将意味着我们从左邻右舍发起非阻塞接收。这将意味着我们将收到一些东西，但也许不是现在，也许以后，我们做一些工作。在这种情况下，这将意味着向下面的接收者发送信息，因此，将信息发送给右边的邻居。最后，我们会调用MPI_Wait函数来等待非阻塞接收完成。<br>让我们在下面的练习中通过实现这些想法来进一步巩固这些想法吧</p><h3 id="三、Rotating-information-around-a-ring-non-blocking"><a href="#三、Rotating-information-around-a-ring-non-blocking" class="headerlink" title="三、Rotating information around a ring (non-blocking)"></a>三、Rotating information around a ring (non-blocking)</h3><p>在这个练习中，你将尝试使用阻塞式和非阻塞式通信。通过使用非阻塞通信，我们要避免闲置时间、死锁和序列化。这是两部分练习的第二部分。</p><p>这是之前环形通信练习的延续，当时你使用了阻塞通信来解决它。现在你将重复这个练习，但你现在要用非阻塞通信的最佳方式来解决死锁问题。</p><p>练习</p><ul><li>用MPI_Isend（非阻塞的同步发送）代替MPI_Send，并将等待语句放在正确的位置。保留正常阻塞的MPI_Recv。运行该程序。</li><li>你是否已经有了防止死锁的经验？你在过去使用过哪些方法？你有没有想过序列化的问题？</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file ring.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> rank, size;<br>    <span class="hljs-type">int</span> snd_buf, rcv_buf;<br>    <span class="hljs-type">int</span> right, left;<br>    <span class="hljs-type">int</span> sum, i;<br>    MPI_Status status;<br>    MPI_Request request; <span class="hljs-comment">//added request variable</span><br><br>    MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br>    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);<br><br>    right = (rank+<span class="hljs-number">1</span>)      % size;<br>    left  = (rank<span class="hljs-number">-1</span>+size) % size;<br><br>    sum = <span class="hljs-number">0</span>;<br>    snd_buf = rank;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size; i++) <br>    &#123;<br>        MPI_Isend(&amp;snd_buf, <span class="hljs-number">1</span>, MPI_INT, right, <span class="hljs-number">17</span>, MPI_COMM_WORLD, &amp;request); <span class="hljs-comment">//substitute send with issend</span><br>        MPI_Recv(&amp;rcv_buf, <span class="hljs-number">1</span>, MPI_INT, left,  <span class="hljs-number">17</span>, MPI_COMM_WORLD, &amp;status);<br>        MPI_Wait(&amp;request, &amp;status); <span class="hljs-comment">//wait right after receive</span><br>        <span class="hljs-comment">//only after this wait you are allowed to modify the send buffer</span><br>        <span class="hljs-comment">//you must not modify the buffer between the issend and the wait</span><br>        snd_buf = rcv_buf;<br>        sum += rcv_buf;<br>    &#125;<br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;PE%i:\tSum = %i\n&quot;</span>, rank, sum);<br><br>    MPI_Finalize();<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="四、One-sided-communication"><a href="#四、One-sided-communication" class="headerlink" title="四、One sided communication"></a>四、One sided communication</h3><p>正如我们在一开始已经学到的，MPI的并行化是基于分布式内存的。这意味着，如果我们在不同的核心上运行一个程序，每个核心都有自己的私有内存。由于内存对每个进程都是私有的，所以我们发送消息来从一个进程到另一个进程交换数据。</p><p>在两边（即点对点通信）和集体通信模型中，问题是（即使在非阻塞的情况下）发送方和接收方都必须明确参与数据交换操作，这就需要同步。</p><img src="/MPI/Introduction-to-Parallel-Programming/MPI%20Continued/image-20221210111905587.png" alt="image-20221210111905587" style="zoom:50%;"><p>在这个例子中，我们可以看到，当我们有非阻塞程序时，但问题是，当我们调用MPI_Send，直到MPI_Recv收到消息时，有这么一段时间，两个进程都必须等待，它们不能做任何事情。因此，<strong>这种方法的一个重要缺点是，发送方必须等待接收方准备好接收数据，然后才能发送数据，或者反之亦然。这就造成了空闲时间。为了避免这种情况，我们使用单边通信。</strong></p><p>尽管MPI使用的是分布式内存方法，但MPI标准引入了<strong>远程内存访问（RMA）例程</strong>，也称为单边通信，因为它只需要一个进程来传输数据。<strong>简单地说，它使一个进程可以从其他进程的内存中访问一些数据。这个想法是，一个进程可以直接访问一个远程进程的内存地址空间，而无需该远程进程的干预。</strong></p><img src="/MPI/Introduction-to-Parallel-Programming/MPI%20Continued/image-20221210112048211.png" alt="image-20221210112048211" style="zoom:50%;"><p>因此，<strong>我们不必明确调用参与通信的两个进程的发送和接收例程。一个进程可以直接从另一个进程的内存中放入和获取数据。这很有帮助，因为目标进程可以继续执行它的任务，做它的工作而不需要等待什么。</strong>因此，单边通信最重要的好处是，当一个进程从远程进程中放入或得到数据时，远程进程可以继续计算而不是等待数据。这减少了通信时间，并可以解决程序的可扩展性方面的一些问题（即在成千上万的MPI进程上）。</p><p><strong>为了允许其他进程访问其内存，一个进程必须明确地将自己的内存暴露给其他人。这意味着，为了让原进程访问目标进程的内存，目标进程必须允许该内存被访问和使用。它通过声明一个共享内存区域（也称为窗口）来做到这一点。</strong>这个窗口成为内存中的一个区域，它对通信器中的所有其他进程都是可用的，允许它们从其内存中放入和获取数据。这个窗口的创建是通过调用函数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">MPI_Win_create</span> (<span class="hljs-type">void</span> *base, <span class="hljs-built_in">MPI_Aint</span> size, <span class="hljs-type">int</span> disp_unit, <span class="hljs-built_in">MPI_Info</span> info, <span class="hljs-built_in">MPI_Comm</span> comm, <span class="hljs-built_in">MPI_Win</span> *win);<br></code></pre></td></tr></table></figure><p>这个函数中的参数是相当不同的。它们是如下的。</p><ul><li>base是指向要公开的本地数据的指针，也就是我们想要访问的数据。</li><li>size表示本地数据的大小，单位是字节。</li><li>disp_unit是单位大小的位移。</li><li>info是信息参数。大多数情况下我们使用info_NULL。</li><li>comm是我们在前面所有函数中知道的通信器。</li><li>win代表窗口对象。</li></ul><p>在MPI应用的最后，我们必须用函数释放这个窗口</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">MPI_Win_free</span> (<span class="hljs-built_in">MPI_Win</span> *win);<br></code></pre></td></tr></table></figure><p>因此，通过这些函数，我们在内存周围创建了一个窗口，可以让其他人访问。这就是为什么在最后我们必须调用Win_free函数来释放这个窗口。</p><p>为了更好地理解，我们来看看一个经典的例子。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">MPI_Win</span> win;<br><span class="hljs-type">int</span> shared_buffer[NUM_ELEMENTS];<br><span class="hljs-built_in">MPI_Win_create</span>(shared_buffer, NUM_ELEMENT, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>), <span class="hljs-built_in">MPI_INFO_NULL</span>, <span class="hljs-built_in">MPI_COMM_WORLD</span>, &amp;win);<br>...<br><span class="hljs-built_in">MPI_Win_free</span>(&amp;win);<br></code></pre></td></tr></table></figure><p>所以在这里我们定义一个MPI结构变量win。然后我们通过动态分配或类似的方法定义一些数据或存储。利用这个缓冲区，我们实际上创建了窗口。所以在MPI_Win_create中，你可以看到我们想分享这个shared_buffer缓冲区。这里的大小是NUM_ELEMENTS。因为每个数据类型都是int，所以位移变成了，比方说可能是4字节宽。信息参数通常为NULL，通信器一如既往地是MPI_COMM_WORLD。一旦这个被调用，这个共享缓冲区就可以通过调用MPI_Put和MPI_Get例程被所有进程共享。当然，在应用程序结束时，我们要释放win窗口。</p><h4 id="MPI-Put-and-MPI-Get"><a href="#MPI-Put-and-MPI-Get" class="headerlink" title="MPI_Put and MPI_Get"></a><code>MPI_Put</code> and <code>MPI_Get</code></h4><p>为了访问这些数据，我们需要前面谈到的两个例程，即MPI_Put和MPI_Get。MPI_Put操作相当于起源进程的发送和目标进程的匹配接收。让我们来看看这些函数的原型，它们有相当多的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Put (<span class="hljs-type">void</span> *origin_addr, <span class="hljs-type">int</span> origin_count, MPI_Datatype origin_datatype, <span class="hljs-type">int</span> target_rank, MPI_Aint target_disp, <span class="hljs-type">int</span> target_count, MPI_Datatype_target_datatype, MPI_Win win)<br></code></pre></td></tr></table></figure><p>以同样的方式，MPI_Get与put操作类似，只是数据从目标内存转移到了源进程。这个函数的原型看起来像这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Get (<span class="hljs-type">void</span> *origin_addr, <span class="hljs-type">int</span> origin_count, MPI_Datatype origin_datatype, <span class="hljs-type">int</span> target_rank, MPI_Aint target_disp, <span class="hljs-type">int</span> target_count, MPI_Datatype_target_datatype, MPI_Win win);<br></code></pre></td></tr></table></figure><p>我们将在下面的练习中深入了解这些函数的参数。但在这之前，我们需要讨论的另一件重要事情是同步。如果你还记得，我们在第二周学习OpenMP的概念时简要地讨论了这个概念。在MPI的单边通信中，目标进程调用函数来创建窗口，以便将其内存访问权交给其他进程。然而，在有多个用户的情况下，如果这些用户试图同时访问这些数据，就会导致一些问题，这一点已经非常明显。例如，假设有两个用户使用MPI_Put函数访问窗口来放置数据。这显然是一个需要避免的竞赛条件。这就是同步化发挥作用的地方。因此，为了避免在每个单边通信函数，即MPI_Get和MPI_Put之前和之后出现这种情况，我们需要使用函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Win_fence (<span class="hljs-number">0</span>, MPI_Win win);<br></code></pre></td></tr></table></figure><p>这个函数实际上帮助我们同步数据，如果多个进程想访问同一个窗口，它将确保它们按顺序进行。因此，程序将允许不同的进程访问该窗口，但它将确保它不会同时发生。因此，重要的是，单边函数调用被这个栅栏函数所包围。</p><h3 id="五、One-sided-communication-in-a-ring"><a href="#五、One-sided-communication-in-a-ring" class="headerlink" title="五、One-sided communication in a ring"></a>五、One-sided communication in a ring</h3><p>你已经熟悉了环状通信。在这个练习中，目标是用单边通信代替非阻塞通信。</p><p>我们想通过使用MPI_Put或MPI_Get来替代对发送和接收例程的调用。所以我们有两个选择。</p><ol><li>之前调用send的进程，现在调用MPI_Put。发送缓冲区是一个本地缓冲区，接收缓冲区必须是一个窗口。</li><li>之前调用接收的进程，现在调用MPI_Get。发送缓冲区是一个窗口，接收缓冲区是一个本地缓冲区。</li></ol><p>在这个练习中，你将使用1.选项。所以你需要做的是为接收缓冲区创建一个窗口，并通过在先前调用MPI_Send的进程中调用MPI_Put来替代发送和接收。同时不要忘记用MPI_Win_fence进行同步。</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>进入练习，填写骨架，在其进程中创建所有rcv_buf作为窗口。</p><p>用Win_fence&#x2F;Put&#x2F;Win_fence序列代替Isend&#x2F;Irecv&#x2F;Wait。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file ring.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> rank, size;<br>    <span class="hljs-type">int</span> snd_buf, rcv_buf;<br>    <span class="hljs-type">int</span> right, left;<br>    <span class="hljs-type">int</span> sum, i;<br><br>    MPI_Win win;<br><br>    MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br>    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);<br><br>    right = (rank+<span class="hljs-number">1</span>)      % size;<br>    left  = (rank<span class="hljs-number">-1</span>+size) % size;<br><br>    <span class="hljs-comment">/* Create the window. */</span><br>    MPI_Win_create(&amp;rcv_buf, (MPI_Aint) <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>), <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>), MPI_INFO_NULL, MPI_COMM_WORLD, &amp;win);<br><br>    sum = <span class="hljs-number">0</span>;<br>    snd_buf = rank;<br><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size; i++) <br>    &#123;<br>        MPI_Win_fence(MPI_MODE_NOSTORE | MPI_MODE_NOPRECEDE, win);<br>        MPI_Put(&amp;snd_buf, <span class="hljs-number">1</span>, MPI_INT, right, (MPI_Aint) <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, MPI_INT, win);<br>        MPI_Win_fence(MPI_MODE_NOSTORE | MPI_MODE_NOPUT | MPI_MODE_NOSUCCEED, win);<br><br>        snd_buf = rcv_buf;<br>        sum += rcv_buf;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PE%i:\tSum = %i\n&quot;</span>, rank, sum);<br><br>    MPI_Win_free(&amp;win);<br><br>    MPI_Finalize();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="六、Quiz：Do-you-understand-advanced-communication-in-MPI"><a href="#六、Quiz：Do-you-understand-advanced-communication-in-MPI" class="headerlink" title="六、Quiz：Do you understand advanced communication in MPI?"></a>六、Quiz：Do you understand advanced communication in MPI?</h3><ul><li><strong>在调用MPI_Win_create时，用什么单位来定义窗口的大小？</strong></li></ul><p>​字节✅</p><p>​由MPI_Datatype参数指定的单位❌</p><p>​字节❌</p><ul><li><p>从MPI_Put调用返回后，立即覆盖包含发送数据的缓冲区是安全的。</p><p>真❌</p><p>错✅</p></li></ul><h2 id="第二节、MPI-OpenMP"><a href="#第二节、MPI-OpenMP" class="headerlink" title="第二节、MPI + OpenMP"></a>第二节、MPI + OpenMP</h2><h3 id="一、MPI-threading-methods"><a href="#一、MPI-threading-methods" class="headerlink" title="一、MPI + threading methods"></a>一、MPI + threading methods</h3><p>在本小节中，我们将在前两周对OpenMP进行介绍的基础上，看看如何将其纳入MPI。我们需要讨论这个问题的原因有很多，但最重要的是在高性能计算（HPC）中，计算机系统具有分层的硬件设计。因此，我们需要讨论如何有效地协调通过网络连接的多核节点的工作。我们还将看到每种方法的瓶颈所在。</p><p>在这个小节中，我们还将<strong>讨论或试图找出混合代码是否比MPI代码表现更好，并看看它与通信优势是否结果线程开销等有什么关系。</strong>最后，我们也会问自己，MPI方法是否是最好的方法，是否有其他的方法可以提供不同的速度或在节点内更有效的分层。我们将看到其他方法如何提供工作负载平衡，当我们处理在许多核心上运行的大型程序时，这种平衡就变得可操作了。为了了解我们将需要多少努力，确保所有的CPU都以最大的效率（100%）被利用，也就是说，没有睡眠的处理器，或睡眠的GPU，或睡眠的线程是可用的，这样所有的东西都被利用了。这将为我们提供机会，探索是否有一些其他可能的方法来更容易地解决这些问题，并以更有效的方式完成工作，例如使用一些其他语言等。</p><p>这是我们对并行编程的介绍，也就是说，我们只是在简单的MPI加线程方法的基础上进行学习。</p><p>为了举例说明，让我们将IBM Power8处理器与英特尔或AMD，即经典的x64架构进行比较。<strong>我们看到，Power8处理器每个核心有更多的线程。因此，与我们在笔记本电脑上发现的通常的超线程不同，我们通常在核心之外还有一个线程；在Power8处理器上，例如在一个插座上有八个处理核心，那么我们可以在每个核心上运行额外的八个线程，这样它们就可以共享高速缓存。</strong>如果我们运行的是OpenMP程序，用许多线程运行会提高性能。这意味着程序和线程共享变量、内存等。希望在我们最初的OpenMP课程中，在前两周的课程中，要做到这一点是非常简单的。</p><h4 id="MPI-OpenMP"><a href="#MPI-OpenMP" class="headerlink" title="MPI + OpenMP"></a>MPI + OpenMP</h4><p>我们可以尝试的两个主要线程范式是。</p><ul><li>MPI + OpenMP</li><li>MPI + MPI-3 shared memory</li></ul><p><strong>MPI+OpenMP对于非均匀内存架构来说通常是一种更好的方法，而且在我们有许多套接字的情况下，也就是缓存一致的非均匀内存。可以通过这样的方式进行优化，即我们只利用少量的MPI线程，其余的是OpenMP。</strong>像往常一样，先决条件是库必须对C来说是线程安全的，这并不复杂，因为C本身利用了很多内部变量，这些变量是在计算附近分配的，所以堆栈或附近的堆。在上一周，我们已经介绍了MPI，我们已经看到MPI有很多不同的消息传递程序。所以，MPI的方法是提供从简单到扩展的所有通信手段。OpenMP，或者说它的线程模型，是和MPI-2一起引入的，这样我们就可以在MPI-2中使用一些线程。从该库中，我们通常使用OpenMPI，但也有一些其他厂商特定的MPI库，特别是如果你从知名厂商那里购买的话。有一些经过调整的MPI库在你购买的集群上工作得最好，这意味着它考虑到了拓扑结构、延迟和MPI库本身的所有架构差异。</p><p>因此，在C语言中，有三个库是我们最初可以查询的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MPI_Init_thread</span> <span class="hljs-params">(<span class="hljs-type">int</span> * argc, <span class="hljs-type">char</span> ** argv[], <span class="hljs-type">int</span> thread_level_required,</span><br><span class="hljs-params">                    <span class="hljs-type">int</span> * thread_level_provided)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">MPI_Query_thread</span> <span class="hljs-params">(<span class="hljs-type">int</span> * thread_level_provided)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">MPI_Is_main_thread</span> <span class="hljs-params">(<span class="hljs-type">int</span> * flag)</span>;<br></code></pre></td></tr></table></figure><p>然而，在这之前，我们需要某些值，以提及我们可以从中获得的线程类型，或者说是线程的级别。因此，所需的值是，例如。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">MPI_THREAD_SINGLE</span><br></code></pre></td></tr></table></figure><ul><li>这里只有一个线程将执行MPI调用。</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">MPI_THREAD_FUNNELED</span><br></code></pre></td></tr></table></figure><ul><li>这里只有主线程会进行MPI调用。</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">MPI_THREAD_SERIALIZED</span><br></code></pre></td></tr></table></figure><ul><li>在这种情况下，多个线程可以进行MPI调用，但一次只能调用一个。</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">MPI_THREAD_MULTIPLE</span><br></code></pre></td></tr></table></figure><ul><li>这里多个线程可以调用MPI，没有任何限制。</li></ul><h3 id="二、Calculate-Pi-Using-MPI-THREAD-FUNNELED"><a href="#二、Calculate-Pi-Using-MPI-THREAD-FUNNELED" class="headerlink" title="二、Calculate Pi! Using MPI_THREAD_FUNNELED"></a>二、Calculate Pi! Using MPI_THREAD_FUNNELED</h3><p>使用线程的最安全和最简单的方法是使用MPI_THREAD_FUNNELED。这个级别的线程安全保证了多线程，但是只有主线程进行MPI调用（调用MPI_Init_thread的那个）。所有的MPI调用都是由主线程进行的，在OpenMP并行区域外或OpenMP主区域内。</p><p>本例笔记本显示了如何通过解决这个积分近似来计算Pi的值。</p><img src="/MPI/Introduction-to-Parallel-Programming/MPI%20Continued/image-20221210173514927.png" alt="image-20221210173514927" style="zoom:50%;"><p>在前几周，你已经用OpenMP和MPI进行了计算。我们将在这个例子中使用这两种方法。我们的目标是尽量少用MPI进行节点间的通信，在节点内部用OpenMP的共享内存计算来完成一切。完整的代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000000</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-type">int</span> rank;<br>  <span class="hljs-type">int</span> size;<br>  <span class="hljs-type">int</span> provided;<br>  <span class="hljs-type">double</span> subsum = <span class="hljs-number">0.0</span>;<br><br>  MPI_Init_thread(&amp;argc, &amp;argv, MPI_THREAD_FUNNELED, &amp;provided);<br>  MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br>  MPI_Comm_size(MPI_COMM_WORLD, &amp;size);<br>  <span class="hljs-type">int</span> nthreads = <span class="hljs-number">2</span>;<br>  omp_set_num_threads(nthreads);<br>  <br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>  &#123;  <br>    <span class="hljs-type">int</span> tid = omp_get_thread_num();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread %d within rank %d started.\n&quot;</span>, tid, rank);<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for reduction(+:subsum)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = rank; i &lt; N; i += size*nthreads)<br>      &#123;<br>        <span class="hljs-type">double</span> x = (i+<span class="hljs-number">0.5</span>)/N;<br>        subsum += <span class="hljs-number">4</span>/(<span class="hljs-number">1</span> + x*x);<br>      &#125;<br>  &#125;<br>  <span class="hljs-type">double</span> sum;<br>  MPI_Reduce(&amp;subsum, &amp;sum, <span class="hljs-number">1</span>, MPI_DOUBLE, MPI_SUM, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br>  <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>)<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pi = %.10lf\n&quot;</span>, sum*nthreads/N);<br>  MPI_Finalize();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们有线程时，考虑如何分割工作负载是很重要的。你可以通过下面这行看到工作负载是如何分割的，所以我们遵循MPI要求的相同原则。如果我们有n个线程，那么我们需要增加跳到下一个块的大小*nthreads的值。每个分块都是这样计算的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = rank; i &lt; N; i += size*nthreads)<br></code></pre></td></tr></table></figure><p>subsum的收集，实际上是线程中的一个共享变量，对每个MPI进程来说，开始时是0.0，从每个线程的一个等级中收集，所以我们在OpenMP并行区域的最后得到每个MPI进程的subsum。之后，主线程将这个子和与MPI一起减少为总和。</p><p>我们在3个进程上编译并运行这个程序，通过在代码内设置2个线程，我们在3个等级（等级0、1和2）内总共有6个线程。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">mpicc -fopenmp pi-hybrid.c <span class="hljs-variable">&amp;&amp;</span> mpirun -n 3 --allow-run-<span class="hljs-keyword">as</span>-root a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>请看一下代码，并在本文末尾的笔记本中运行它。</p><h4 id="该练习的学习成果"><a href="#该练习的学习成果" class="headerlink" title="该练习的学习成果"></a>该练习的学习成果</h4><p>这个程序是以线程方法的第一种方式（MPI+OpenMP）完成的。</p><ul><li>我们刚才在笔记本例子中做的这种并行化方式很适合大多数OpenMP模型。</li><li>昂贵的循环是用OpenMP并行化的，这样做更快。你可以利用许多处理器的内核，所以线程的数量翻倍，而不是内核。所以，以这种方式运行程序肯定有一定的潜力。</li><li>循环之间的通信和MPI调用。</li><li>消除了对真正的 “线程安全 “MPI的需求。</li><li>并行扩展效率可能被MPI_THREAD_FUNNELED方法所限制（Amdahl’s law）。</li><li>迁移到MPI_THREAD_MULTIPLE确实需要付出性能代价（和编程挑战）。</li></ul><h3 id="三、Hybrid-MPI"><a href="#三、Hybrid-MPI" class="headerlink" title="三、Hybrid MPI"></a>三、Hybrid MPI</h3><p>混合MPI+OpenMP的Masteronly风格</p><p>我们在前面的练习中看到，扩展效率可能受到阿姆达尔定律的限制。当然，这意味着，即使所有的计算实际上都被并行化了，我们仍然可能有大块的串行代码存在。例如，串行代码就是前面例子中#pragma omp for reduction之后的代码。所以，还原子句是串行部分的代码，尽管它利用了并行线程。但这是最后一条命令，下面的MPI_Reduce实际上是集体通信，我们已经学过了。</p><p>如果我们在循环中做这样的事情，我们肯定会得到一定量的串行代码，这意味着我们无论如何都会受到阿姆达尔定律的限制。这直接意味着我们无法利用每天在新的和最近的硬件上涌现出来的丰富的数千个或更多的内核（甚至一百万个）。</p><p>解决这些问题的一个有效办法是重叠。某种区域，我们可以同时做MPI和OpenMP，以克服这些通信问题。这可以通过Hybrid MPI + OpenMP Masteronly Style来实现。使用这种混合方式有相当多的优点，然而，最突出的是：</p><ul><li>SMP节点内部没有信息传递，并且</li><li>不存在拓扑结构问题。</li></ul><p>一个有效的例子来解释其必要性和效率，比如说我们在一个房间里做光线追踪。光线追踪的问题是，我们所描述的体积是相当复杂的。因此，假设我们必须做光线追踪，以及我们从照明等方面看到的反射，我们将需要计算每条光线的参数。这已经是几GB的内存了，如果我们每个节点只有60GB的内存，那么我们解决这个问题就会受到内存的限制。所以，我们不能用许多核心来做大问题，因为MPI中的每个核心实际上都有自己的问题在里面。线程、进程或核心之间不存在问题的共享。我们通常可以通过使用MPI+OpenMP相当容易地解决这个问题。这类问题需要大量的内存，因为它们是复杂的，因为要描述环境等等，所以最好用MPI+OpenMP来解决。</p><h4 id="在OMP-MASTER中调用MPI"><a href="#在OMP-MASTER中调用MPI" class="headerlink" title="在OMP MASTER中调用MPI"></a>在OMP MASTER中调用MPI</h4><p>如果我们想做通信，那么通常最好是做OMP主线程。这可以确保只有一个线程与MPI进行通信。然而，我们仍然需要做一些同步工作。正如我们在前几周学到的关于同步的知识，在并行编程中，有时在处理多个并行运行的线程时，我们要暂停线程的执行，而在同一时间只运行一个线程。同步意味着每当我们做MPI时，所有的线程都需要在某个时刻停下来，做屏障。</p><p>在OpenMP中，MPI是在一个并行区域内调用的，有OMP MASTER。它需要MPI_THREAD_FUNNELED，我们在上一小节看到，这意味着只有主线程会进行MPI调用。然而，我们需要注意的是，OMP MASTER并没有任何的同步性！在OMP MASTER中没有隐含的屏障。在主工作共享结构中没有隐含的屏障。因此，使用OMP BARRIER有必要保证，在MPI调用之前&#x2F;之后，其他线程的数据或缓冲空间是可用的。屏障对于防止数据竞赛是必要的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp barrier</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp master</span><br>&#123;<br>    <span class="hljs-built_in">MPI_Xxx</span>(...);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp barrier</span><br></code></pre></td></tr></table></figure><p>我们可以看到，这意味着所有其他的线程都在睡觉，而额外的屏障意味着必要的缓存刷新！通过下面的练习，我们将看到为什么需要刷新缓存。<br>通过下面的练习，我们将看到为什么屏障是必要的。</p><h4 id="Example-with-MPI-recv"><a href="#Example-with-MPI-recv" class="headerlink" title="Example with MPI_recv"></a>Example with <code>MPI_recv</code></h4><p>在这个例子中，主线程将在OMP MASTER结构中执行一个MPI调用，而其他线程都是空闲的。如图所示，在两个地方可能需要屏障。</p><ul><li>在MPI调用之前，以防MPI调用需要等待其他线程的结果。</li><li>在MPI调用之后，以防其他线程立即需要MPI的结果</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for nowait</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>        a[i] = buf[i];<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp barrier</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp master</span><br>    &#123;<br>        MPI_Recv(buf,....);<br>    &#125; <br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp barrier</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for nowait</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>        c[i] = buf[i];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MPI</category>
      
      <category>Introduction-to-Parallel-Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并行计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode 远程连接服务器</title>
    <link href="/Documentation/ssh/"/>
    <url>/Documentation/ssh/</url>
    
    <content type="html"><![CDATA[<h2 id="一、vscode-远程连接服务器"><a href="#一、vscode-远程连接服务器" class="headerlink" title="一、vscode 远程连接服务器"></a>一、vscode 远程连接服务器</h2><ol><li><p>打开vscode，下载Remote - SSH插件</p></li><li><p>新建ssh config</p><p>eg：ssh <a href="mailto:&#x72;&#x6f;&#x6f;&#x74;&#64;&#120;&#120;&#x78;&#x2e;&#120;&#120;&#x78;&#46;&#x78;&#x78;">&#x72;&#x6f;&#x6f;&#x74;&#64;&#120;&#120;&#x78;&#x2e;&#120;&#120;&#x78;&#46;&#x78;&#x78;</a></p></li></ol><img src="/Documentation/ssh/image-20221209172054293.png" alt="image-20221209172054293" style="zoom:50%;"><ol start="3"><li><p>配置文档</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host <span class="hljs-number">10.21</span>.<span class="hljs-number">249.193</span><br>  HostName <span class="hljs-number">10.21</span>.<span class="hljs-number">249.193</span><br>  <span class="hljs-keyword">User</span> <span class="hljs-title">lxy</span><br>  IdentityFile ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure></li></ol><h2 id="二、免密钥设置"><a href="#二、免密钥设置" class="headerlink" title="二、免密钥设置"></a>二、免密钥设置</h2><ol><li><p>在配置文档中新增</p><p>IdentityFile ~&#x2F;.ssh&#x2F;id_rsa </p></li><li><p>进入服务器 ~&#x2F;.ssh文件夹</p><p>（0）如果没有这个文件夹</p><p>​输入ssh-keygen -t rsa -b 4096，一直回车生成密钥</p><p>（1）将本机密钥~&#x2F;.ssh&#x2F;id_rsa.pub</p><p>​追加写入服务器的~&#x2F;.ssh&#x2F;authorized_keys文件中</p><p>​如果没有authorized_keys文件则自己新建一个</p><p>​    可以使用如下命令自动写入：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">ssh-<span class="hljs-keyword">copy</span><span class="language-bash">-<span class="hljs-built_in">id</span> -i ~/.ssh/id_rsa.pub user@host</span><br></code></pre></td></tr></table></figure><p>​本机：</p><img src="/Documentation/ssh/image-20221209173006620.png" alt="image-20221209173006620" style="zoom:50%;"><p>​服务器：</p><img src="/Documentation/ssh/image-20221209172924092.png" alt="image-20221209172924092" style="zoom:50%;"></li><li><p>修改服务器.ssh文件权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">chmod <span class="hljs-number">700</span> <span class="hljs-regexp">/home/u</span>sername<br><br>chmod <span class="hljs-number">700</span> ~<span class="hljs-regexp">/.ssh/</span><br><br>chmod <span class="hljs-number">600</span> ~<span class="hljs-regexp">/.ssh/</span>authorized_keys<br></code></pre></td></tr></table></figure></li></ol><h2 id="三、本机与服务器文件互传"><a href="#三、本机与服务器文件互传" class="headerlink" title="三、本机与服务器文件互传"></a>三、本机与服务器文件互传</h2><p>本机命令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">scp</span> filePath/failName root<span class="hljs-variable">@xxx</span>.xxx.xx:filePath<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/470592903">将vscode与自己的服务器连接</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Document</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Document</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协程</title>
    <link href="/OS/coroutine/"/>
    <url>/OS/coroutine/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么是协程"><a href="#一、什么是协程" class="headerlink" title="一、什么是协程"></a>一、什么是协程</h2><p>协程是轻量级线程，用户级线程，<strong>协程的切换过程中无需陷入内核</strong>。</p><p>可以将协程理解为一个<strong>特殊的函数</strong>。</p><h3 id="todo：协程与函数区别"><a href="#todo：协程与函数区别" class="headerlink" title="todo：协程与函数区别"></a>todo：协程与函数区别</h3><h2 id="二、协程切换"><a href="#二、协程切换" class="headerlink" title="二、协程切换"></a>二、协程切换</h2><p>进程与线程的切换上下文信息都保存在<strong>内核栈</strong>中，协程的上下文信息存在<strong>用户栈</strong>中</p><!--部分为个人理解，可能存在错误--><p><strong>协程切换</strong></p><p>切换不涉及cpu的切换，将当前协程程的本地数据，程序当前的指针等保存在存在用户栈中。</p><p><strong>线程切换</strong></p><p>当一个cpu从一个线程切换到另一个线程时，cpu需要保存当前线程的本地数据，程序当前的指针等，然后加载下一个等待执行的线程的本地数据，程序指针等。</p><p><strong>进程切换</strong></p><p>比起线程切换，还有需要将数据换入换出。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>一个线程内的协程是串行运行的，共用这个线程占有的cpu核心，协程切换过程中该线程会一直占有这个cpu核心，所以协程间的切换不涉及cpu的切换，可以完全由用户控制，而无需陷入内核。</p><p><strong>比起计算密集型场景，协程更适合IO密集型场景。</strong></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://blog.csdn.net/sanmi8276/article/details/111375619">什么是协程</a></li><li><a href="https://blog.csdn.net/w2009211777/article/details/125514898">总结：协程与线程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU、核心以及与线程之间对应</title>
    <link href="/OS/cpu/"/>
    <url>/OS/cpu/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是CPU"><a href="#什么是CPU" class="headerlink" title="什么是CPU"></a>什么是CPU</h2><h3 id="cpu的组成"><a href="#cpu的组成" class="headerlink" title="cpu的组成"></a>cpu的组成</h3><ul><li>控制单元（管理者）：负责调度运算，包括指令控制器，时序控制器，总线控制器，中断控制器。</li><li>运算单元（执行者）：负责计算，包括 ALU（算术逻辑单元）、FPU（浮点运算处理器）。</li><li>存储单元（寄存器）：负责存储缓存数据，包括通用寄存器，状态寄存器，cache。</li></ul><p>指令太多运算速度过快，会存在寄存器存储空间跟不上的情况。cpu为了和内存速度匹配，在寄存器和内存中间加了三级高速缓存。</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器是cpu中的一块<strong>存储</strong>区域，具有很<strong>快</strong>的读写速度。</p><p>不同的cpu中寄存器的构造、数目不一致。</p><p><img src="/OS/cpu/webp" alt="img"></p><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><!--图源网络，见水印and参考文献1--><img src="/OS/cpu/image-20221206171122439.png" alt="image-20221206171122439" style="zoom:50%;"><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>取指令</li><li>指令译码</li><li>执行指令</li><li>访存取数</li><li>结果写回</li></ol><!--可完善--><h2 id="CPU数，核心数，线程数的关系"><a href="#CPU数，核心数，线程数的关系" class="headerlink" title="CPU数，核心数，线程数的关系"></a>CPU数，核心数，线程数的关系</h2><p><strong>CPU数：</strong>我们用的电脑一般都只有一个cpu。</p><p><strong>CPU核心数（CPU cores）：</strong>一个CPU上可以有多个核心，每个核中都有独立的ALU，FPU，Cache等组件，每个cpu核心有自己的L1缓存，同一个cpu的不同核心共用L2、L3缓存。</p><p><strong>CPU线程数（processor）：</strong>逻辑核心数，与超线程技术有关，一个物理核心可以对应两个逻辑核心。</p><!-- Intel有超线程技术。AMD没有 --><h2 id="超线程技术"><a href="#超线程技术" class="headerlink" title="超线程技术"></a>超线程技术</h2><p>两个线程同时使用一个cpu核心，比如说当一个逻辑处理器在执行浮点运算（使用处理器的浮点运算单元）时，另一个逻辑处理器可以执行加法运算（使用处理器的整数运算单元）。</p><h2 id="线程是如何使用CPU核心的"><a href="#线程是如何使用CPU核心的" class="headerlink" title="线程是如何使用CPU核心的"></a>线程是如何使用CPU核心的</h2><p>单个线程只能运行在一个cpu核心上</p><p>单个cpu核心只能运行一个线程（无超线程技术情况下）</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.elecfans.com/baike/zhujipeijian/cpu/20170526519542.html">cpu的基本结构及其工作原理</a></li><li><a href="https://baijiahao.baidu.com/s?id=1619812694399963397&wfr=spider&for=pc">CPU科普文：5分钟让你看懂CPU的结构和工作原理</a></li><li><a href="https://baijiahao.baidu.com/s?id=1666360319131085422&wfr=spider&for=pc">10分钟看懂CPU构造原理</a></li><li><a href="https://blog.csdn.net/weixin_44124323/article/details/115905701">CPU的组成介绍</a></li><li><a href="https://www.jianshu.com/p/0d2cdf2091c9">cpu寄存器</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Message Passing Interface</title>
    <link href="/MPI/Introduction-to-Parallel-Programming/Message%20Passing%20Interface/"/>
    <url>/MPI/Introduction-to-Parallel-Programming/Message%20Passing%20Interface/</url>
    
    <content type="html"><![CDATA[<h2 id="第一节、Welcome-to-Week-3"><a href="#第一节、Welcome-to-Week-3" class="headerlink" title="第一节、Welcome to Week 3"></a>第一节、Welcome to Week 3</h2><h3 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h3><p>本周介绍的消息传递接口（MPI）将介绍通信器和进程如何通信消息。发送和接收消息可以用于一对一的通信。一对多的广播和分散的消息可以通过减少和收集操作来分发和收集回来。所有这些经常使用的集体操作，都由MPI库提供。我们将通过许多例子和执行来介绍这些MPI功能的差异，你可以进一步探索。</p><h3 id="二、Communicator-in-MPI"><a href="#二、Communicator-in-MPI" class="headerlink" title="二、Communicator in MPI"></a>二、Communicator in MPI</h3><p>首先，我们需要了解MPI中的通信器是什么。当我们启动MPI时，整个环境将所有的进程和参与这个应用程序的内核放在一起，并将它们捆绑在一起，这就是所谓的通信器。通信器就像一个集合，将所有的进程绑定在一起，并证实只有在一个应用程序中在一起的进程才能相互通信。我们最常使用的默认通信器是</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">MPI_COMM_WORLD</span><br></code></pre></td></tr></table></figure><p>已经在头文件中预定义了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">mpi.h<br></code></pre></td></tr></table></figure><img src="/MPI/Introduction-to-Parallel-Programming/Message%20Passing%20Interface/image-20221204105843994.png" alt="image-20221204105843994" style="zoom:50%;"><h4 id="Ranks-and-Size"><a href="#Ranks-and-Size" class="headerlink" title="Ranks and Size"></a>Ranks and Size</h4><p>如前所述，当我们将需要使用一个通信器时，我们经常使用MPI_COMM_WORLD。一旦我们实际初始化MPI环境，所有的进程就会在通信器中。正如我们可以预测的那样，能够区分不同的进程是很好的，这就是行列的作用。<strong>当我们初始化环境时，MPI通信器将为每个进程分配一个数字。这就是所谓的等级。</strong>它是一个数字，从零开始，以大小减一结束。在这个例子中，正如你所看到的，我们已经启动了有七个内核的应用程序，每个内核都有一个等级。因此，在这个应用程序中，我们有不同的进程，它们被赋予从零到六的等级。</p><p>这有助于我们识别和使用一个特定的处理器。例如，如果我们想让2号处理器执行某项任务，我们可以用条件来命令执行任务：如果等级是2。 在下面的小节中，当我们进一步学习在特定处理器之间发送消息时，我们将看到等级是如何有用的。比如说，如果等级等于2，就向等级6发送一个消息，这很有用。这就是我们在MPI中不同进程之间发送和接收消息的方式。</p><p>为了实际得到这些数字，我们在MPI中有两个基本的例程。我们现在知道，当我们初始化MPI环境时，rank是每个处理器被赋予的数字，是你可以识别一个进程的数字。size告诉我们一个通信器中包含的进程数，或者简单地说，我们的应用程序中有多少个进程。例如，当规模为10时，等级从0到9，以此类推。</p><p>There are two basic routines for the <code>rank</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">MPI_Comm_rank(MPI_Comm <span class="hljs-params">comm</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">rank</span>)</span><br></code></pre></td></tr></table></figure><p>and for the <code>size</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">MPI_Comm_size(MPI_Comm <span class="hljs-params">comm</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">size</span>)</span>;<br></code></pre></td></tr></table></figure><img src="/MPI/Introduction-to-Parallel-Programming/Message%20Passing%20Interface/image-20221204110444478.png" alt="image-20221204110444478" style="zoom:50%;"><h3 id="三、Hello-World-2-0"><a href="#三、Hello-World-2-0" class="headerlink" title="三、Hello World 2.0"></a>三、Hello World 2.0</h3><p>在这个练习中，你将用提供的C、Python和Fortran的骨架创建你的第一个MPI程序。</p><p>进入练习，修改 “Hello world “的骨架，以使</p><ol><li>每个进程写出它的等级和MPI_COMM_WORLD的大小</li><li>只有MPI_COMM_WORLD中排名为0的进程才会打印 “hello world”。</li></ol><p>现在用4个进程运行该程序。<br>所有MPI进程的输出有可能按照等级的顺序吗？还是没有机会保证这一点？<br>当你多次运行该程序时，你观察到了什么？在评论中告诉我们你的答案和想法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file hello-world.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> rank, size;<br>    MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br>    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);<br>    <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am process %i out of %i.\n&quot;</span>, rank, size);<br>    MPI_Finalize();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>mpicc hello-world.c -o hello-world &amp;&amp; mpirun -np <span class="hljs-number">4</span> --allow-run-<span class="hljs-keyword">as</span>-root hello-world<br></code></pre></td></tr></table></figure><p>output：（顺序不一致）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">I</span> am process <span class="hljs-number">1</span> out of <span class="hljs-number">4</span>.<br><span class="hljs-attribute">I</span> am process <span class="hljs-number">2</span> out of <span class="hljs-number">4</span>.<br><span class="hljs-attribute">I</span> am process <span class="hljs-number">3</span> out of <span class="hljs-number">4</span>.<br><span class="hljs-attribute">Hello</span> world!<br><span class="hljs-attribute">I</span> am process <span class="hljs-number">0</span> out of <span class="hljs-number">4</span>.<br></code></pre></td></tr></table></figure><h3 id="四、Messages-and-communications"><a href="#四、Messages-and-communications" class="headerlink" title="四、Messages and communications"></a>四、Messages and communications</h3><p>到目前为止，我们已经介绍了MPI，我们使用了一些简单的例程，如等级和大小来区分不同的进程，并实际分配给它们一些数字，我们可以识别并在以后使用。但是到目前为止，我们还没有用这些知识做任何有用的事情，也就是说，我们没有在进程之间发送任何信息。这就是我们需要对MPI中的消息进行了解的地方。</p><p>当我们在开发不同的高级应用程序时，在某些时候我们需要从一个进程到另一个进程交换信息。通常情况下，这些信息可能是一些整数，一些其他的值，甚至是数组等等。这就是使用消息的地方。信息是在子程序之间移动的数据包。因此，如前所述，如果我们把要在进程之间共享的信息打包成一些消息，我们可以通过通信网络发送它们，这样其他进程就可以作为消息接收它们。这就是数据和信息在进程之间共享的方式。当然还有一些重要的信息，为了使消息能够有效地发送和接收，我们总是需要指定。</p><img src="/MPI/Introduction-to-Parallel-Programming/Message%20Passing%20Interface/image-20221204111726590.png" alt="image-20221204111726590" style="zoom:50%;"><p>正如我们在这个例子中所看到的，我们正试图从一个等级为0的进程向等级为2的进程发送一个消息。为了使其发挥作用，我们必须指定一些信息。</p><ul><li><strong>数据大小和类型</strong></li></ul><p>发送者需要指定正在发送的是哪种类型的数据。因此，例如，如果我们要发送一个数组，让我们说100个数字，我们需要指定其大小等于100。正如你可能已经猜到的，我们还需要提到数据的类型是什么。那么，它是否是一个字符？是一个双整数吗？等等。</p><ul><li><strong>发送或接收数据的指针</strong></li></ul><p>对于这种数据交换，我们将需要两个指针。这些指针来自于发送方，它将需要指向它自己的内存，以提到，好的，我想发送的数据在这里。然后，接收方将需要指定它想接收这些数据的内存。<br>发送进程和接收进程，即行列<br>MPI环境将需要知道谁是发送方，谁是接收方。这就是等级的作用。因此，对于我们前面的例子，我们将指定等级0是发送方，等级2是接收方。</p><ul><li><strong>信息的标签</strong></li></ul><p>我们需要指定的下一个信息是信息的标签。标签是一个简单的数字，我们可以给它分配任何数值，让接收者可以从中识别信息。例如，如果我们要发送两条信息，我们可以指定一个标签为，比方说0，另一个为标签1。这有助于接收者识别和区分信息。但通常情况下，如果我们只有一条信息，我们可以直接把标签定为0。</p><ul><li><strong>通信器，即MPI_COMM_WORLD</strong></li></ul><p>我们需要指定的最后一个参数是我们要发送消息的通信器是什么。在我们这里，它将是MPI_COMM_WORLD，但随着我们做更多的练习和实际操作，我们最终会更好地了解这些函数。</p><h4 id="MPI数据类型"><a href="#MPI数据类型" class="headerlink" title="MPI数据类型"></a>MPI数据类型</h4><p>MPI环境定义了它自己的基本数据类型。然而，如果你熟悉C语言，它们真的很简单，因为你要做的只是在变量前用大写字母写上MPI，然后把所有东西都改成大写。</p><table><thead><tr><th align="left">C Datatype</th><th align="left">MPI Datatype</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">MPI_CHAR</td></tr><tr><td align="left">int</td><td align="left">MPI_INT</td></tr><tr><td align="left">long</td><td align="left">MPI_LONG</td></tr><tr><td align="left">float</td><td align="left">MPI_FLOAT</td></tr><tr><td align="left">double</td><td align="left">MPI_DOUBLE</td></tr></tbody></table><p>然而，随着我们将更多地接触MPI，我们将探索，还有一种方法可以让用户定义自己的派生数据类型。例如，如果我们在C语言中使用结构，那么我们可以将该结构定义为一个新的MPI数据类型。这被证明是非常有用的，因为我们可以直接在一个消息中发送所有的东西。因此，这就不需要我们用不同的消息来发送结构的部分内容。但我们将在未来几周内深入研究派生数据类型。对于今天的部分，我们只使用简单的数据.类型。</p><h3 id="五、Quiz"><a href="#五、Quiz" class="headerlink" title="五、Quiz"></a>五、Quiz</h3><p><strong>通信器有什么作用？</strong><br>它可以防止你的主程序的MPI调用与库的MPI调用相混淆✅<br>它可以用来识别将参与消息传递的进程的子组✅<br>如果等于MPI_COMM_WORLD，它表明通信涉及所有进程✅<br>以上都是✅</p><p><strong>以下哪项是消息传递调用所不需要的。</strong><br>你的消息的起始内存地址<br>消息的类型<br>消息的大小，以字节数计✅<br>消息中的数据元素的数量</p><p><strong>在消息传递调用中，参数标签是什么意思。</strong><br>传入消息的消息类型<br>通信方式的类型<br>一个用户分配的号码，在发送方和接收方都必须匹配✅<br>进程组的类型</p><h2 id="第二节、Types-of-communication-in-MPI"><a href="#第二节、Types-of-communication-in-MPI" class="headerlink" title="第二节、Types of communication in MPI"></a>第二节、<strong>Types of communication in MPI</strong></h2><h3 id="一、Different-types-of-communication-in-MPI"><a href="#一、Different-types-of-communication-in-MPI" class="headerlink" title="一、Different types of communication in MPI"></a>一、Different types of communication in MPI</h3><p>我们可以通过两个标准来划分MPI中的通信类型。</p><p><strong>定义通信类型的第一个方法是根据所涉及的过程的数量来划分。</strong></p><ul><li>因此，如果只有两个进程参与通信，即只有一个发送方和一个接收方，那么它就被称为点对点通信。这是消息传递的最简单形式，一个进程向另一个进程发送消息。</li><li>这类通信的另一种类型是集体通信，我们有多个进程参与其中。这涉及到一个进程与其他许多进程之间的通信，甚至是许多进程与其他几个进程的通信。因此，这可以有不同的执行方式。这是区分通信类型的一个标准，即通过参与的进程的数量来区分。</li></ul><p><strong>第二个标准，也许是更复杂的标准，是通过将通信类型定义为阻塞型和非阻塞型。</strong></p><ul><li><p>一个阻塞式程序只有在操作完成后才会返回。这意味着阻塞意味着，如果我们发送一个消息，我们不能进行下一步的操作，直到接收方真正向我们返回它已经收到消息的信息。</p><img src="/MPI/Introduction-to-Parallel-Programming/Message%20Passing%20Interface/image-20221204164807103.png" alt="image-20221204164807103" style="zoom:50%;"></li><li><p>非阻塞式通信比简单的阻塞式通信更复杂。在这种情况下，它立即返回并允许子程序执行其他工作。它与阻塞式通信的不同之处在于，如果我们向接收方发送一些东西，我们可以在中间执行一些其他任务，在一段时间后，我们可以检查接收方是否真正返回了信息，即它已经收到了信息，或者一切正常。许多真实的应用通常采用这种类型的通信。</p></li></ul><img src="/MPI/Introduction-to-Parallel-Programming/Message%20Passing%20Interface/image-20221204164824037.png" alt="image-20221204164824037" style="zoom:50%;"><h4 id="Point-to-Point-Communication"><a href="#Point-to-Point-Communication" class="headerlink" title="Point-to-Point Communication"></a>Point-to-Point Communication</h4><p>正如我们在上一节已经看到的，点对点通信是最简单的通信，因为它只涉及两个进程。其中一个进程作为发送方，另一个作为接收方。在这里，源头或发送方通过通信器向接收方发送一个消息。为了做到这一点，环境必须知道谁是发送方，谁是接收方，这一点可以通过指定进程的等级来解决。</p><img src="/MPI/Introduction-to-Parallel-Programming/Message%20Passing%20Interface/image-20221204165627157.png" alt="image-20221204165627157" style="zoom:50%;"><h5 id="Sending-paradigms"><a href="#Sending-paradigms" class="headerlink" title="Sending paradigms"></a>Sending paradigms</h5><p>为了用点对点通信发送一个信息，我们使用函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">MPI_Send(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">buf</span>, <span class="hljs-params">int</span> <span class="hljs-params">count</span>, MPI_Datatype <span class="hljs-params">datatype</span>, <span class="hljs-params">int</span> <span class="hljs-params">dest</span>, <span class="hljs-params">int</span> <span class="hljs-params">tag</span>, MPI_Comm <span class="hljs-params">comm</span>)</span>;<br></code></pre></td></tr></table></figure><p>我们现在来看看这个程序到底需要什么参数。</p><ul><li>buf是数据的指针，有很多元素，每个元素都用数据类型描述。所以首先，我们必须指定我们想发送的数据的地址。这是一个指向发送方数据的指针，然后第二个参数实际上是我们发送的元素的数量。例如，如果我们只发送1个整数，大小将是1。如果你发送一个有100个整数的数组，这将是100，以此类推。这个函数希望得到的第三个参数是数据类型。所以，如果我们要发送一个整数，我们将不得不在这里指定MPI_INT，以此类推。</li><li>dest是目标进程的等级。在这个参数中，我们指定接收方的等级。因此，例如，在前面的例子中，这将是5。</li><li>tag是与消息一起发送的附加整数信息。tag基本上是一个数字，我们通过它来识别消息。所以，通常情况下，如果我们只发送一条消息，我们可以只把0标签放在那里，也可以把任何我们希望的数字放在那里。</li><li>最后一个参数是通信器，正如我们已经讨论过的，我们通常使用MPI_COMM_WORLD。</li><li>这些参数是MPI环境需要的最重要的信息，以便知道发送什么数据以及发送给谁。</li></ul><h5 id="Receiving-paradigms"><a href="#Receiving-paradigms" class="headerlink" title="Receiving paradigms"></a>Receiving paradigms</h5><p>正如我们所看到的，发送方需要一个函数来发送消息，显然，接收方必须调用接收函数。这意味着，为了使通信工作，我们需要两个进程和两个等级。因此，一个将调用MPI_Send函数，另一个将类似地调用MPI_Recv来接收。为了能够接收，我们使用函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">MPI_Recv(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">buf</span>, <span class="hljs-params">int</span> <span class="hljs-params">count</span>, MPI_Datatype <span class="hljs-params">datatype</span>, <span class="hljs-params">int</span> <span class="hljs-params">source</span>, <span class="hljs-params">int</span> <span class="hljs-params">tag</span>, MPI_Comm <span class="hljs-params">comm</span>, MPI_Status <span class="hljs-operator">*</span><span class="hljs-params">status</span>)</span>;<br></code></pre></td></tr></table></figure><p>这个函数需要的参数与MPI_Send函数类似。</p><ul><li>buf&#x2F;count&#x2F;datatype描述了接收的数据。在第一个参数中，我们指定数据的地址，即我们想接收数据的地址，同样，我们把数据类型放在这里。</li><li>source是发送方进程的等级。我们必须要有发送方进程的等级。在前面的例子中，我们会指定数字3，因为数字3的等级正试图向我们发送一个消息。</li><li>与MPI_Send类似，我们这里也有一个标签。确保我们将这个数字与发送方相匹配真的很重要。因此，如果发送方指定消息的标签为0，接收方也必须在这里指定同样的数字。否则，这将是一个无限循环，因为我们将不会收到任何东西，因为我们的接收函数调用与发送函数调用不匹配。</li><li>下一个参数是通信器，我们将再次使用MPI_COMM_WORLD。</li><li>最后一个参数目前对我们来说不是很重要，因为这是我们将在下一个练习中学习的东西。现在我们只使用</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">MPI_STATUS_IGNORE</span><br></code></pre></td></tr></table></figure><img src="/MPI/Introduction-to-Parallel-Programming/Message%20Passing%20Interface/image-20221204203725379.png" alt="image-20221204203725379" style="zoom:50%;"><p>这里，左边是发送方，右边是接收方。我们假设发送方想把这个有n个浮点的缓冲阵列发送给其他进程。为此，它调用MPI_Send常规函数。正如我们已经知道的，第一个是数据的指针。所以，这就是发送缓冲区。然后，它需要指定数据的数量。下一个参数是MPI_FLOAT，我们需要确保这个数据与前面提到的数据一致。正如我们之前讨论的，这是环境定义的MPI数据类型，但它必须与这个数据相匹配，否则通信将无法进行。我们需要记住的另一件事是，这个数据类型必须与接收器相匹配。所以，当我们写这些函数时，我们必须小心，所有这些都必须匹配。现在，接收方必须调用具有相同数据类型的接收方函数。在这里，它必须首先定义一个数组，用来接收这些数据，即接收缓冲区。当然，通信器也必须是相同的，因为它们被绑定在同一个程序中。但我们通常使用MPI_COMM_WORLD通信器。下一个重要的部分是，标签必须匹配。最后，消息的类型或数据的类型必须匹配。</p><h3 id="二、Send-and-receive"><a href="#二、Send-and-receive" class="headerlink" title="二、Send and receive"></a>二、Send and receive</h3><p>在这个练习中，你将编写一个基本的MPI程序，使用MPI_Send和MPI_Recv例程将数字-1从进程0发送至进程1（ping）。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (rank <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>) &#123; ... &#125;<br>else if (rank <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span>) &#123; ... &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file ping.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i, rank;<br>    <span class="hljs-type">float</span> buffer[<span class="hljs-number">1</span>];<br>    MPI_Status status;<br><br>    MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br><br>    <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am %i before send ping \n&quot;</span>, rank);<br>      MPI_Send(buffer, <span class="hljs-number">1</span>, MPI_FLOAT, <span class="hljs-number">1</span>, <span class="hljs-number">17</span>, MPI_COMM_WORLD);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">1</span>)<br>    &#123;<br>      MPI_Recv(buffer, <span class="hljs-number">1</span>, MPI_FLOAT, <span class="hljs-number">0</span>, <span class="hljs-number">17</span>, MPI_COMM_WORLD, &amp;status);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am %i after  recv ping \n&quot;</span>, rank);<br>    &#125;<br><br>    MPI_Finalize();<br>&#125;<br><br>output:<br>I am <span class="hljs-number">0</span> before send ping <br>I am <span class="hljs-number">1</span> after  recv ping <br></code></pre></td></tr></table></figure><h3 id="三、Ping-pong"><a href="#三、Ping-pong" class="headerlink" title="三、Ping pong"></a>三、Ping pong</h3><p>在这个练习中，你将得到使用MPI_Send和MPI_Recv程序的练习。<br>这是上一个练习的继续，当时我们从进程0向进程1发送一个平移。现在你将发送和接收多个消息。</p><p>练习</p><ol><li>两个进程来回乒乓一个令牌，不断递增直到达到一个给定的值。</li><li>进程0向进程1发送一个消息（ping）。</li><li>在收到这个消息后，进程1又向进程0发送了一个消息（pong）。</li><li>每发送一条消息，令牌就会递增1。</li><li>重复这个ping pong，直到token的值达到6，即3个ping和3个pong。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file ping.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i, rank;<br>    <span class="hljs-type">float</span> token[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">10</span>&#125;;<br>    MPI_Status status;<br><br>    MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br>      <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-keyword">while</span> (token[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">6</span>) &#123;<br>          <br>          token[<span class="hljs-number">0</span>]--;<br>          MPI_Send(token, <span class="hljs-number">1</span>, MPI_FLOAT, <span class="hljs-number">1</span>, <span class="hljs-number">17</span>, MPI_COMM_WORLD);<br>          MPI_Recv(token, <span class="hljs-number">1</span>, MPI_FLOAT, <span class="hljs-number">1</span>, <span class="hljs-number">22</span>, MPI_COMM_WORLD, &amp;status);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am %i after recv pong %f\n&quot;</span>, rank, token[<span class="hljs-number">0</span>]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">1</span>)<br>    &#123;<br>      <span class="hljs-keyword">while</span> (token[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">6</span>) &#123;<br>          MPI_Recv(token, <span class="hljs-number">1</span>, MPI_FLOAT, <span class="hljs-number">0</span>, <span class="hljs-number">17</span>, MPI_COMM_WORLD, &amp;status);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am %i after recv ping %f\n&quot;</span>, rank, token[<span class="hljs-number">0</span>]);<br><br>          token[<span class="hljs-number">0</span>]--;<br>          MPI_Send(token, <span class="hljs-number">1</span>, MPI_FLOAT, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, MPI_COMM_WORLD);<br>      &#125;<br>    &#125;<br><br><br>    MPI_Finalize();<br>&#125;<br><br>output:<br>I am <span class="hljs-number">0</span> after recv pong <span class="hljs-number">8.000000</span><br>I am <span class="hljs-number">0</span> after recv pong <span class="hljs-number">6.000000</span><br>I am <span class="hljs-number">1</span> after recv ping <span class="hljs-number">9.000000</span><br>I am <span class="hljs-number">1</span> after recv ping <span class="hljs-number">7.000000</span><br></code></pre></td></tr></table></figure><h3 id="四、What-happens-with-a-different-number-of-pings-and-pongs-🤔️"><a href="#四、What-happens-with-a-different-number-of-pings-and-pongs-🤔️" class="headerlink" title="四、What happens with a different number of pings and pongs ?🤔️"></a>四、What happens with a different number of pings and pongs ?🤔️</h3><p>上一步的程序对不同数量的ping和pongs，即3个ping和2个pongs，是否有效？</p><h3 id="五、Rotating-information-around-a-ring"><a href="#五、Rotating-information-around-a-ring" class="headerlink" title="五、Rotating information around a ring"></a>五、Rotating information around a ring</h3><p>在这个练习中，你将尝试使用阻塞式和非阻塞式通信。通过使用非阻塞通信，我们要避免闲置时间、死锁和序列化。这是两部分练习的第一部分。</p><p>这是一个环形通信的小例子，它是一种具有循环边界条件的晕轮通信。每个进程都在向其右边的邻居发送其数据，并从其左边的邻居那里接收数据（在一个环中）。如果我们使用阻塞式例程，就会有死锁和串行化的风险。所有进程都可能被卡在MPI_Send，因为它们在等待MPI_Recv的调用。</p><p>你从提供的源代码开始，这是错误的，因为它以一种天真的方式使用MPI_Send和MPI_Recv。如果MPI_Send是用同步通信协议实现的，那么这个程序就会出现死锁。但是我们期望这个错误的程序能够工作，因为我们只发送一个小的1整数信息而不是巨大的双精度数组。下面的程序在一个循环中以进程迭代的方式发送环形的等级值，并将所有的数值相加（所有等级之和）。邻居等级的计算是通过modulo运算完成的。我们使用2个不同的缓冲区进行发送和接收，这通常是在我们进行非阻塞通信时使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> rank, size;<br>    <span class="hljs-type">int</span> snd_buf, rcv_buf;<br>    <span class="hljs-type">int</span> right, left;<br>    <span class="hljs-type">int</span> sum, i;<br>    MPI_Status status;<br><br>    MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br>    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);<br><br>    right = (rank+<span class="hljs-number">1</span>)      % size;<br>    left  = (rank<span class="hljs-number">-1</span>+size) % size;<br><br>    sum = <span class="hljs-number">0</span>;<br>    snd_buf = rank; <span class="hljs-comment">//store rank value in send buffer</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size; i++) <br>    &#123;<br>        MPI_Send(&amp;snd_buf, <span class="hljs-number">1</span>, MPI_INT, right, <span class="hljs-number">17</span>, MPI_COMM_WORLD); <span class="hljs-comment">//send data to the right neighbour</span><br>        MPI_Recv(&amp;rcv_buf, <span class="hljs-number">1</span>, MPI_INT, left,  <span class="hljs-number">17</span>, MPI_COMM_WORLD, &amp;status); <span class="hljs-comment">//receive data from the left neighbour</span><br>        snd_buf = rcv_buf; <span class="hljs-comment">//prepare send buffer for next iteration</span><br>        sum += rcv_buf; <span class="hljs-comment">//sum of all received values</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;PE%i:\tSum = %i\n&quot;</span>, rank, sum);<br><br>    MPI_Finalize();<br>&#125;<br></code></pre></td></tr></table></figure><p>练习</p><ul><li>进入练习，用进程3、4、5运行并检查正确的和。</li><li>然后用MPI_Send (explicit synchronous send) 代替MPI_Send。运行该程序。你将看到一个死锁，你将需要杀死程序（用中断按钮◼）。</li><li>用序列化来解决死锁问题。使用技巧：例如，如果等级&#x3D;&#x3D; ，则先做接收，然后再发送。用3、4、5个进程运行程序，看看你是否解决了死锁问题。现在用1个进程运行该程序。它仍然会出现死锁。由于性能不好，该程序仍然是错误的，当只用1个进程运行时，它仍然会死锁。</li><li>为什么我们用一个有2个不同缓冲区的程序而不是1个缓冲区的序列化方案？</li><li>为什么序列化的方案在运行1个进程时仍然会死锁？</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file ring.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> rank, size;<br>    <span class="hljs-type">int</span> snd_buf, rcv_buf;<br>    <span class="hljs-type">int</span> right, left;<br>    <span class="hljs-type">int</span> sum, i;<br>    MPI_Status status;<br><br>    MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br>    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);<br><br>    right = (rank+<span class="hljs-number">1</span>)      % size;<br>    left  = (rank<span class="hljs-number">-1</span>+size) % size;<br><br>    sum = <span class="hljs-number">0</span>;<br>    snd_buf = rank;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size; i++) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>) &#123;<br>            MPI_Ssend(&amp;snd_buf, <span class="hljs-number">1</span>, MPI_INT, right, <span class="hljs-number">17</span>, MPI_COMM_WORLD);<br>            MPI_Recv(&amp;rcv_buf, <span class="hljs-number">1</span>, MPI_INT, left,  <span class="hljs-number">17</span>, MPI_COMM_WORLD, &amp;status);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            MPI_Recv(&amp;rcv_buf, <span class="hljs-number">1</span>, MPI_INT, left,  <span class="hljs-number">17</span>, MPI_COMM_WORLD, &amp;status);<br>            MPI_Ssend(&amp;snd_buf, <span class="hljs-number">1</span>, MPI_INT, right, <span class="hljs-number">17</span>, MPI_COMM_WORLD);<br>        &#125;<br>        snd_buf = rcv_buf;<br>        sum += rcv_buf;<br>    &#125;<br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;PE%i:\tSum = %i\n&quot;</span>, rank, sum);<br><br>    MPI_Finalize();<br>&#125;<br><br>output：<br>PE0:Sum = <span class="hljs-number">3</span><br>PE1:Sum = <span class="hljs-number">3</span><br>PE2:Sum = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="六、Dynamic-Receiving-with-MPI-PROBE-and-MPI-STATUS"><a href="#六、Dynamic-Receiving-with-MPI-PROBE-and-MPI-STATUS" class="headerlink" title="六、Dynamic Receiving with MPI PROBE and MPI STATUS"></a>六、Dynamic Receiving with MPI PROBE and MPI STATUS</h3><p>在前面的练习中，我们实现了沿环形线发送数组的程序。这是一个应用的例子，我们已经知道我们将使用一个有100个值的数组。我们已经知道它有多长，或者换句话说，这个信息有多大，有多少元素被实际发送等等。这很重要，因为如果我们回过头来看发送和接收例程，我们需要指定这个计数。所以，不知道这些数字已经占了一个问题。在本小节中，我们将了解到有两种方法来处理这种情况，也就是说，如果不知道消息的大小。</p><ul><li>第一种方法是将数据的大小作为一个单独的发送&#x2F;回传操作来发送。因此，我们会用MPI_Send发送一个单独的消息，在这里我们可以发送例如一个数组中的元素数量，而我们稍后会将其发送出去。这样做是可行的，但有时效率并不高。</li><li>第二种也是更有效的方法是我们将在本小节中借助两个函数来学习的。我们将通过使用MPI_Probe和MPI_Status来获得发送数据的大小来解决这个问题。</li></ul><p>为了更多地了解这些函数以及如何使用它们，我们需要掌握以下一些概念。</p><h4 id="Wildcards"><a href="#Wildcards" class="headerlink" title="Wildcards"></a>Wildcards</h4><p>到目前为止，当我们在调用MPI_Send和MPI_Recv函数时，我们一直在指定一些信息。在这些情况下，接收器可以在其中一些参数中使用通配符。这意味着在函数中</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">MPI_Recv(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">buf</span>, <span class="hljs-params">int</span> <span class="hljs-params">count</span>, MPI_Datatype <span class="hljs-params">datatype</span>, <span class="hljs-params">int</span> <span class="hljs-params">source</span>,<span class="hljs-params">int</span> <span class="hljs-params">tag</span>, MPI_Comm <span class="hljs-params">comm</span>, MPI_Status <span class="hljs-operator">*</span><span class="hljs-params">status</span>)</span>;<br></code></pre></td></tr></table></figure><p>接收者可以直接把源头作为</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">MPI_ANY_SOURCE</span><br></code></pre></td></tr></table></figure><p>这意味着它不关心消息从哪里来，允许从任何来源接收。例如，如果你们都给我发了一条信息，而我只想阅读其中一条信息，我就会使用这个。所以，我不会关心谁给我发的信息，我只是从其中一个来源阅读它。同样地，我们也可以对标签这样做。在我们必须提及标签号码的函数中，我们可以直接使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">MPI_ANY_TAG</span><br></code></pre></td></tr></table></figure><p>允许我们接收具有任何标签的信息。</p><h4 id="MPI-Status-and-MPI-Probe"><a href="#MPI-Status-and-MPI-Probe" class="headerlink" title="MPI_Status and MPI_Probe"></a><code>MPI_Status</code> and <code>MPI_Probe</code></h4><p>MPI_Status是一个包含重要信息的结构，如以下信息。</p><ul><li>The rank of the sender as</li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">status</span>.MPI_SOURCE<br></code></pre></td></tr></table></figure><ul><li>The tag of the message as</li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">status</span>.MPI_TAG<br></code></pre></td></tr></table></figure><ul><li>The length of the message with</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">MPI_Get_count(MPI_Status <span class="hljs-operator">*</span><span class="hljs-params">status</span>, MPI_Datatype <span class="hljs-params">datatype</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">count</span>)</span><br></code></pre></td></tr></table></figure><p>所以，这个Status结构有一些属性，可以为我们提供关于发送方的额外信息。例如，就像我们看到的那样，如果我们使用MPI_ANY_SOURCE或MPI_ANY_TAG，那么在这种情况下，Status是我们能够找出发件人究竟是谁的唯一方法。所以，使用前两者我们可以得到谁是发件人和消息的标签的信息。在后面的练习中我们还将看到，我们可以使用Status结构来调用MPI_Get_count函数，该函数实际上给我们提供了消息的大小。因此，如果我们不知道有多少个数字，或者不知道消息会有多大，我们可以使用MPI_Get_count函数来推断出消息的尺寸是多少。我们很快就会在一个例子中看到这个方法的作用。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">MPI_Probe(<span class="hljs-params">int</span> <span class="hljs-params">source</span>, <span class="hljs-params">int</span> <span class="hljs-params">tag</span>, MPI_Comm <span class="hljs-params">comm</span>, MPI_Status<span class="hljs-operator">*</span> <span class="hljs-params">status</span>)</span>;<br></code></pre></td></tr></table></figure><p>它可以被认为是一个MPI_Recv，除了接收消息，它做了所有的事情，但我们可以从中得到很多信息。一旦我们有了这些信息，我们就可以实际使用MPI_Recv来接收实际的消息。<br>我们可以通过下面的可选练习更好地理解这些函数。</p><h2 id="第三节、Collective-communications"><a href="#第三节、Collective-communications" class="headerlink" title="第三节、Collective communications"></a>第三节、<strong>Collective communications</strong></h2><h3 id="一、Basic-collective-communications"><a href="#一、Basic-collective-communications" class="headerlink" title="一、Basic collective communications"></a>一、Basic collective communications</h3><p>到目前为止，我们学习的所有不同的方法和练习实际上只涉及点对点的通信，即两个过程之间的通信。现在我们将介绍一些更高级的通信，其中涉及到更多的进程。我们必须记住，在这些涉及一组进程的通信中，例程被一个通信器中的所有进程调用。所以，简单地说，参与这种通信的所有进程都需要调用同一个例程。</p><p>Examples of these types of communication are</p><ul><li>Broadcast</li><li>Scatter</li><li>Gather</li><li>Reduction</li></ul><h4 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h4><p>广播是所有集体通信形式中最简单的一种，它被用来向所有进程发送用户输入或参数。广播的基本思想是，我们选择一个进程向通信器中的所有其他进程发送相同的数据。通常我们在算法的开始阶段使用广播，在这种情况下，我们想分配用户输入或算法的一些参数。例如，如果我们不使用并行IO（输入-输出），通常的情况是，我们用一个处理器读取一个文件，然后用广播分配内容。<br>为了执行这个，我们将使用函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">MPI_Bcast(<span class="hljs-params">void</span><span class="hljs-operator">*</span> <span class="hljs-params">data</span>, <span class="hljs-params">int</span> <span class="hljs-params">count</span>, MPI_Datatype <span class="hljs-params">datatype</span>, <span class="hljs-params">int</span> <span class="hljs-params">root</span>, MPI_Comm <span class="hljs-params">communicator</span>)</span>;<br></code></pre></td></tr></table></figure><p>与我们到目前为止所学的大多数函数类似，在广播函数的参数中，我们想指定数据，所以我们想分享的数据的指针。同样，我们指定有多少个数据，以及它的类型是什么。然而，我们将注意到的一个有趣的区别是，这里没有发送方源和接收方。但实际上这个根告诉我们的是，在这里我们指定分配数据的进程的等级。所有不是根的其他进程都会收到消息。虽然根进程和接收进程做的是不同的工作，但它们都调用了同一个MPI_Bcast函数! 我们将通过一个例子更好地理解它。在参数的最后，我们必须指定通信器。</p><p>例如，假设我们已经用五个处理器初始化了MPI应用程序，这意味着等级0到4。现在我们想让等级1发送一个字符串，一个包含字母r-e-d的字符数组给所有其他进程。如前所述，为了使其发挥作用，等级1以及我们希望参与这一通信的所有其他进程都必须调用同一个函数和这个函数的原型。</p><img src="/MPI/Introduction-to-Parallel-Programming/Message%20Passing%20Interface/image-20221204215929294.png" alt="image-20221204215929294" style="zoom:50%;"><p>所以，这里假设红色被包含在名为buf的数组中。有三个元素我们想在所有其他进程中分配。它们的数据类型是字符，所以我们使用MPI_CHAR。root是1，所以发送或广播数据的进程有等级1，其次是通信器MPI_COMM_WORLD。因此，上面的图片的函数将是</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">MPI_Bcast</span>(buf, <span class="hljs-number">3</span>, <span class="hljs-built_in">MPI_CHAR</span>, <span class="hljs-number">1</span>, <span class="hljs-built_in">MPI_COMM_WORLD</span>);<br></code></pre></td></tr></table></figure><p>我们可以看到，这是一个相当简单但非常有用的程序。请记住，这个确切的函数调用必须由每个参与的进程调用，根和所有的接收进程。</p><h3 id="二、Broadcast"><a href="#二、Broadcast" class="headerlink" title="二、Broadcast"></a>二、Broadcast</h3><p>在这个练习中，你将得到使用MPI_Bcast和编写你自己的广播函数。你将比较MPI和你的函数的时间效率。</p><p>练习</p><ol><li><p>进入练习，完成使用MPI_Bcast例程从等级为0的进程中广播一个有10.000.000个数字的阵列的程序。</p></li><li><p>使用MPI_Send和MPI_Recv例程编写你自己的广播函数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void my<span class="hljs-constructor">_Bcast(<span class="hljs-params">void</span><span class="hljs-operator">*</span> <span class="hljs-params">data</span>, <span class="hljs-params">int</span> <span class="hljs-params">count</span>, MPI_Datatype <span class="hljs-params">datatype</span>, <span class="hljs-params">int</span> <span class="hljs-params">root</span>, MPI_Comm <span class="hljs-params">communicator</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>使用MPI函数MPI_Wtime测量两个例程在2、4、8个处理器上运行时的时间。你对不同规模下的差异有什么看法？</p></li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">MPI_Wtime</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file bcast.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">my_Bcast</span><span class="hljs-params">(<span class="hljs-type">void</span>* data, <span class="hljs-type">int</span> count, MPI_Datatype datatype, <span class="hljs-type">int</span> root, MPI_Comm communicator)</span> <br>&#123;<br>    <span class="hljs-type">int</span> rank, size, i;<br>    MPI_Comm_rank(communicator, &amp;rank);<br>    MPI_Comm_size(communicator, &amp;size);<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>    <span class="hljs-comment">// If we are the root process, send our data to everyone</span><br>    <span class="hljs-comment">// If we are a receiver process, receive the data from the root</span><br>    <span class="hljs-keyword">if</span>(rank == root)&#123;<br>        <span class="hljs-comment">// send</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i != root)&#123;<br>                MPI_Send(data, count,datatype, i ,<span class="hljs-number">0</span>, communicator);<br>            &#125;<br>        &#125;<br>        <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        MPI_Recv(data, count, datatype, root,<span class="hljs-number">0</span> ,communicator, MPI_STATUS_IGNORE );<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> rank, i;<br>    <span class="hljs-type">int</span> num_elements = <span class="hljs-number">10000000</span>; <span class="hljs-comment">// size of array</span><br>    <span class="hljs-type">int</span> num_trials = <span class="hljs-number">10</span>; <span class="hljs-comment">// number of timing experiments</span><br><br>    MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br><br>    <span class="hljs-type">double</span> total_my_bcast_time = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-type">double</span> total_mpi_bcast_time = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-type">int</span>* data = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * num_elements); <span class="hljs-comment">// create array</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_trials; i++) &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>        <span class="hljs-comment">// broadcast with MPI_Bcast</span><br>        <span class="hljs-comment">// time MPI_Bcast</span><br>        <span class="hljs-comment">// synchronize before starting timing and before obtaining final time</span><br>        MPI_Barrier(MPI_COMM_WORLD);<br>        total_mpi_bcast_time -= MPI_Wtime();<br>        MPI_Bcast(data, num_elements, MPI_INT, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br><br>        MPI_Barrier(MPI_COMM_WORLD);<br>        total_mpi_bcast_time += MPI_Wtime();<br><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>        <span class="hljs-comment">// broadcast with my_Bcast</span><br>        <span class="hljs-comment">// time my_Bcast</span><br>        MPI_Barrier(MPI_COMM_WORLD);<br>        total_my_bcast_time -= MPI_Wtime();<br>        my_Bcast(data, num_elements, MPI_INT, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br>        MPI_Barrier(MPI_COMM_WORLD);<br>        total_my_bcast_time += MPI_Wtime();<br><br>    &#125;<br><br>    <span class="hljs-comment">// Print resulting times</span><br>    <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Avg my_Bcast time = %lf\n&quot;</span>, total_my_bcast_time / num_trials);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Avg MPI_Bcast time = %lf\n&quot;</span>, total_mpi_bcast_time / num_trials);<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(data);<br>    MPI_Finalize();<br>&#125;<br><br>output:(n = <span class="hljs-number">4</span>)<br>Avg my_Bcast time = <span class="hljs-number">0.017896</span><br>Avg MPI_Bcast time = <span class="hljs-number">0.022628</span><br></code></pre></td></tr></table></figure><p>自定义的反而要快？❌？</p><p>只要我们有&gt;2个进程，MPI_Bcast的执行时间就比my_Bcast的执行时间小，而且它的扩展性更好。<br>n &#x3D; [2, 4, 6, 8, 12, 16] # 进程<br>t1 &#x3D; [1.9e-2, 5.6e-2, 0.11, 0.13, 0.18, 0.22] # MPI_Bcast<br>t2 &#x3D; [1.1e-2, 8.9e-2, 0.19, 0.40, 0.84, 1.51] # my_Bcast</p><p>![img](Message Passing Interface&#x2F;hero_db3fb5e7-3d36-475e-af4d-44fa31d69607.png)</p><h3 id="四、Scatter-and-Gather"><a href="#四、Scatter-and-Gather" class="headerlink" title="四、Scatter and Gather"></a>四、Scatter and Gather</h3><h4 id="散射"><a href="#散射" class="headerlink" title="散射"></a>散射</h4><p>函数的原型：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">MPI_Scatter</span> (<span class="hljs-type">void</span> *sendbuf, <span class="hljs-type">int</span> sendcount, <span class="hljs-built_in">MPI_Datatype</span> sendtype, <span class="hljs-type">void</span> *recvbuf, <span class="hljs-type">int</span> recvcount, <span class="hljs-built_in">MPI_Dataype</span> recvtype, <span class="hljs-type">int</span> root, <span class="hljs-built_in">MPI_Comm</span> comm)<br></code></pre></td></tr></table></figure><p>函数原型与广播类似，但我们将通过参数，因为有些部分我们需要小心处理。像往常一样，首先我们要指定数据，所以这就是缓冲区。在这个例子中，根处理器将是等级为1的那个，它想把这个由5个数字组成的数组分散到所有其他进程中。为了能够做到这一点，它将需要指定这个sendbuf。在这之后是数字<strong>sendcount</strong>，稍后我们会看到recvcount。通常情况下，它们是一样的。这实际上是一个数字，<strong>它告诉你有多少元素将被发送到每个进程</strong>，重要的是要注意，它并不意味着总共有多少元素被发送，而只是每个进程将得到的那一部分。下一个参数是recvbuf，它是将接收数据的进程的缓冲区。最后，root与广播中的参数相同。它是实际进行散布的进程，而comm表示进程所在的通信器。在这个函数中，我们唯一需要注意的是sendcount和recvcount，因为这是决定将向每个进程发送多少个元素的数字，而不是整个元素的数量。另一个需要注意的是，当这个函数完成后，发送方（在我们的例子中，等级为1的进程）将不会得到整个数据的信息。在我们的例子中，这将意味着在通信后，等级1将只拥有一部分数据，即B。</p><img src="/MPI/Introduction-to-Parallel-Programming/Message%20Passing%20Interface/image-20221208170337715.png" alt="image-20221208170337715" style="zoom:50%;"><p>MPI_Bcast和MPI_Scatter之间的区别是，MPI_Bcast向所有进程发送相同的数据，而MPI_Scatter则向不同的进程发送大块的数据。</p><h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><p>正如我们将看到的，许多MPI应用的基本思想是，我们有一些数据，我们分散它，使每个进程计算一些东西，然后我们在一个进程中收集回信息。该函数与MPI_Scatter非常相似</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">MPI_Gather(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">sendbuf</span>, <span class="hljs-params">int</span> <span class="hljs-params">sendcount</span>, MPI_Datatype <span class="hljs-params">sendtype</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">recvbuf</span>, <span class="hljs-params">int</span> <span class="hljs-params">recvcount</span>, MPI_Dataype <span class="hljs-params">recvtype</span>, <span class="hljs-params">int</span> <span class="hljs-params">root</span>, MPI_Comm <span class="hljs-params">comm</span>)</span><br></code></pre></td></tr></table></figure><p>这里的主要区别是，由于只有一个进程，即根进程，收集所有的信息，它是唯一需要有一个有效的接收缓冲区的进程。所有其他的调用进程可以为recvbuf传递NULL，因为他们不接收任何东西，因为他们只是将数据发送到根进程。最后，再次要注意和记住的是，<strong>recvcount参数是每个进程收到的元素的数量，而不是所有进程的总和</strong></p><img src="/MPI/Introduction-to-Parallel-Programming/Message%20Passing%20Interface/image-20221208170844247.png" alt="image-20221208170844247" style="zoom:50%;"><h3 id="五、Scatter-and-Gather"><a href="#五、Scatter-and-Gather" class="headerlink" title="五、Scatter and Gather"></a>五、Scatter and Gather</h3><p>在这个练习中，你将编写一个MPI程序，使用MPI_Scatter和MPI_Gather计算一个数组元素的平均值。<br>这个相当简单的程序演示了如何使用MPI在不同的进程中进行分工，对数据的子集进行计算，然后将较小的结果合并到最终结果中。<br>该程序采取了以下步骤。</p><ol><li>根进程（进程0）创建一个生成随机数的数组。</li><li>将根进程的随机数分散到所有其他进程，给每个进程同等数量的数字。</li><li>每个进程计算其数字子集的平均值。</li><li>根进程收集每个单独的平均数，并在现在更小的数字数组上计算出总的平均数。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file gather.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i, rank, size;<br>    <span class="hljs-type">int</span> num_elements_per_proc = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> num_elements;<br>    <span class="hljs-comment">// seed the random number generator</span><br>    srand(time(<span class="hljs-literal">NULL</span>));<br><br>    MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br>    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);<br><br>    <span class="hljs-comment">// create a random array of elements on the root process</span><br>    <span class="hljs-comment">// total size will be the number of elements per process times the number of processes</span><br>    <span class="hljs-type">float</span> *rand_nums = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>) &#123;<br>        num_elements = num_elements_per_proc * size;<br>        rand_nums = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) * num_elements);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_elements; i++) &#123;<br>            rand_nums[i] = (rand() / (<span class="hljs-type">float</span>)RAND_MAX);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// for each process, create a buffer that will hold a subset of the array</span><br>    <span class="hljs-type">float</span> *sub_rand_nums = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) * num_elements_per_proc);<br><br>    <span class="hljs-comment">// scatter the random numbers from the root process to all other processes</span><br>    MPI_Scatter(rand_nums, num_elements_per_proc, MPI_FLOAT, sub_rand_nums,<br>              num_elements_per_proc, MPI_FLOAT, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br><br>    <span class="hljs-comment">// compute the average of your subset</span><br>    <span class="hljs-type">float</span> sub_avg = <span class="hljs-number">0.f</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_elements_per_proc; i++) &#123;<br>        sub_avg += sub_rand_nums[i];<br>    &#125;<br>    sub_avg = sub_avg / num_elements_per_proc;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am process %i out of %i, average result = %f \n&quot;</span>, rank, size, sub_avg);<br><br>    <span class="hljs-comment">// gather all partial averages down to the root process</span><br>    <span class="hljs-type">float</span> *sub_avgs = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// memory allocation needed only on root process</span><br>        sub_avgs = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) * size);<br>    &#125;<br>    MPI_Gather(&amp;sub_avg, <span class="hljs-number">1</span>, MPI_FLOAT, sub_avgs, <span class="hljs-number">1</span>, MPI_FLOAT, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br><br>    <span class="hljs-comment">// compute the total average of all numbers from the partial averages</span><br>    <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> avg = <span class="hljs-number">0.f</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            avg += sub_avgs[i];<br>        &#125;<br>        avg = avg / size;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Avg of all elements is %f\n&quot;</span>, avg);<br><br>        <span class="hljs-comment">// compute average across the original data for comparison</span><br>        <span class="hljs-type">float</span> original_data_avg = <span class="hljs-number">0.f</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_elements; i++) &#123;<br>            original_data_avg += rand_nums[i];<br>        &#125;<br>        original_data_avg = original_data_avg / num_elements;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Avg computed across original data is %f\n&quot;</span>, original_data_avg);<br><br>    &#125;<br><br>    <span class="hljs-comment">// Clean up</span><br>    <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">free</span>(rand_nums);<br>        <span class="hljs-built_in">free</span>(sub_avgs);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(sub_rand_nums);<br><br>    MPI_Finalize();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第四节、Advanced-Collective-operations"><a href="#第四节、Advanced-Collective-operations" class="headerlink" title="第四节、Advanced Collective operations"></a>第四节、<strong>Advanced Collective operations</strong></h2><h3 id="一、MPI-Reduce"><a href="#一、MPI-Reduce" class="headerlink" title="一、MPI_Reduce"></a>一、MPI_Reduce</h3><p>到目前为止，在基本的集体通信中，我们已经遇到了广播、散射和聚集。现在，我们可以转向更高级的集体通信，我们将讨论MPI_Reduce和MPI_Allreduce例程。<br>在我们进入这些例程之前，让我们在实践中修订一下<em>reduce</em>或data reduction的概念。简单地说，data reduction就是通过一些函数将一组数字缩减为一个更小的数字集。例如，假设我们有一个数字列表（1，2，3，4，5）。那么用sum函数还原这个数字列表就会产生。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) = <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>同样地，如果我们使用另一个函数，比如说乘法，那么乘法减法将产生</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">multiply</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) = <span class="hljs-number">120</span>.<br></code></pre></td></tr></table></figure><p>很简单，这就是MPI reduction函数的作用。</p><h4 id="MPI-Reduce"><a href="#MPI-Reduce" class="headerlink" title="MPI_Reduce"></a><code>MPI_Reduce</code></h4><p> MPI_Reduce基本上就是我们在上一个练习中所做的，并增加了一个功能。在某种程度上，reduce例程所做的事情基本上与分散&#x2F;聚集类似，但我们也指定了一个MPI函数，如sum、multiplication、maximum或类似的东西。我们将在后面看到，哪些函数是可用的，以及我们如何使用它们。因此，MPI库在这些数据上直接使用这些函数，立即给我们减少的结果。我们不需要调用收集程序，然后手动编程来获得总和，而是由库来为我们完成。因此，MPI_Reduce在每个进程上接收一个输入元素的数组，并向根进程返回一个输出元素的数组。输出元素包含减去的结果。</p><p>也许通过一个例子会更容易理解。</p><p>![MPI_Reduce](Message Passing Interface&#x2F;hero_ffcb98cd-1789-4c4d-ac99-8026fce723b5.png)</p><p>让我们假设我们要计算一个总和，但不同的数字分散在不同的进程中。如果我们会有我们的数字（1，2，3，4，5），我们会在这些数据上调用MPI_Reduce，我们还需要提到我们想Reduce数据的函数，比如说，和。然后根进程将得到总和作为结果。为了能够做到这一点，我们需要MPI_Reduce的原型</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">MPI_Reduce(<span class="hljs-params">void</span><span class="hljs-operator">*</span> <span class="hljs-params">send_data</span>, <span class="hljs-params">void</span><span class="hljs-operator">*</span> <span class="hljs-params">recv_data</span>, <span class="hljs-params">int</span> <span class="hljs-params">count</span>, MPI_Datatype <span class="hljs-params">datatype</span>, MPI_Op <span class="hljs-params">op</span>, <span class="hljs-params">int</span> <span class="hljs-params">root</span>, MPI_Comm <span class="hljs-params">communicator</span>)</span>;<br></code></pre></td></tr></table></figure><p>这个例程的参数与我们到目前为止看到的参数非常相似。所以，send_data参数是一个每个进程想要减少的元素的数组。接下来是recv_data，它只对等级为root的进程有意义，因为它包含了减少的结果。然后我们提到计数，即数据的数目或数量和数据类型。然而，这就是MPI_Reduce函数的不同之处。这里我们还在op参数中提到了操作，即我们希望应用于数据的操作。MPI库中的还原操作列表如下。</p><table><thead><tr><th align="left">Function</th><th align="left"><code>MPI_Op</code></th></tr></thead><tbody><tr><td align="left">Maximum</td><td align="left"><code>MPI_MAX</code></td></tr><tr><td align="left">Minimum</td><td align="left"><code>MPI_MIN</code></td></tr><tr><td align="left">Sum</td><td align="left"><code>MPI_SUM</code></td></tr><tr><td align="left">Product</td><td align="left"><code>MPI_PROD</code></td></tr><tr><td align="left">Logical AND</td><td align="left"><code>MPI_LAND</code></td></tr><tr><td align="left">Logical OR</td><td align="left"><code>MPI_LOR</code></td></tr></tbody></table><h3 id="二、Computing-average-with-MPI-Reduce"><a href="#二、Computing-average-with-MPI-Reduce" class="headerlink" title="二、Computing average with MPI_Reduce"></a>二、Computing average with MPI_Reduce</h3><p>在这个练习中，你将编写一个MPI程序，使用MPI_Reduce计算一个数组元素的平均值。<br>在上一课中，你用MPI_Scatter和MPI_Gather计算了平均数。使用MPI_Reduce使代码简化了很多。<br>该程序采取了以下步骤。</p><ol><li>每个进程创建一个生成随机数的数组。</li><li>每个进程执行local_sum计算。</li><li>使用MPI_SUM将local_sum减少到根进程（进程0）。</li><li>根进程计算最后的平均值。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file reduce.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i, rank, size;<br>    <span class="hljs-type">int</span> num_elements_per_proc = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> num_elements;<br>    <span class="hljs-comment">// seed the random number generator to get different results for each processor</span><br>    srand(time(<span class="hljs-literal">NULL</span>)*rank);<br><br>    MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br>    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);<br><br>    <span class="hljs-comment">// create a random array of elements on all processes</span><br>    <span class="hljs-type">float</span> *rand_nums = <span class="hljs-literal">NULL</span>;<br>    rand_nums = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) * num_elements_per_proc);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_elements_per_proc; i++) &#123;<br>        rand_nums[i] = (rand() / (<span class="hljs-type">float</span>)RAND_MAX);<br>    &#125;<br><br>    <span class="hljs-comment">// sum the numbers locally</span><br>    <span class="hljs-type">float</span> local_sum = <span class="hljs-number">0.f</span>;<br>    <span class="hljs-comment">// TODO</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_elements_per_proc; i++) &#123;<br>        local_sum += rand_nums[i];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Local sum for process %d : %f, avg = %f\n&quot;</span>,<br>             rank, local_sum, local_sum / num_elements_per_proc);<br><br><br>    <span class="hljs-comment">// reduce all of the local sums into the global sum on root process</span><br>    <span class="hljs-type">float</span> global_sum;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> reduce</span><br>        MPI_Reduce(&amp;local_sum, &amp;global_sum, <span class="hljs-number">1</span>, MPI_FLOAT, MPI_SUM, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br><br>    <span class="hljs-comment">// print the result</span><br>    <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// TODO</span><br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Total sum = %f, avg = %f\n&quot;</span>, global_sum,<br>            global_sum / (size * num_elements_per_proc));<br>        <br>    &#125;<br><br>    <span class="hljs-comment">// clean up</span><br>    <span class="hljs-built_in">free</span>(rand_nums);<br><br>    MPI_Finalize();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、MPI-Allreduce"><a href="#四、MPI-Allreduce" class="headerlink" title="四、MPI_Allreduce"></a>四、MPI_Allreduce</h3><p>在我们之前学习的MPI_Reduce函数中，其思路是其中一个处理器将从不同的处理器中获取数据，使用一些MPI操作将它们组合起来，使用这个操作来减少数据并获得结果。MPI_Allreduce以一种奇特的方式从MPI_Reduce中脱颖而出：在Allreduce中，所有的进程都会得到这个结果。简单地说，我们在减少数据的同时，以某种方式广播结果。当然，我们自己也可以做到这一点，但是MPI_Allreduce库做到了这一点，不仅速度更快，而且对我们来说也更容易。<br>许多并行应用需要在所有进程中访问减少的结果，而不是只访问根进程。这就是MPI_Allreduce最常用的地方，因为它可以减少数值并将结果分配给所有进程。简单地说，Allreduce基本上是减少和广播函数的结合。MPI_Allreduce的原型与MPI_Reduce非常相似，它看起来像</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">MPI_Allreduce(<span class="hljs-params">void</span><span class="hljs-operator">*</span> <span class="hljs-params">send_data</span>, <span class="hljs-params">void</span><span class="hljs-operator">*</span> <span class="hljs-params">recv_data</span>, <span class="hljs-params">int</span> <span class="hljs-params">count</span>, MPI_Datatype <span class="hljs-params">datatype</span>, MPI_Op <span class="hljs-params">op</span>, MPI_Comm <span class="hljs-params">communicator</span>)</span>;<br></code></pre></td></tr></table></figure><p>然而，一个主要的区别是，这里的参数中没有根，因为所有的进程都会得到数据。其他的东西都是差不多的。我们有两个用于发送和接收数据的指针。我们有每个处理器发送的元素的数量，后面是数据类型。然后类似于reduce函数，我们有我们想用来减少数据的MPI操作，当然最后还有通信器。<br>由于我们已经熟悉了reduce函数，通过下面的练习，我们将更容易了解Allreduce。</p>]]></content>
    
    
    <categories>
      
      <category>MPI</category>
      
      <category>Introduction-to-Parallel-Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并行计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机中负数的存储</title>
    <link href="/Algorithm/Storage%20of%20negative%20numbers/"/>
    <url>/Algorithm/Storage%20of%20negative%20numbers/</url>
    
    <content type="html"><![CDATA[<h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><p>在计算机中，存储一个数的时候，都是以补码的形式存储的。</p><p><strong>反码再加一（符号位不变）</strong></p><p>如short x &#x3D; -2;</p><p>原码：1000 0000 0000 0010</p><p>反码：1111 1111 1111 1101</p><p>补码：1111 1111 1111 1110</p><p>-2+4 &#x3D; 2</p><p>1111 1111 1111 1110</p><p>0000 0000 0000 0100</p><p>&#x3D; &#x3D;》</p><p>0000 0000 0000 0010</p><p>ps：前面的都进位了</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/elegantandhh/article/details/124749552">计算机中负数的存储</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用二进制表示double</title>
    <link href="/Algorithm/Double%20to%20Binary%20Number/"/>
    <url>/Algorithm/Double%20to%20Binary%20Number/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>无论是单精度还是双精度在存储中都分为三个部分：</p><ol><li>符号位(Sign) : 0代表正，1代表为负</li><li>指数位（Exponent）:用于存储科学计数法中的指数数据，并且采用移位存储</li><li>尾数部分（Mantissa）：尾数部分</li></ol><img src="/Algorithm/Double%20to%20Binary%20Number/image-20221130093354952.png" alt="image-20221130093354952" style="zoom:50%;"><h2 id="取法"><a href="#取法" class="headerlink" title="取法"></a>取法</h2><p>eg：2.625</p><p><strong>1. 小数部分二进制表示：</strong>取小数部分乘二再取结果整数部分，直至重复or为0</p><p>​0.625 —— start</p><p>​0.625 —— 1.250 —— 1</p><p>​0.250 —— 0.500 —— 0</p><p>​0.500 —— 1.000 —— 1</p><p>​0 —— end</p><p><strong>2. 整数部分取二进制</strong></p><p>​2 —— 10</p><p><strong>3. 组合，转换成科学计数法</strong></p><p>​10.101 —— 1.0101 * (2 ^1)</p><p> <strong>4. 在计算机中表示</strong></p><p>​<strong>符号位：0</strong> </p><p>（表示正数）</p><p>​<strong>指数位：10000000000</strong></p><p>​底数为1，加上1023，取1024，<strong>原因：指数也有正负，将指数位平分可以取到（-1023～+1024）</strong></p><p>​<strong>尾数：010100000…</strong></p><p>​因为尾数都是1开头，所以尾数位的第一个1不用存只需要存0101部分</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://leetcode.cn/problems/bianry-number-to-string-lcci/?favorite=xb9lfcwi">面试题 05.02. 二进制数转字符串</a></p><p>二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。</p><p><strong>示例1:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-number">0.625</span><br>输出：<span class="hljs-string">&quot;0.101&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-number">0.1</span><br>输出：<span class="hljs-string">&quot;ERROR&quot;</span><br>提示：<span class="hljs-number">0.1</span>无法被二进制准确表示<br></code></pre></td></tr></table></figure><p><strong>解答</strong></p><p>效率低，但是没用内部的double</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>       <span class="hljs-keyword">public</span> String <span class="hljs-title function_">printBin</span><span class="hljs-params">(<span class="hljs-type">double</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0.0&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> String.valueOf(num);<br>        <span class="hljs-comment">// System.out.println(st);</span><br>        HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;0.&quot;</span>);<br>        set.add(st.toString());<br>        <span class="hljs-keyword">while</span>(!st.equals(<span class="hljs-string">&quot;0&quot;</span>))&#123;<br>            <span class="hljs-comment">// 乘二</span><br>            st = doub(st.toString());<br>            <span class="hljs-comment">// num *= 2;</span><br><br>            s.append(st.charAt(<span class="hljs-number">0</span>));<br>            <span class="hljs-comment">// System.out.println(s.toString());</span><br><br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(st);<br>            tmp.replace(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;0&quot;</span>);<br><br>            st = tmp.toString();<br>            <span class="hljs-keyword">if</span>(set.contains(st))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ERROR&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(check(st))&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            set.add(st);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.toString();<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(String st)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; st.length(); i++) &#123;<br>            <span class="hljs-type">char</span> c= st.charAt(i);<br>            <span class="hljs-keyword">if</span> (st.charAt(i) != <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; st.charAt(i) != <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">doub</span><span class="hljs-params">(String st)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> st.length();<br>        <span class="hljs-type">char</span>[] chars = st.toCharArray();<br>        <span class="hljs-comment">// 先乘再进位</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">2</span> ; i--) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> chars[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> (x - <span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-number">2</span>;<br>            chars[i] = toChar(now);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">2</span> ; i--) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> chars[i];<br>            <span class="hljs-keyword">if</span>( x &gt; <span class="hljs-string">&#x27;9&#x27;</span>)  &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span> == <span class="hljs-number">1</span>? <span class="hljs-number">0</span>:i-<span class="hljs-number">1</span>;<br>                chars[index] = (<span class="hljs-type">char</span>) (chars[index] + <span class="hljs-number">1</span>);<br>                chars[i] = (<span class="hljs-type">char</span>)(x - <span class="hljs-number">10</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> String.valueOf(chars);<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> <span class="hljs-title function_">toChar</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">char</span>)(c + <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.cnblogs.com/ClassNotFoundException/p/6198805.html">float浮点数的二进制存储方式及转换</a></li><li><a href="https://blog.csdn.net/K__Ming/article/details/106062892">float与double在内存中的储存及范围，精度</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP</title>
    <link href="/MPI/Introduction-to-Parallel-Programming/OpenMP/"/>
    <url>/MPI/Introduction-to-Parallel-Programming/OpenMP/</url>
    
    <content type="html"><![CDATA[<h1 id="第二周、OpenMP"><a href="#第二周、OpenMP" class="headerlink" title="第二周、OpenMP"></a>第二周、OpenMP</h1><h2 id="第一节、Getting-started-with-OpenMP"><a href="#第一节、Getting-started-with-OpenMP" class="headerlink" title="第一节、Getting started with OpenMP"></a>第一节、Getting started with OpenMP</h2><h3 id="一、Welcome-to-Week-2"><a href="#一、Welcome-to-Week-2" class="headerlink" title="一、Welcome to Week 2"></a>一、Welcome to Week 2</h3><p>OpenMP是一个共享内存的线程编程模型，可以用来逐步升级现有的代码以实现并行执行。升级后的代码仍然可以进行串行编译。这是OpenMP的一个很大的特点，它让你有机会检查并行执行是否提供了与串行版本相同的结果。为了更好地理解自动并行化，我们首先要看一下运行时函数。在简单的OpenMP程序中通常不需要这些函数。我们将介绍一些基本的编译器或pragma指令和变量的范围，以了解对内存的线程访问逻辑。</p><p>工作共享指令和线程的同步将在几个例子中讨论。如何从线程中收集结果，将用常见的减少条款来说明。在本周结束时，我们将介绍有趣的基于任务的并行化方法。不要忘了用练习来做实验，因为这些是你主要的学习机会。让我们开始吧。 本周的结构受到了HLRS OpenMP课程的启发（礼尚往来。Rolf Rabenseifner（HLRS））。</p><h3 id="二、Runtime-functions"><a href="#二、Runtime-functions" class="headerlink" title="二、Runtime functions"></a>二、Runtime functions</h3><p>运行时函数（Runtime functions）的目的是管理或修改我们想在代码中使用的并行进程。它们随OpenMP库而来。</p><p>对于C++和C，你可以添加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> &lt;omp.h</span><br></code></pre></td></tr></table></figure><p>头文件到你的代码的开头，然后这个库包括所有你需要的和你想使用的标准运行时函数。我们今天将在教程中使用的函数可以从成绩单中的链接或资源中获取。</p><ul><li>要设置所需的线程数，使用</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_set_num_threads</span><span class="hljs-params">(n)</span></span><br></code></pre></td></tr></table></figure><p>例如，如果你想用12个线程来并行化你的程序，你可以用函数指定程序中的线程数，比如说</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_set_num_threads</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span><br></code></pre></td></tr></table></figure><ul><li>要返回当前的线程数，请使用</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_get_num_threads</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><ul><li>要返回这个线程的ID，使用</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_get_thread_num</span><span class="hljs-params">()</span></span> <br></code></pre></td></tr></table></figure><ul><li>To return <code>true</code> if inside parallel region, use</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_in_parallel</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>如果它被指定在一个平行区域内，该函数返回true。如果不是，也就是说，如果它被指定在串行区域内，它将返回false。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>Let’s observe the following example.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">omp_set_num_threads</span>(num_threads);<br>    <span class="hljs-type">int</span> rank;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>    &#123;<br>        rank = <span class="hljs-built_in">omp_get_thread_num</span>();<br>        <span class="hljs-type">int</span> nr_threads = <span class="hljs-built_in">omp_get_num_threads</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am thread %i of %i threads\n&quot;</span>,<br>        rank,<br>        nr_threads);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>花点时间，试着理解上面的代码中发生了什么。</p><ul><li><p>预期的输出是什么？rank和nr_threads的值是多少？</p><p>I am thread 0 of 4 threads</p><p>I am thread 1 of 4 threads</p><p>I am thread 2 of 4 threads</p><p>I am thread 3 of 4 threads</p></li><li><p>输出总是一样的吗？线程的打印顺序是什么？</p><p>不一样，打印顺序应该随机</p></li><li><p>如果我们把线程的数量改为12，会发生什么？</p><p>会打印十二次</p><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221127203248794.png" alt="image-20221127203248794"></p></li></ul><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>使用私有变量设置线程数</p><h3 id="三、Variables-and-constructs"><a href="#三、Variables-and-constructs" class="headerlink" title="三、Variables and constructs"></a>三、Variables and constructs</h3><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>接下来我们要看的是环境变量。与运行时函数相反，环境变量不是在代码中使用的，而是在环境中指定的，在那里你正在编译和运行你的代码。环境变量的目的是为了在运行时控制并行程序的执行。由于这些变量不是在代码中指定的，你可以在编译和运行你的程序之前，例如在Linux终端指定它们。让我们来看看三个最常见的环境变量：</p><ul><li><p><strong>指定要使用的线程数</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">OMP_NUM_THREADS</span>=4<br></code></pre></td></tr></table></figure></li><li><p><strong>指定线程应该放在哪个CPU上，可以使用</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">OMP_PLACES</span> <br></code></pre></td></tr></table></figure></li><li><p><strong>要显示OpenMP的版本和环境，使用</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">OMP_DISPLAY_ENV</span>  <br></code></pre></td></tr></table></figure><h4 id="Parallel-constructs"><a href="#Parallel-constructs" class="headerlink" title="Parallel constructs"></a>Parallel constructs</h4><p>并行结构是使用OpenMP时的基本结构。所以，每个线程基本上都同时执行平行区域内的相同语句，正如你在这张图片上看到的。</p><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221128153335944.png" alt="image-20221128153335944"></p><p>所以，首先我们有一个主线程，执行代码的串行部分。然后我们来到了一个pragma omp语句。我们在这里可以看到，主线程首先遇到了这个omp结构，并创建了多个线程，也就是我们所说的并行运行的从线程。随后，主线程和从线程在彼此之间划分了任务。最后，我们指定了一个隐含的障碍，所以当达到这个障碍时，线程结束，我们等待所有线程完成执行。在这之后，当所有的线程都完成了执行，我们回到主线程，最终恢复代码的执行。当然，在这一步骤中，从属线程已经消失了，因为它们已经完成了自己的任务。</p><p>在C语言中，这个隐含的屏障被指定为</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>&#123;<br>...<br> &#125;<br></code></pre></td></tr></table></figure><p>Let’s observe the following code.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>  <span class="hljs-built_in">omp_set_num_threads</span>(num_threads);<br>  <span class="hljs-type">int</span> rank;<br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>  &#123;<br>  rank = <span class="hljs-built_in">omp_get_thread_num</span>();<br>  <span class="hljs-type">int</span> nr_threads = <span class="hljs-built_in">omp_get_num_threads</span>();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am thread %i of %i threads\n&quot;</span>,<br>   rank,<br>   nr_threads);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="四、Clauses-and-directive-format"><a href="#四、Clauses-and-directive-format" class="headerlink" title="四、Clauses and directive format"></a>四、Clauses and directive format</h3><h4 id="Directive-format（指令格式）"><a href="#Directive-format（指令格式）" class="headerlink" title="Directive format（指令格式）"></a>Directive format（指令格式）</h4><p>到目前为止，我们只是指定了一个并行区域，并且代码是以串行方式执行的。现在我们将继续前进，看看OpenMP的指令。使用指令的格式如下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp directive_name [clause[clause]...]</span><br></code></pre></td></tr></table></figure><p>我们已经看到并使用了pragma omp parallel，它是一个并行执行区域的指令。在这种格式中，我们也有一些子句，以指定不同的参数。例如，私有变量是指对每个线程都是私有的变量，而共享变量是指对所有线程共享的变量，任何线程都可以访问和修改它。</p><p>我们将在下面的小节中更多地探讨这些条款。现在，我们将学习一下条件语句。与任何编程语言类似，OpenMP也有条件语句。因此，举例来说，我们也可以在OpenMP中以如下方式指定一个if语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _OPENMP</span><br><span class="hljs-comment">//block of code to be executed if code was compiled with OpenMP, for example</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Number of threads: %d&quot;</span>, omp_get_num_threads);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">//block of code to be executed if code was compiled without OpenMP</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>下面的例子说明了条件编译的使用。通过OpenMP编译，_OPENMP被定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> rank;<br>  <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _OPENMP</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(4) private(rank)</span><br>  &#123;<br>    rank = <span class="hljs-built_in">omp_get_thread_num</span>();<br>    <span class="hljs-type">int</span> nr_threads = <span class="hljs-built_in">omp_get_num_threads</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am thread %i of %i threads\n&quot;</span>,<br>     rank,<br>     nr_threads);<br>  &#125;<br>  <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This program is not compiled with OpenMP\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><blockquote><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ gcc example.c<br>This program is not compiled with OpenMP<br><br>$ gcc -fopenmp example.c<br>I am thread<span class="hljs-number"> 3 </span>of<span class="hljs-number"> 4 </span>threads<br>I am thread<span class="hljs-number"> 2 </span>of<span class="hljs-number"> 4 </span>threads<br>I am thread<span class="hljs-number"> 1 </span>of<span class="hljs-number"> 4 </span>threads<br>I am thread<span class="hljs-number"> 0 </span>of<span class="hljs-number"> 4 </span>threads<br></code></pre></td></tr></table></figure></blockquote></blockquote><h4 id="Clauses（条款）"><a href="#Clauses（条款）" class="headerlink" title="Clauses（条款）"></a>Clauses（条款）</h4><p>我们刚刚学习的指令格式</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp directive_name [clause[clause]...]</span><br></code></pre></td></tr></table></figure><p>是OpenMP的一个重要的关键字，我们把它放在代码的开头，放在我们想让并行区域开始的那一行，然后我们提到指令名称和子句。在本小节中，我们将学习条款。</p><p>基本上有两种条款，即：私有或共享。一个私有变量将是一个对每个线程都是私有的变量。</p><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221128155745412.png" alt="image-20221128155745412"></p><p>So, we execute, e.g.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> A;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(A)</span><br>&#123;<br>    A=<span class="hljs-built_in">omp_get_thread_num</span>();<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们在C代码中定义了一个整数A。然后我们定义了OpenMP指令，omp parallel和private A。因此，这里发生的情况是，任何时候我们都会得到一个新的线程，这个变量A将被单独分配给每个线程。这意味着，A的值将与线程的数量有关。因此，在第一个线程中，它将是0，在第二个线程中，这个变量的值将是1，因为这将是线程的ID，在第三个线程中的值将是2，以此类推。我们可以清楚地看到，这些变量基本上是私有的，这意味着它们存在于每个线程中。这意味着，第一个线程中的变量A（0）不能被第二个线程中的变量A（1）访问。所以，这就推断出这个变量对我们程序中的每个单独的线程来说基本上是私有的。当然，与此相反的是共享变量。如果我们指定一个变量是共享变量，这将标志着该变量将在线程之间共享。如果我们在并行区域之外指定该变量，那么就在</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br></code></pre></td></tr></table></figure><p>这个变量将被每个线程访问。举例来说，如果我们有一个for循环，并且我们在每次迭代中都向它添加一个数字，我们可以直接指定它为一个共享变量。在这种情况下，每当任何线程更新共享变量时，它都会向其中添加数字。这是一种使用for循环的适当方式，我们将在下面的小节中看到。 因此，总结一下，私有和共享的区别：私有变量只对一个线程可用，不能被其他任何线程访问，而共享变量不仅可以被程序中的每个线程访问，而且还可以被每个线程同时更新。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> num_threads = <span class="hljs-number">10</span>;<br>  <span class="hljs-built_in">omp_set_num_threads</span>(num_threads);<br><br>  <span class="hljs-type">int</span> private_var = <span class="hljs-number">1000</span>;<br>  <span class="hljs-type">int</span> shared_var = <span class="hljs-number">5000</span>;<br>  <span class="hljs-type">int</span> rank;<br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(private_var, rank) shared(shared_var)</span><br>  &#123;<br>    rank = <span class="hljs-built_in">omp_get_thread_num</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread ID is: %d\n&quot;</span>, rank);  <br>    private_var = private_var + num_threads;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of private_var is: %d\n&quot;</span>, private_var);<br>    shared_var = shared_var + num_threads;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of shared_var is: %d\n&quot;</span>, shared_var);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的代码并观察输出。当被不同的线程访问时，私有和共享变量的值如何变化？当被多个线程修改时，共享变量的值是否增加？为什么？</p><p>被不同线程访问时私有变量private_var初始值不变，共享变量初始值shared_var会改变。</p><p><strong>多个线程修改时，共享变量的值不一定增加，可能发生并发修改and修改丢失。</strong>❌</p><p>这里可能还存在一个竞赛条件。并行区域内的变量的写入和立即读取是一个写-读竞赛条件。两个或多个线程访问同一个共享变量并对其进行修改，这些访问是不同步的。我们将在并行区域练习中看到一个更清晰的竞赛条件的例子。</p><p>！！结果显示，并没有发生并发问题</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">5</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5010</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">8</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5020</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5030</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5040</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">9</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5050</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">2</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5060</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">6</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5070</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">4</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5080</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">3</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5090</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">7</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5100</span><br></code></pre></td></tr></table></figure><h3 id="五、Clauses"><a href="#五、Clauses" class="headerlink" title="五、Clauses"></a>五、Clauses</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">omp_set_num_threads</span>(num_threads);<br><br>    <span class="hljs-type">int</span> private_var = <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">int</span> shared_var = <span class="hljs-number">5000</span>;<br>    <span class="hljs-type">int</span> rank;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(private_var) shared(shared_var)</span><br>    &#123;<br>        rank = <span class="hljs-built_in">omp_get_thread_num</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread ID is: %d\n&quot;</span>, rank);  <br>        private_var = private_var + num_threads;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of private_var is: %d\n&quot;</span>, private_var);<br>        shared_var = shared_var + num_threads;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of shared_var is: %d\n&quot;</span>, shared_var);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>花点时间，试着理解上面的代码中发生了什么。</p><ul><li><p>当被不同的线程访问时，私有和共享变量的值如何变化？</p><p>被不同线程访问时私有变量private_var初始值不变（<strong>为0！</strong>），共享变量初始值shared_var会改变。</p></li><li><p>当被多个线程修改时，共享变量的值是否增加？为什么？</p><p><strong>多个线程修改时，共享变量的值不一定增加，可能发生并发修改and修改丢失？</strong></p><p><strong>运行没有出现这个现象，但是助教在评论中提到了会出现race condition</strong> </p></li><li><p>当被多个线程修改时，私有变量的值是否会增加？</p></li></ul><p>现在去做练习，试一试，检查你的答案是否正确。</p><h3 id="六、Parallel-region"><a href="#六、Parallel-region" class="headerlink" title="六、Parallel region"></a>六、Parallel region</h3><p>在这个练习中，你将得到练习使用基本的运行时函数、指令格式、并行结构和条款，这些都是我们到目前为止学到的。</p><p>这个练习的代码在Jupyter笔记本的以下说明中。你将从这个提供的Hello world模板开始。预期的输出是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    i = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world %d\n&quot;</span>, i );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><ol><li>进入练习，使用其中一个运行时函数将所需的线程数设置为4。✅</li><li>使用其中一个运行时函数将变量i设置为该线程的ID。✅</li><li>添加一个并行区域，使代码并行运行。✅</li><li>在包含OpenMP头文件和使用运行时函数时，添加OpenMP条件条款。✅</li></ol><p>在你运行这个程序之前，你认为会发生什么？ 现在，运行该程序并观察输出。你可以将线程数改为12个或其他，观察输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">%%file exercise.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br><br>    i = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">12</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _OPENMP</span><br>    <span class="hljs-built_in">omp_set_num_threads</span>(num_threads);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel </span><br>    &#123;<br>        i = <span class="hljs-built_in">omp_get_thread_num</span>();<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world openmp %d\n&quot;</span>, i );<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world gcc %d\n&quot;</span>, i );<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221128210815541.png" alt="image-20221128210815541"></p><ol><li>为变量i的并行区域添加一个私有子句。</li></ol><p>会发生什么？观察输出的差异。为什么输出会不同？检查你是否得到一个竞赛条件。</p><p>竞赛条件(Race condition):</p><ul><li>两个线程访问同一个共享变量，并且至少有一个线程修改了该变量，并且访问没有同步化。</li><li>程序的结果取决于团队中各线程的时间。</li><li>这是由非故意的数据共享造成的。</li></ul><p><strong>不要担心你是否总是得到正确的输出，因为编译器可能在每个线程上使用一个私有寄存器，而不是直接写入内存中</strong></p><ul><li>If compiled with OpenMP, the program should output »hello world« and the ID of each thread.</li></ul><h2 id="第二节、Worksharing-directives（工作共享指令）"><a href="#第二节、Worksharing-directives（工作共享指令）" class="headerlink" title="第二节、Worksharing directives（工作共享指令）"></a>第二节、Worksharing directives（工作共享指令）</h2><h3 id="一、Which-thread-executes-which-statement-or-operation"><a href="#一、Which-thread-executes-which-statement-or-operation" class="headerlink" title="一、Which thread executes which statement or operation?"></a>一、Which thread executes which statement or operation?</h3><p>在下面的步骤中，我们要学习如何真正地平行组织我们的工作。请分享你对我们如何实现这一目标的想法。</p><p>你知道有哪些可能的并行组织工作的方法吗？如何在线程之间分配操作？有什么方法可以控制线程的顺序吗？</p><h3 id="二、OpenMP-constructs"><a href="#二、OpenMP-constructs" class="headerlink" title="二、OpenMP constructs"></a>二、OpenMP constructs</h3><h4 id="Worksharing-constructs（工作共享结构）"><a href="#Worksharing-constructs（工作共享结构）" class="headerlink" title="Worksharing constructs（工作共享结构）"></a>Worksharing constructs（工作共享结构）</h4><p>工作共享结构将代码区域的执行在团队线程的不同成员之间进行划分。这些结构不启动新的线程，它们被动态地包围在并行区域内。工作共享结构体的一些例子是。</p><ul><li>sections</li><li>for</li><li>task</li><li>single</li></ul><h4 id="Section-construct"><a href="#Section-construct" class="headerlink" title="Section construct"></a>Section construct</h4><p>我们首先将看到一个使用section结构的代码例子，我们可以通过指令性的section来指定它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp sections</span><br>    &#123;<br>      <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>      &#123;<br>        <span class="hljs-built_in">function_1</span>();<span class="hljs-comment">// a=... b=...</span><br>      &#125;<br>      <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>      &#123; <br>        <span class="hljs-built_in">function_2</span>();<span class="hljs-comment">// c=... d=...</span><br>      &#125;<br>    &#125;<br>&#125;<span class="hljs-comment">// end of parallel</span><br></code></pre></td></tr></table></figure><p>当我们使用section结构时，多个代码块被并行执行。当我们指定章节并将一个任务放入其中时，这个特定的任务将在一个线程中执行。然后，当我们进入另一个部分时，它将在不同的线程中执行其任务。这样，我们就可以在pragma omp并行代码中添加这些部分，为每个线程指定一个部分，这些部分将在每个单独的线程中执行。</p><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221128212103284.png" alt="image-20221128212103284"></p><p>在上面的示例代码中，我们可以看到，在这一节中，我们指定了变量a和b。当这段代码被执行时，一个新的线程会带着这些变量产生，同样的，变量c和d也被指定在不同的一节中，因此也在不同的线程中。</p><p>Eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp">%%file sections.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Function 1 done by thread %d \n&quot;</span> , <span class="hljs-built_in">omp_get_thread_num</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j != <span class="hljs-number">2</span>; j++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Function 2 done by thread %d \n&quot;</span> , <span class="hljs-built_in">omp_get_thread_num</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>; <span class="hljs-comment">//number of threads</span><br>    <span class="hljs-built_in">omp_set_num_threads</span>(n);<br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp sections</span><br>        &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>            &#123;<br>                <span class="hljs-built_in">function_1</span>();<br>            &#125;<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>            &#123; <br>                <span class="hljs-built_in">function_2</span>();<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br>output:<br>Function <span class="hljs-number">2</span> done by thread <span class="hljs-number">0</span> <br>Function <span class="hljs-number">2</span> done by thread <span class="hljs-number">0</span> <br>Function <span class="hljs-number">1</span> done by thread <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="For-construct"><a href="#For-construct" class="headerlink" title="For construct"></a>For construct</h4><p>在计算机科学中，for-loop是一个指定迭代的控制流语句。这使得代码可以被反复执行。这样的任务，动作相似，多次执行，也可以被并行化。在OpenMP中，我们可以使用#pragma omp中的for结构。简单地说，for结构可以被看作是一个并行化的for循环。我们可以将for结构指定为</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#pragma omp for <span class="hljs-comment">[clause<span class="hljs-comment">[<span class="hljs-comment">[,]</span>clause]</span>...]</span><br></code></pre></td></tr></table></figure><p>这里我们也是以pragma omp开始，后面是for关键字，我们可以再次使用不同的子句，即私有的、共享的等等。相应的for-loop必须有一个规范的形状。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (int i<span class="hljs-operator">=</span>it<span class="hljs-comment">; i&lt;M; i++)</span><br></code></pre></td></tr></table></figure><p>由于每个迭代器默认是一个私有变量，并且只由一个线程共享，所以迭代器在循环体中不会被修改。如果它被每个线程访问，我们的for-loop就会被破坏。</p><p>除了private，我们还有一些其他的子句。比如说。</p><ul><li>schedule。它对循环的迭代如何在线程之间分配进行分类。</li><li>collapse(n)。n个循环的迭代被折叠成一个更大的迭代空间。</li></ul><p>我们可以看到代码中使用for结构的一个例子。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(f)</span><br>&#123;<br>    f=<span class="hljs-number">10</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>        a[i] = b[i]*f;<br>    &#125; <span class="hljs-comment">// end of for</span><br>&#125; <span class="hljs-comment">// end of parallel</span><br></code></pre></td></tr></table></figure><p>我们用pragma omp parallel开始，然后是名为f的私有变量。然后我们用pragma omp for构造，接着是一个从0到10的for循环（10次不同的迭代）。然后，私有变量f在每个线程中都是固定的，列表a被并行更新。这是因为每个数组需要的索引都是不同的。所以，每个线程只能访问数组的一个地方，允许我们并行更新这个列表。</p><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221128212831945.png" alt="image-20221128212831945"></p><p>在这里我们可以看到，如果我们在两个线程上工作，有10个迭代，那么这些迭代将被分成两个线程，分别从0到4和5到9。列表a上的每个地方都将被自己更新，由于迭代器是相互独立的，它们只修改一个地方，所以我们可以很容易地更新列表a的每个地方。</p><p>Eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file forloop.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>; <span class="hljs-comment">//number of threads</span><br>    omp_set_num_threads(n);<br><span class="hljs-type">int</span>* iterations; <span class="hljs-comment">//count iterations for each thread</span><br>iterations = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span> (n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br><span class="hljs-type">int</span> f = <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">//set array values to 0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> loop = <span class="hljs-number">0</span>; loop &lt; n; loop++)<br>&#123;<br>    iterations[loop] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel shared(iterations, f)</span><br>&#123;    <br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; f; i++)<br>    &#123;<br>        iterations[omp_get_thread_num()]++;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> loop = <span class="hljs-number">0</span>; loop &lt; n; loop++)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, iterations[loop]);<br>&#125;<br><br><span class="hljs-built_in">free</span>(iterations);  <br>&#125;<br><br>output:<br><span class="hljs-number">25</span> <span class="hljs-number">25</span> <span class="hljs-number">25</span> <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><h4 id="pragma-omp-single"><a href="#pragma-omp-single" class="headerlink" title="#pragma omp single"></a>#pragma omp single</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file single.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>; <span class="hljs-comment">//number of threads</span><br>    omp_set_num_threads(n);<br>    <span class="hljs-type">int</span> sum1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> sum2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> f = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel shared(sum1, sum2)</span><br>    &#123;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; f; i++)<br>        &#123;<br>            sum1 += <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread_id = %d sum1 = %d\n&quot;</span>, omp_get_thread_num(),sum1);<br><br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp single</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The first sum is %d\n&quot;</span>, sum1);<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; f; i++)<br>        &#123;<br>            sum2 += <span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread_id = %d sum2 = %d\n&quot;</span>, omp_get_thread_num(),sum2);<br><br>        &#125;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp single</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The second sum is %d\n&quot;</span>, sum2);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br>output:<span class="hljs-comment">// sum2的最终值每次会发生变化，应该是都发生了并发问题</span><br>thread_id = <span class="hljs-number">0</span> sum1 = <span class="hljs-number">1</span><br>thread_id = <span class="hljs-number">0</span> sum1 = <span class="hljs-number">5</span><br>thread_id = <span class="hljs-number">0</span> sum1 = <span class="hljs-number">6</span><br>thread_id = <span class="hljs-number">1</span> sum1 = <span class="hljs-number">3</span><br>thread_id = <span class="hljs-number">1</span> sum1 = <span class="hljs-number">7</span><br>thread_id = <span class="hljs-number">1</span> sum1 = <span class="hljs-number">8</span><br>thread_id = <span class="hljs-number">2</span> sum1 = <span class="hljs-number">4</span><br>thread_id = <span class="hljs-number">2</span> sum1 = <span class="hljs-number">9</span><br>thread_id = <span class="hljs-number">3</span> sum1 = <span class="hljs-number">2</span><br>thread_id = <span class="hljs-number">3</span> sum1 = <span class="hljs-number">10</span><br>The first sum is <span class="hljs-number">10</span><br>thread_id = <span class="hljs-number">3</span> sum2 = <span class="hljs-number">2</span><br>thread_id = <span class="hljs-number">0</span> sum2 = <span class="hljs-number">4</span><br>thread_id = <span class="hljs-number">1</span> sum2 = <span class="hljs-number">2</span><br>thread_id = <span class="hljs-number">3</span> sum2 = <span class="hljs-number">6</span><br>thread_id = <span class="hljs-number">1</span> sum2 = <span class="hljs-number">8</span><br>thread_id = <span class="hljs-number">1</span> sum2 = <span class="hljs-number">10</span><br>thread_id = <span class="hljs-number">0</span> sum2 = <span class="hljs-number">12</span><br>thread_id = <span class="hljs-number">0</span> sum2 = <span class="hljs-number">14</span><br>thread_id = <span class="hljs-number">2</span> sum2 = <span class="hljs-number">2</span><br>thread_id = <span class="hljs-number">2</span> sum2 = <span class="hljs-number">16</span><br>The second sum is <span class="hljs-number">16</span><br>  <br><br></code></pre></td></tr></table></figure><h4 id="pragma-omp-task（todo"><a href="#pragma-omp-task（todo" class="headerlink" title="#pragma omp task（todo)"></a>#pragma omp task（todo)</h4><p>Task 用于指定某一段程序，并放置在任务池中，由进程池中的空闲的进程执行该任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file task.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">2</span>; <span class="hljs-comment">//number of threads</span><br>    omp_set_num_threads(n);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>    &#123;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp single</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A &quot;</span>);<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp task</span><br>            &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;race &quot;</span>);&#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp task</span><br>            &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;car &quot;</span>);&#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br>output：<br>A race car <br></code></pre></td></tr></table></figure><h3 id="三、Synchronization"><a href="#三、Synchronization" class="headerlink" title="三、Synchronization"></a>三、Synchronization</h3><p>在并行编程中，有时在处理并行运行的多个线程时，我们希望暂停线程的执行，而一次只运行一个线程。这是用所谓的障碍物实现的。同步可以通过两种方式实现，即通过隐式屏障或显式屏障。</p><ul><li>Implicit barrier(隐性障碍)</li></ul><p>我们已经在前面两个例子中看到了隐式屏障的使用。它是并行构造的开始和结束的屏障，也是所有其他控制构造的屏障。在C++中，这是用大括号实现的。正如我们在前面的例子中所看到的，{是隐式屏障，在这里我们指定进入并行区域，而最后的}基本上是隐式屏障，它指定了并行构造的结束，并表示转入代码的串行执行。隐式同步可以通过nowait子句来移除，但我们不会在本节中讨论它。</p><ul><li>Explicit barrier(显式屏障)</li></ul><p>为了应用显式屏障，我们使用了一个临界子句，基本上指定了屏障的存在。在使用显式屏障时，包含在临界子句中的代码会被所有线程执行，但每次只限制在一个线程中。C&#x2F;C++中的临界子句的定义是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp critical [(name)]</span><br></code></pre></td></tr></table></figure><p>让我们快速浏览一下这段代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">cnt = <span class="hljs-number">0</span>;<br>f=<span class="hljs-number">10</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>&#123;<br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for</span><br>     <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>       <span class="hljs-keyword">if</span> (b[i] == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp critical</span><br>          cnt ++;<br>       &#125; <span class="hljs-comment">/* endif */</span><br>       a[i] = b[i]*f;<br>  &#125; <span class="hljs-comment">/* end for */</span><br>&#125; <span class="hljs-comment">/*omp end parallel */</span><br></code></pre></td></tr></table></figure><p>我们看到，我们已经指定了变量cnt和f，在并行区域我们指定了for结构，所以我们可以进行迭代。在if语句中，我们为下一行指定了pragma omp critical，即cnt ++。我们可以在下面的图片中观察到线程执行中发生的情况。</p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221129165944073.png" alt="image-20221129165944073" style="zoom:50%;"><p>在我们进入pragma omp并行区域之前，我们是在串行执行中，所以那部分是串行执行的。然后我们进入了我们的并行区域。在第一个线程遇到cnt++语句之前，一切都以并行方式执行。这时，cnt++语句由遇到它的第一个线程执行。在这段时间内，第二个线程无法访问它，因为cnt已经被第一个线程修改。因此，在第一个线程完成关键操作后，下一个线程将获得对cnt变量的访问权并修改它。在所有的线程都执行了cnt++语句之后，代码也继续并行地执行。它一直持续到达到我们在最后指定的隐式屏障，之后我们返回到串行执行。</p><p><strong>我们归功于临界子句，对于这个cnt变量，每次只有一个线程被执行。</strong>因此，当我们在一个并行程序中使用临界子句时，只有一个线程能够执行你在临界子句中指定的那部分代码。</p><h3 id="四、Nesting-and-binding（嵌套和绑定）"><a href="#四、Nesting-and-binding（嵌套和绑定）" class="headerlink" title="四、Nesting and binding（嵌套和绑定）"></a>四、Nesting and binding（嵌套和绑定）</h3><h4 id="Directive-Scoping"><a href="#Directive-Scoping" class="headerlink" title="Directive Scoping"></a>Directive Scoping</h4><p>OpenMP规定了一些关于指令如何关联（绑定）和相互嵌套的范围规则。这就是为什么如果忽略了OpenMP的绑定和嵌套规则，可能会导致不正确的程序。这些术语被用来解释OpenMP指令的影响。</p><p><strong>Static (Lexical) Extent:（静态范围）</strong></p><ul><li>在指令之后的结构化块的开头和结尾之间的文本所包含的代码。</li><li>一个指令的静态范围不跨越多个例程或代码文件。</li></ul><p><strong>Dynamic Extent：</strong></p><ul><li>指令的动态范围还包括从构造中调用的例程。</li><li>它包括其静态（词法）范围和其孤儿指令的范围。</li></ul><p><strong>Orphaned Directive:（被遗弃的指令）</strong></p><ul><li>一个独立于另一个封闭指令出现的OpenMP指令被称为 “孤儿 “指令。它们是动态范围内的指令，但不在静态范围内。</li><li>会跨越例程，也可能跨越代码文件。</li></ul><p>让我们用这个示例程序来解释。我们有2个子程序调用，而且都是并行的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>&#123;<br>     ...<br>     <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for</span><br>     &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>               ...<br>               sub1();<br>               ...<br>          &#125;<br>     &#125;<br>     ...<br>     sub2();<br>     ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是两个子程序sub1和sub2。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sub1</span>()</span> &#123;<br>     ...<br>     <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp critical</span><br>     &#123;<br>          ...<br>     &#125;<br>     ...<br>     <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sub2</span>()</span> &#123;<br>     ...<br>     <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp sections</span><br>     &#123;<br>          ...<br>     &#125;<br>     ...<br>     <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中。</p><ul><li>我们平行区域的静态范围正是这样，平行区域内的调用。FOR指令发生在一个封闭的并行区域内。</li><li>我们并行区域的动态范围是静态范围加上在并行区域内调用的两个子程序。CRITICAL和SECTIONS指令发生在FOR和PARALLEL指令的动态范围内。</li><li>在动态范围内，而不是在静态范围内，我们有无主的CRITICAL和SECTIONS指令。</li></ul><h3 id="五、Exercise-Calculate-Pi"><a href="#五、Exercise-Calculate-Pi" class="headerlink" title="五、Exercise: Calculate Pi"></a>五、Exercise: Calculate Pi</h3><p>Pi的计算方式之一：</p><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221129172157867.png" alt="image-20221129172157867"></p><p>该积分可以用以下数字逼近：</p><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221129172323455.png" alt="image-20221129172323455"></p><p>这里，n是区间的数量，h&#x3D;1&#x2F;n。</p><h4 id="串行代码"><a href="#串行代码" class="headerlink" title="串行代码"></a>串行代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file exercise.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> f(A) (4.0/(1.0+A*A))</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>    omp_set_num_threads(num_threads);<br><br>    <span class="hljs-comment">//declarations</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">10000000</span>;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">double</span> w, x, sum, pi;<br>    <span class="hljs-type">clock_t</span> t1, t2;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">tv1</span>, <span class="hljs-title">tv2</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timezone</span> <span class="hljs-title">tz</span>;</span><br>    <span class="hljs-type">double</span> wt1, wt2;<br><br>    <span class="hljs-meta">#   <span class="hljs-keyword">pragma</span> omp parallel</span><br>    &#123; <br>    <span class="hljs-meta">#     <span class="hljs-keyword">pragma</span> omp single </span><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenMP-parallel with %1d threads\n&quot;</span>, omp_get_num_threads());<br>    &#125; <span class="hljs-comment">/* end omp parallel */</span><br>    <span class="hljs-meta"># <span class="hljs-keyword">pragma</span> omp barrier</span><br><br>    gettimeofday(&amp;tv1, &amp;tz);<br>    wt1 = omp_get_wtime();<br>    t1 = clock();<br><br>    <span class="hljs-comment">/* calculate pi = integral [0..1] 4/(1+x**2) dx */</span><br>    w = <span class="hljs-number">1.0</span>/n;<br>    sum = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        x = w*((<span class="hljs-type">double</span>)i<span class="hljs-number">-0.5</span>);<br>        sum = sum+f(x);<br>    &#125;<br>    pi = w*sum;<br><br>    t2 = clock();<br>    wt2 = omp_get_wtime();<br>    gettimeofday(&amp;tv2, &amp;tz);<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;computed pi = %24.16g\n&quot;</span>, pi );<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;CPU time (clock)                = %12.4g sec\n&quot;</span>, (t2-t1)/<span class="hljs-number">1000000.0</span> );<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;wall clock time (omp_get_wtime) = %12.4g sec\n&quot;</span>, wt2-wt1 );<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;wall clock time (gettimeofday)  = %12.4g sec\n&quot;</span>, (tv2.tv_sec-tv1.tv_sec) + (tv2.tv_usec-tv1.tv_usec)*<span class="hljs-number">1e-6</span> );<br>&#125;<br><br>output:<br>OpenMP-parallel with <span class="hljs-number">4</span> threads<br>computed pi =        <span class="hljs-number">3.141592653589731</span><br>CPU time (clock)                =       <span class="hljs-number">0.1159</span> sec<br>wall clock time (omp_get_wtime) =       <span class="hljs-number">0.1113</span> sec<br>wall clock time (gettimeofday)  =       <span class="hljs-number">0.1113</span> sec<br></code></pre></td></tr></table></figure><h4 id="一些函数"><a href="#一些函数" class="headerlink" title="一些函数"></a>一些函数</h4><ul><li><p>gettimeofday(&amp;tv1, &amp;tz)</p><p>int gettimeofday(struct timeval*tv,struct timezone *tz )</p><p>这个函数会把时间包装为一个结构体返回。包括秒，微妙，时区等信息.通过这个函数即可 准确获取多线程序运行时间。</p></li><li><p>omp_get_wtime()</p><p>返回的是一个观察点的时间值，这个时间将一直在程序运行时持续，也就是说，在程序运行前使用和程序运行结束使用，这个时间差是整个程序运行的时间，而不是clock得到的cpu运行的时间</p></li><li><p>clock()</p><p>返回的是处理器执行的时间，也就是说，只要内核中有程序在cpu中运行，时间就会增加，使用多核并行化技术并不能并行地计算使用的时间，仍然是进行<strong>叠加</strong></p></li></ul><h4 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h4><ol><li>进入练习，在计算Pi的部分添加一个并行区域和for指令。Pi的计算是否正确？多次测试一下，把线程数改为2或12，并尝试找到竞赛条件。</li></ol><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs excel"> /* calculate <span class="hljs-built_in">pi</span> = integral [<span class="hljs-number">0</span>..<span class="hljs-number">1</span>] <span class="hljs-number">4</span>/(<span class="hljs-number">1</span>+x**<span class="hljs-number">2</span>) dx */<br>    w = <span class="hljs-number">1.0</span>/<span class="hljs-built_in">n</span>;<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0.0</span>;<br>    #   pragma omp parallel<br>    &#123;<br>    # pragma omp for<br>      for (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">n</span>; i++)<br>      &#123;<br>          x = w*((double)i-<span class="hljs-number">0.5</span>);<br>          <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span>+f(x);<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">pi</span> = w*<span class="hljs-built_in">sum</span>;<br>outo<span class="hljs-symbol">ut:</span><br>OpenMP-parallel with <span class="hljs-number">4</span> threads<br>computed <span class="hljs-built_in">pi</span> =        <span class="hljs-number">1.297274379815414</span><br>CPU <span class="hljs-built_in">time</span> (clock)                =       <span class="hljs-number">0.2108</span> <span class="hljs-built_in">sec</span><br>wall clock <span class="hljs-built_in">time</span> (omp_get_wtime) =      <span class="hljs-number">0.07117</span> <span class="hljs-built_in">sec</span><br>wall clock <span class="hljs-built_in">time</span> (gettimeofday)  =      <span class="hljs-number">0.07117</span> <span class="hljs-built_in">sec</span><br></code></pre></td></tr></table></figure><p><strong>结论：pi错误，cpu时间与总耗时不再相等，发生了竞赛条件</strong></p><ol start="2"><li>添加private(x)子句。还是不正确吗？</li></ol><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs excel"> /* calculate <span class="hljs-built_in">pi</span> = integral [<span class="hljs-number">0</span>..<span class="hljs-number">1</span>] <span class="hljs-number">4</span>/(<span class="hljs-number">1</span>+x**<span class="hljs-number">2</span>) dx */<br>    w = <span class="hljs-number">1.0</span>/<span class="hljs-built_in">n</span>;<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0.0</span>;<br>    #   pragma omp parallel private(x)<br>    &#123;<br>        # pragma omp for<br>        for (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">n</span>; i++)<br>        &#123;<br>            x = w*((double)i-<span class="hljs-number">0.5</span>);<br>            # <br>            <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span>+f(x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">pi</span> = w*<span class="hljs-built_in">sum</span>;<br>    <br>outp<span class="hljs-symbol">ut:</span><br>OpenMP-parallel with <span class="hljs-number">4</span> threads<br>computed <span class="hljs-built_in">pi</span> =        <span class="hljs-number">1.527720616497807</span><br>CPU <span class="hljs-built_in">time</span> (clock)                =       <span class="hljs-number">0.2061</span> <span class="hljs-built_in">sec</span><br>wall clock <span class="hljs-built_in">time</span> (omp_get_wtime) =      <span class="hljs-number">0.06862</span> <span class="hljs-built_in">sec</span><br>wall clock <span class="hljs-built_in">time</span> (gettimeofday)  =      <span class="hljs-number">0.06862</span> <span class="hljs-built_in">sec</span><br></code></pre></td></tr></table></figure><p><strong>结论：还是不正确，时间所差无几</strong></p><ol start="3"><li>在sum语句周围添加一个临界指令，然后进行编译。Pi的值是否正确？CPU的时间是多少？你可以如何优化你的代码？</li></ol><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs excel"> /* calculate <span class="hljs-built_in">pi</span> = integral [<span class="hljs-number">0</span>..<span class="hljs-number">1</span>] <span class="hljs-number">4</span>/(<span class="hljs-number">1</span>+x**<span class="hljs-number">2</span>) dx */<br>    w = <span class="hljs-number">1.0</span>/<span class="hljs-built_in">n</span>;<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0.0</span>;<br>    #   pragma omp parallel private(x),shared(w,<span class="hljs-built_in">sum</span>)<br>    &#123;<br>        # pragma omp for<br>        for (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">n</span>; i++)<br>        &#123;<br>            x = w*((double)i-<span class="hljs-number">0.5</span>);<br>            <br>            # pragma omp critical<br>            &#123;<br>                <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span>+f(x);<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">pi</span> = w*<span class="hljs-built_in">sum</span>;<br><br>outp<span class="hljs-symbol">ut:</span><br>OpenMP-parallel with <span class="hljs-number">4</span> threads<br>computed <span class="hljs-built_in">pi</span> =        <span class="hljs-number">3.141592653589849</span><br>CPU <span class="hljs-built_in">time</span> (clock)                =        <span class="hljs-number">4.173</span> <span class="hljs-built_in">sec</span><br>wall clock <span class="hljs-built_in">time</span> (omp_get_wtime) =        <span class="hljs-number">1.086</span> <span class="hljs-built_in">sec</span><br>wall clock <span class="hljs-built_in">time</span> (gettimeofday)  =        <span class="hljs-number">1.086</span> <span class="hljs-built_in">sec</span><br><br>优化：<br> /* calculate <span class="hljs-built_in">pi</span> = integral [<span class="hljs-number">0</span>..<span class="hljs-number">1</span>] <span class="hljs-number">4</span>/(<span class="hljs-number">1</span>+x**<span class="hljs-number">2</span>) dx */<br>    w = <span class="hljs-number">1.0</span>/<span class="hljs-built_in">n</span>;<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0.0</span>;<br>    double tmp;<br>    #   pragma omp parallel private(x,tmp),shared(w,<span class="hljs-built_in">sum</span>)<br>    &#123;<br>        # pragma omp for<br>        for (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">n</span>; i++)<br>        &#123;<br>            double x = w*((double)i-<span class="hljs-number">0.5</span>);<br>            double tmp = f(x);<br>            # pragma omp critical<br>            &#123;<br>                <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span>+tmp;<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">pi</span> = w*<span class="hljs-built_in">sum</span>;<br><br>outp<span class="hljs-symbol">ut2:</span><br>OpenMP-parallel with <span class="hljs-number">4</span> threads<br>computed <span class="hljs-built_in">pi</span> =        <span class="hljs-number">3.141592653589924</span><br>CPU <span class="hljs-built_in">time</span> (clock)                =        <span class="hljs-number">3.694</span> <span class="hljs-built_in">sec</span><br>wall clock <span class="hljs-built_in">time</span> (omp_get_wtime) =       <span class="hljs-number">0.9747</span> <span class="hljs-built_in">sec</span><br>wall clock <span class="hljs-built_in">time</span> (gettimeofday)  =       <span class="hljs-number">0.9747</span> <span class="hljs-built_in">sec</span><br></code></pre></td></tr></table></figure><p><strong>结论：将f(x)计算放外面，速度优化了0.1s，但是由于上锁过多，反而比串行运行慢得多</strong></p><ol start="4"><li>将临界指令移到for循环之外以减少计算时间。</li></ol><p><strong>nowait 子句用于消除隐式的 barrier（*implicit barrier*）</strong></p><pre><code class="hljs"> /* calculate pi = integral [0..1] 4/(1+x**2) dx */    w = 1.0/n;    sum = 0.0;    double tmp, sum0;    #   pragma omp parallel private(x,tmp,sum0),shared(w,sum)    &#123;        sum0 = 0;        # pragma omp for nowait        for (i = 1; i &lt;= n; i++)        &#123;            x = w*((double)i-0.5);            tmp = f(x);            sum0 += tmp;        &#125;        # pragma omp critical        &#123;            sum += sum0;        &#125;             &#125;        pi = w*sum;        output:OpenMP-parallel with 4 threadscomputed pi =         3.14159265358967CPU time (clock)                =       0.1304 secwall clock time (omp_get_wtime) =      0.03479 secwall clock time (gettimeofday)  =      0.03479 sec</code></pre><p><strong>结论：总cpu处理时间和串行多一点点，但是执行比串行快很多，大概在之前1&#x2F;3～1&#x2F;4样子</strong></p><h3 id="六、Do-you-understand-worksharing-directives"><a href="#六、Do-you-understand-worksharing-directives" class="headerlink" title="六、Do you understand worksharing directives?"></a>六、Do you understand worksharing directives?</h3><p>  <strong>The purpose of <code>#pragma omp for</code> is？</strong></p><p>Loop work is to be divided into user defined sections❌</p><p>Work to be done in a loop when done, don’t wait❌ （+nowait）</p><p>Work to be done in a loop✅</p><p><strong>The following code forces threads to wait till all are done:</strong></p><p>#pragma omp parallel❌</p><p>#pragma omp barrier✅</p><p>#pragma omp critical❌（临界锁）</p><p>#pragma omp sections❌</p><h2 id="第三节、Data-environment-and-combined-constructs"><a href="#第三节、Data-environment-and-combined-constructs" class="headerlink" title="第三节、Data environment and combined constructs"></a>第三节、Data environment and combined constructs</h2><h3 id="一、Private-and-shared-variables"><a href="#一、Private-and-shared-variables" class="headerlink" title="一、Private and shared variables"></a>一、Private and shared variables</h3><p>我们已经了解了private子句，在这里我们可以指定每个线程应该有自己的变量实例。我们还学习了共享子句，我们可以指定一个或多个变量在所有线程之间共享。这通常是不需要的，<strong>因为默认范围是共享的。</strong></p><p>有几个例外情况。</p><ul><li>被调用的子程序中的堆栈（局部）变量是自动私有的</li><li>一个区块内的自动变量是私有的</li><li>并行FOR循环的循环控制变量是私有的</li></ul><h4 id="私有子句"><a href="#私有子句" class="headerlink" title="私有子句"></a>私有子句</h4><ul><li>私有子句总是创建一个变量的本地实例。对于每一个线程来说，都会创建一个新的变量，并带有一个未初始化的值<strong>。这意味着这些私有变量除了具有相同的名称和类型外，与原始变量没有任何关系。</strong></li><li>firstprivate(var)指定每个线程应该有自己的变量实例，并且该变量应该用并行构造之前存在的共享变量的值进行初始化。</li><li>lastprivate(var)指定变量在并行结构后的值被设置为等于执行最后迭代（for-loop结构）或最后一段（#pragma sections）的哪个线程的私有版本。</li><li>具有相同变量名称的嵌套private(var)再次分配新的私有存储。</li></ul><p>Let’s explain by observing the following code：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>    omp_set_num_threads(num_threads);<br><br>    <span class="hljs-type">int</span> var_shared = <span class="hljs-number">-777</span>;<br>    <span class="hljs-type">int</span> var_private = <span class="hljs-number">-777</span>;<br>    <span class="hljs-type">int</span> var_firstprivate = <span class="hljs-number">-777</span>;<br>    <span class="hljs-type">int</span> var_lastprivate = <span class="hljs-number">-777</span>;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel shared(var_shared) private(var_private) firstprivate(var_firstprivate)</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for lastprivate(var_lastprivate)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>        &#123;<br>            var_shared = i;<br>            var_private = i;<br>            var_firstprivate = i;<br>            var_lastprivate = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;after parallel region: %d %d %d %d&quot;</span>, <br>        var_shared, var_private, var_firstprivate, var_lastprivate);<br>&#125;<br><br>output：<br>after parallel region: <span class="hljs-number">999</span> <span class="hljs-number">-777</span> <span class="hljs-number">-777</span> <span class="hljs-number">999</span> ✅<br></code></pre></td></tr></table></figure><p>花点时间，试着猜测平行区域后的变量的值。注意数据范围条款的用法。<br>var_shared是一个共享变量，它通常会被并行区域更新。<br>var_private被指定为private，所以每个线程都有自己的实例，在并行区域之后，其值仍与之前相同。<br>var_firstprivate被指定为private，并在共享范围内用值初始化，但在并行区域之后，值保持不变。<br>var_lastprivate在for循环的最后一次迭代中被更新，以便在并行区域之后使用。</p><h3 id="二、Reduction-clause"><a href="#二、Reduction-clause" class="headerlink" title="二、Reduction clause"></a>二、Reduction clause</h3><p>Reduction子句是一个数据范围子句，可以用来并行地执行某种形式的递归计算。它定义了计算还原的区域，并指定了一个运算符和一个或多个列表还原变量。减少子句的语法如下。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">reduction (operator : <span class="hljs-type">list</span>)<br></code></pre></td></tr></table></figure><p>列表中的变量在包围的上下文中不能是私有的。私有变量不能在reduce子句中指定。一个变量不能同时在共享子句和reduce子句中指定。</p><p>对于每个列表项，在每次迭代中都会创建一个私有副本，并以运算符的中性常量值进行初始化。下表是每个运算符的列表及其语义初始化值。</p><table><thead><tr><th align="left">Operator</th><th align="left">Initializer</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">var &#x3D; 0</td></tr><tr><td align="left">-</td><td align="left">var &#x3D; 0</td></tr><tr><td align="left">*</td><td align="left">var &#x3D; 1</td></tr><tr><td align="left">&amp;</td><td align="left">var &#x3D; ~ 0</td></tr><tr><td align="left">&#96;</td><td align="left">&#96;</td></tr><tr><td align="left">^</td><td align="left">var &#x3D; 0</td></tr><tr><td align="left">&amp;&amp;</td><td align="left">var &#x3D; 1</td></tr><tr><td align="left">&#96;</td><td align="left"></td></tr><tr><td align="left">max</td><td align="left">var &#x3D; most negative number</td></tr><tr><td align="left">min</td><td align="left">var &#x3D; most positive number</td></tr></tbody></table><p>在该区域结束后，原始列表项被使用与运算符相关的组合器用私有拷贝的值更新。<br>让我们观察一下下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for reduction(+:sum)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++)<br>    &#123;<br>        sum = sum + i;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum: %d&quot;</span>, sum);<br>&#125;<br><br>output:<br>sum: <span class="hljs-number">190</span><br></code></pre></td></tr></table></figure><p>reduction变量是sum，reduction操作是+。reduction操作是自动进行的。它在循环中产生一个私有变量sum，最后将私有部分sum加到全局变量上。</p><h3 id="三、Sum-and-substract（❌-todo）"><a href="#三、Sum-and-substract（❌-todo）" class="headerlink" title="三、Sum and substract（❌ todo）"></a>三、Sum and substract（❌ todo）</h3><p>在这个练习中，你将在一个组合的并行循环结构中练习求和和求减。<br>在这个练习中，我们要生成一些人，这些人要减去我们的苹果值。你需要做的是将代码并行化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">double</span> <span class="hljs-title function_">generate_people</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * i + <span class="hljs-number">3</span> * j); <span class="hljs-comment">// some dummy return value</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>    omp_set_num_threads(num_threads);<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> people = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> apples = <span class="hljs-number">5000</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; num; j++) &#123;<br>            <span class="hljs-type">int</span> ppl = generate_people(i, j);<br>            people += ppl;<br>            apples -= ppl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;people = %d\n&quot;</span>, people);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;apples = %d&quot;</span>, apples);<br>&#125;<br><br>output：<br>people = <span class="hljs-number">1095</span><br>apples = <span class="hljs-number">3905</span><br></code></pre></td></tr></table></figure><p>​<strong>练习</strong></p><ul><li>进入练习，添加一个带有for句的平行区域。</li><li>添加两个减少句：一个是增加人，另一个是减少苹果。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file reduction.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">double</span> <span class="hljs-title function_">generate_people</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * i + <span class="hljs-number">3</span> * j); <span class="hljs-comment">// some dummy return value</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>    &#123;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>    omp_set_num_threads(num_threads);<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> people = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> apples = <span class="hljs-number">5000</span>;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for reduction(+:people) reduction(-:apples)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; num; j++) &#123;<br>            <span class="hljs-type">int</span> ppl = generate_people(i, j);<br>            people += ppl;<br>            apples -= ppl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;people = %d\n&quot;</span>, people);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;apples = %d&quot;</span>, apples);<br>&#125;<br></code></pre></td></tr></table></figure><p>​然后回答这个问题。</p><ul><li>当我们试图让人们 “共享 “时会发生什么？为什么不能？</li></ul><h3 id="四、Combined-parallel-worksharing-directives"><a href="#四、Combined-parallel-worksharing-directives" class="headerlink" title="四、Combined parallel worksharing directives"></a>四、Combined parallel worksharing directives</h3><p>组合结构体是指定一个紧紧嵌套在另一个结构体中的结构体的快捷方式。指定一个组合构架在语义上与指定第一个构架包围第二个构架的实例以及没有其他语句是相同的。适用于两种指令的大部分规则、条款和限制都是有效的。并行结构体可以与其中一个工作共享结构体结合，例如for和section。</p><p><strong>parallel for</strong></p><p>当我们使用一个只包含一个for指令的并行区域时，我们可以用这个组合指令来代替单独的指令。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#pragma omp parallel for <span class="hljs-comment">[clause<span class="hljs-comment">[<span class="hljs-comment">[,]</span>clause]</span>...]</span><br></code></pre></td></tr></table></figure><p>这条指令接纳了并行指令和for指令的所有子句，除了禁止使用nowait子句。<br>这个组合指令必须直接放在for循环的前面。下面是一个组合结构的例子。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> f = <span class="hljs-number">7</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>     <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++)  &#123;<br>          c[i] = a[i] + b[i];<br>     &#125;<br></code></pre></td></tr></table></figure><h3 id="五、Calculate-Pi-with-combined-constructs"><a href="#五、Calculate-Pi-with-combined-constructs" class="headerlink" title="五、Calculate Pi with combined constructs"></a>五、Calculate Pi with combined constructs</h3><p>using reducer</p><pre><code class="hljs">/* calculate pi = integral [0..1] 4/(1+x**2) dx */w = 1.0/n;sum = 0.0;#pragma omp parallel private(x,sum0)&#123;   #pragma omp for reduction(+:sum)            for (i = 1; i &lt;= n; i++)    &#123;        x = f(w*((double)i-0.5));        sum += x;    &#125;   &#125; /*end omp parallel*/ pi = w*sum;</code></pre><h3 id="六、Heat-transfer"><a href="#六、Heat-transfer" class="headerlink" title="六、Heat transfer"></a>六、Heat transfer</h3><p>在这个练习中，你将练习使用到目前为止我们所学到的指令和子句，如  <code>parallel</code><strong>,</strong> <code>for</code><strong>,</strong> <code>single</code><strong>,</strong> <code>critical</code><strong>,</strong> <code>private</code> <strong>and</strong> <code>shared</code>**.**。你的工作是认识到在哪些地方需要这些东西。</p><p>热力方程是一个偏微分方程，描述了温度在空间中如何随时间变化。它可以写成</p><p><img src="/MPI/Introduction-to-Parallel-Programming/OpenMP/image-20221130154838096.png" alt="image-20221130154838096"></p><p>该程序采用显式方案求解热方程：时间超前和中心空间，并在单位平方域上求解方程。</p><p>初始条件非常简单。在正方形内的任何地方，温度都等于f&#x3D;0，在边缘的温度是f&#x3D;x。这意味着温度在x的方向上从0到1。</p><p>源代码有时是硬编码的，目的是加快循环迭代。你的目标是</p><ul><li>对程序进行并行化</li><li>根据对执行时间的影响，使用不同的并行化方法</li></ul><p>下面的代码计算了一个网格点的温度，代码的主要部分是时间步长的迭代。 dphi是温度的差异，phi是温度。然后我们把dphi加到phi数组中，并保存新的phin数组。然后在下一个for循环中我们交换新旧数组的角色（恢复数据）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file exercise.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-comment">// define functions MIN and MAX</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(A,B) ((A) &lt; (B) ? (A) : (B))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(A,B) ((A) &gt; (B) ? (A) : (B))</span><br><br><span class="hljs-comment">// define size of grid points</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> imax 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> kmax 11</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> itmax 20000</span><br><br><span class="hljs-comment">// function prints the temperature grid, don&#x27;t parallelize</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heatpr</span><span class="hljs-params">(<span class="hljs-type">double</span> phi[imax+<span class="hljs-number">1</span>][kmax+<span class="hljs-number">1</span>])</span><br>&#123;<br>    <span class="hljs-type">int</span> i,k,kl,kk,kkk;<br>    kl = <span class="hljs-number">6</span>; kkk = kl<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt;= kmax; k = k+kl)&#123;<br>        <span class="hljs-keyword">if</span>(k+kkk &gt; kmax) kkk = kmax-k;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\ncolumns %5d to %5d\n&quot;</span>, k, k+kkk);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= imax; i++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d &quot;</span>, i);<br>            <span class="hljs-keyword">for</span> (kk = <span class="hljs-number">0</span>; kk &lt;= kkk; kk++)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#12.4g&quot;</span>, phi[i][k+kk]);<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// define variables</span><br>    <span class="hljs-type">double</span> eps = <span class="hljs-number">1.0e-08</span>;<br>    <span class="hljs-type">double</span> phi[imax+<span class="hljs-number">1</span>][kmax+<span class="hljs-number">1</span>], phin[imax][kmax];<br>    <span class="hljs-type">double</span> dx, dy, dx2, dy2, dx2i, dy2i, dt, dphi, dphimax, dphimax0;<br>    <span class="hljs-type">int</span> i, k, it;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">tv1</span>, <span class="hljs-title">tv2</span>;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timezone</span> <span class="hljs-title">tz</span>;</span><br>    <span class="hljs-type">double</span> wt1, wt2;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenMP-parallel with %1d threads\n&quot;</span>, omp_get_num_threads());<br><br>    dx = <span class="hljs-number">1.0</span>/kmax; dy = <span class="hljs-number">1.0</span>/imax;<br>    dx2 = dx*dx; dy2 = dy*dy;<br>    dx2i = <span class="hljs-number">1.0</span>/dx2; dy2i = <span class="hljs-number">1.0</span>/dy2;<br>    dt = min(dx2,dy2)/<span class="hljs-number">4.0</span>;<br><br>    <span class="hljs-comment">// setting initial conditions</span><br>    <span class="hljs-comment">/* start values 0.d0 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; imax; i++)&#123;<br>        <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; kmax; k++)&#123;<br>            phi[i][k] = <span class="hljs-number">0.0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* start values 1.d0 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt;= imax; i++)&#123;<br>        phi[i][kmax] = <span class="hljs-number">1.0</span>;<br>    &#125;<br>    <span class="hljs-comment">/* start values dx */</span><br>    phi[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0.0</span>;<br>    phi[imax][<span class="hljs-number">0</span>] = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt; kmax; k++)&#123;<br>        phi[<span class="hljs-number">0</span>][k] = phi[<span class="hljs-number">0</span>][k<span class="hljs-number">-1</span>]+dx;<br>        phi[imax][k] = phi[imax][k<span class="hljs-number">-1</span>]+dx;<br>    &#125;<br>    <span class="hljs-comment">// print starting values</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nHeat Conduction 2d\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\ndx = %12.4g, dy = %12.4g, dt = %12.4g, eps = %12.4g\n&quot;</span>,<br>    dx, dy, dt, eps);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nstart values\n&quot;</span>);<br>    heatpr(phi);<br><br>    gettimeofday(&amp;tv1, &amp;tz);<br>    wt1 = omp_get_wtime();<br>    <span class="hljs-comment">/* time step iteration */</span><br>    <span class="hljs-keyword">for</span> (it = <span class="hljs-number">1</span>; it &lt;= itmax; it++)&#123;<br>        dphimax = <span class="hljs-number">0.</span>;<br>        dphimax0 = dphimax;<br>        <span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt; imax; k++)&#123;<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; kmax; i++)&#123;<br>                dphi = (phi[i+<span class="hljs-number">1</span>][k]+phi[i<span class="hljs-number">-1</span>][k]<span class="hljs-number">-2.</span>*phi[i][k])*dy2i<br>                    +(phi[i][k+<span class="hljs-number">1</span>]+phi[i][k<span class="hljs-number">-1</span>]<span class="hljs-number">-2.</span>*phi[i][k])*dx2i;<br>                dphi = dphi*dt;<br>                dphimax0 = max(dphimax0,dphi);<br>                phin[i][k] = phi[i][k]+dphi;<br>            &#125;<br>        &#125;<br>        dphimax = max(dphimax,dphimax0);<br>        <span class="hljs-comment">/* save values */</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; imax; i++)&#123;<br>            <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; kmax; k++)&#123;<br>                phi[i][k] = phin[i][k];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dphimax &lt; eps) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    wt2 = omp_get_wtime();<br>    gettimeofday(&amp;tv2, &amp;tz);<br><br>    <span class="hljs-comment">// print resulting grid and execution time</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nphi after %d iterations\n&quot;</span>, it);<br>    heatpr(phi);<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;wall clock time (omp_get_wtime) = %12.4g sec\n&quot;</span>, wt2-wt1 );<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;wall clock time (gettimeofday) = %12.4g sec\n&quot;</span>, (tv2.tv_sec-tv1.tv_sec) + (tv2.tv_usec-tv1.tv_usec)*<span class="hljs-number">1e-6</span> );<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">output</span>:<br><span class="hljs-attribute">OpenMP</span>-parallel with <span class="hljs-number">1</span> threads<br><br><span class="hljs-attribute">Heat</span> Conduction <span class="hljs-number">2</span>d<br><br><span class="hljs-attribute">dx</span> =      <span class="hljs-number">0</span>.<span class="hljs-number">09091</span>, dy =         <span class="hljs-number">0</span>.<span class="hljs-number">05</span>, dt =     <span class="hljs-number">0</span>.<span class="hljs-number">000625</span>, eps =        <span class="hljs-number">1</span>e-<span class="hljs-number">08</span><br><br><span class="hljs-attribute">start</span> values<br><br><span class="hljs-attribute">columns</span>     <span class="hljs-number">0</span> to     <span class="hljs-number">5</span><br>    <span class="hljs-attribute">0</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     <span class="hljs-number">0</span>.<span class="hljs-number">09091</span>      <span class="hljs-number">0</span>.<span class="hljs-number">1818</span>      <span class="hljs-number">0</span>.<span class="hljs-number">2727</span>      <span class="hljs-number">0</span>.<span class="hljs-number">3636</span>      <span class="hljs-number">0</span>.<span class="hljs-number">4545</span><br>    <span class="hljs-attribute">1</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">2</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">3</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">4</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">5</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">6</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">7</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">8</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">9</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">10</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">11</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">12</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">13</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">14</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">15</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">16</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">17</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">18</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">19</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">20</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     <span class="hljs-number">0</span>.<span class="hljs-number">09091</span>      <span class="hljs-number">0</span>.<span class="hljs-number">1818</span>      <span class="hljs-number">0</span>.<span class="hljs-number">2727</span>      <span class="hljs-number">0</span>.<span class="hljs-number">3636</span>      <span class="hljs-number">0</span>.<span class="hljs-number">4545</span><br><br><span class="hljs-attribute">columns</span>     <span class="hljs-number">6</span> to    <span class="hljs-number">11</span><br>    <span class="hljs-attribute">0</span>       <span class="hljs-number">0</span>.<span class="hljs-number">5455</span>      <span class="hljs-number">0</span>.<span class="hljs-number">6364</span>      <span class="hljs-number">0</span>.<span class="hljs-number">7273</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8182</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9091</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">1</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">2</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">3</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">4</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">5</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">6</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">7</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">8</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">9</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">10</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">11</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">12</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">13</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">14</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">15</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">16</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">17</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">18</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">19</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">20</span>       <span class="hljs-number">0</span>.<span class="hljs-number">5455</span>      <span class="hljs-number">0</span>.<span class="hljs-number">6364</span>      <span class="hljs-number">0</span>.<span class="hljs-number">7273</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8182</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9091</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br><br><span class="hljs-attribute">phi</span> after <span class="hljs-number">20001</span> iterations<br><br><span class="hljs-attribute">columns</span>     <span class="hljs-number">0</span> to     <span class="hljs-number">5</span><br>    <span class="hljs-attribute">0</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     <span class="hljs-number">0</span>.<span class="hljs-number">09091</span>      <span class="hljs-number">0</span>.<span class="hljs-number">1818</span>      <span class="hljs-number">0</span>.<span class="hljs-number">2727</span>      <span class="hljs-number">0</span>.<span class="hljs-number">3636</span>      <span class="hljs-number">0</span>.<span class="hljs-number">4545</span><br>    <span class="hljs-attribute">1</span>       <span class="hljs-number">0</span>.<span class="hljs-number">7221</span>      <span class="hljs-number">0</span>.<span class="hljs-number">6228</span>      <span class="hljs-number">0</span>.<span class="hljs-number">5676</span>      <span class="hljs-number">0</span>.<span class="hljs-number">5485</span>      <span class="hljs-number">0</span>.<span class="hljs-number">5486</span>      <span class="hljs-number">0</span>.<span class="hljs-number">5627</span><br>    <span class="hljs-attribute">2</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9931</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9205</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8659</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8190</span>      <span class="hljs-number">0</span>.<span class="hljs-number">7857</span>      <span class="hljs-number">0</span>.<span class="hljs-number">7628</span><br>    <span class="hljs-attribute">3</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9938</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9943</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9744</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9522</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9280</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9059</span><br>    <span class="hljs-attribute">4</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9945</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9948</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9947</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9892</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9811</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9706</span><br>    <span class="hljs-attribute">5</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9948</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9950</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9948</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9946</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9929</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9900</span><br>    <span class="hljs-attribute">6</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9943</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9944</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9940</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9937</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9934</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9926</span><br>    <span class="hljs-attribute">7</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9925</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9926</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9920</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9915</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9910</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9891</span><br>    <span class="hljs-attribute">8</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9887</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9888</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9880</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9872</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9815</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9732</span><br>    <span class="hljs-attribute">9</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9820</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9822</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9809</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9614</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9395</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9142</span><br>   <span class="hljs-attribute">10</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9705</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9708</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9014</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8486</span>      <span class="hljs-number">0</span>.<span class="hljs-number">7972</span>      <span class="hljs-number">0</span>.<span class="hljs-number">7538</span><br>   <span class="hljs-attribute">11</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9511</span>      <span class="hljs-number">0</span>.<span class="hljs-number">7031</span>      <span class="hljs-number">0</span>.<span class="hljs-number">6056</span>      <span class="hljs-number">0</span>.<span class="hljs-number">5298</span>      <span class="hljs-number">0</span>.<span class="hljs-number">4789</span>      <span class="hljs-number">0</span>.<span class="hljs-number">4396</span><br>   <span class="hljs-attribute">12</span>   <span class="hljs-number">3</span>.<span class="hljs-number">518</span>e-<span class="hljs-number">321</span>  <span class="hljs-number">3</span>.<span class="hljs-number">518</span>e-<span class="hljs-number">321</span>  <span class="hljs-number">3</span>.<span class="hljs-number">518</span>e-<span class="hljs-number">321</span>  <span class="hljs-number">3</span>.<span class="hljs-number">360</span>e-<span class="hljs-number">322</span>  <span class="hljs-number">3</span>.<span class="hljs-number">360</span>e-<span class="hljs-number">322</span>  <span class="hljs-number">1</span>.<span class="hljs-number">976</span>e-<span class="hljs-number">323</span><br>   <span class="hljs-attribute">13</span>   <span class="hljs-number">1</span>.<span class="hljs-number">581</span>e-<span class="hljs-number">322</span>  <span class="hljs-number">3</span>.<span class="hljs-number">953</span>e-<span class="hljs-number">323</span>  <span class="hljs-number">9</span>.<span class="hljs-number">321</span>e-<span class="hljs-number">314</span>  <span class="hljs-number">6</span>.<span class="hljs-number">152</span>e-<span class="hljs-number">320</span>  <span class="hljs-number">6</span>.<span class="hljs-number">152</span>e-<span class="hljs-number">320</span>  <span class="hljs-number">6</span>.<span class="hljs-number">152</span>e-<span class="hljs-number">320</span><br>   <span class="hljs-attribute">14</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>  <span class="hljs-number">7</span>.<span class="hljs-number">905</span>e-<span class="hljs-number">323</span>  <span class="hljs-number">9</span>.<span class="hljs-number">321</span>e-<span class="hljs-number">314</span><br>   <span class="hljs-attribute">15</span>   <span class="hljs-number">4</span>.<span class="hljs-number">941</span>e-<span class="hljs-number">324</span>  <span class="hljs-number">3</span>.<span class="hljs-number">395</span>e-<span class="hljs-number">313</span>  <span class="hljs-number">4</span>.<span class="hljs-number">741</span>e-<span class="hljs-number">307</span>  <span class="hljs-number">1</span>.<span class="hljs-number">008</span>e-<span class="hljs-number">313</span>  <span class="hljs-number">1</span>.<span class="hljs-number">482</span>e-<span class="hljs-number">323</span>  <span class="hljs-number">4</span>.<span class="hljs-number">244</span>e-<span class="hljs-number">313</span><br>   <span class="hljs-attribute">16</span>   <span class="hljs-number">2</span>.<span class="hljs-number">762</span>e-<span class="hljs-number">317</span>  <span class="hljs-number">4</span>.<span class="hljs-number">244</span>e-<span class="hljs-number">314</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>  <span class="hljs-number">6</span>.<span class="hljs-number">953</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">6</span>.<span class="hljs-number">953</span>e-<span class="hljs-number">310</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">17</span>   <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">6</span>.<span class="hljs-number">953</span>e-<span class="hljs-number">310</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>  <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">6</span>.<span class="hljs-number">953</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">6</span>.<span class="hljs-number">953</span>e-<span class="hljs-number">310</span><br>   <span class="hljs-attribute">18</span>   <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">1</span>.<span class="hljs-number">391</span>e-<span class="hljs-number">309</span>  <span class="hljs-number">3</span>.<span class="hljs-number">238</span>e-<span class="hljs-number">319</span>        -nan  <span class="hljs-number">6</span>.<span class="hljs-number">953</span>e-<span class="hljs-number">310</span><br>   <span class="hljs-attribute">19</span>   <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">5</span>.<span class="hljs-number">524</span>e-<span class="hljs-number">315</span>  <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span><br>   <span class="hljs-attribute">20</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     <span class="hljs-number">0</span>.<span class="hljs-number">09091</span>      <span class="hljs-number">0</span>.<span class="hljs-number">1818</span>      <span class="hljs-number">0</span>.<span class="hljs-number">2727</span>      <span class="hljs-number">0</span>.<span class="hljs-number">3636</span>      <span class="hljs-number">0</span>.<span class="hljs-number">4545</span><br><br><span class="hljs-attribute">columns</span>     <span class="hljs-number">6</span> to    <span class="hljs-number">11</span><br>    <span class="hljs-attribute">0</span>       <span class="hljs-number">0</span>.<span class="hljs-number">5455</span>      <span class="hljs-number">0</span>.<span class="hljs-number">6364</span>      <span class="hljs-number">0</span>.<span class="hljs-number">7273</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8182</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9091</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">1</span>       <span class="hljs-number">0</span>.<span class="hljs-number">5864</span>      <span class="hljs-number">0</span>.<span class="hljs-number">6174</span>      <span class="hljs-number">0</span>.<span class="hljs-number">6541</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8215</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9151</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">2</span>       <span class="hljs-number">0</span>.<span class="hljs-number">7493</span>      <span class="hljs-number">0</span>.<span class="hljs-number">7434</span>      <span class="hljs-number">0</span>.<span class="hljs-number">7442</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8472</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9237</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">3</span>       <span class="hljs-number">0</span>.<span class="hljs-number">8865</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8706</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8584</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8809</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9324</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">4</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9592</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9476</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9366</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9058</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9363</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">5</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9857</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9803</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9741</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9122</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9300</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">6</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9910</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9883</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9844</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8945</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9080</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">7</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9859</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9812</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9750</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8455</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8622</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">8</span>       <span class="hljs-number">0</span>.<span class="hljs-number">9622</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9497</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9360</span>      <span class="hljs-number">0</span>.<span class="hljs-number">7524</span>      <span class="hljs-number">0</span>.<span class="hljs-number">7798</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>    <span class="hljs-attribute">9</span>       <span class="hljs-number">0</span>.<span class="hljs-number">8888</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8639</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8401</span>      <span class="hljs-number">0</span>.<span class="hljs-number">5954</span>      <span class="hljs-number">0</span>.<span class="hljs-number">6390</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">10</span>       <span class="hljs-number">0</span>.<span class="hljs-number">7158</span>      <span class="hljs-number">0</span>.<span class="hljs-number">6827</span>      <span class="hljs-number">0</span>.<span class="hljs-number">6536</span>      <span class="hljs-number">0</span>.<span class="hljs-number">3512</span>      <span class="hljs-number">0</span>.<span class="hljs-number">4022</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">11</span>       <span class="hljs-number">0</span>.<span class="hljs-number">4089</span>      <span class="hljs-number">0</span>.<span class="hljs-number">3838</span>      <span class="hljs-number">0</span>.<span class="hljs-number">3629</span>  <span class="hljs-number">3</span>.<span class="hljs-number">953</span>e-<span class="hljs-number">323</span>  <span class="hljs-number">8</span>.<span class="hljs-number">488</span>e-<span class="hljs-number">314</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">12</span>   <span class="hljs-number">9</span>.<span class="hljs-number">321</span>e-<span class="hljs-number">314</span>  <span class="hljs-number">3</span>.<span class="hljs-number">360</span>e-<span class="hljs-number">321</span>  <span class="hljs-number">3</span>.<span class="hljs-number">360</span>e-<span class="hljs-number">321</span>  <span class="hljs-number">3</span>.<span class="hljs-number">360</span>e-<span class="hljs-number">321</span>  <span class="hljs-number">1</span>.<span class="hljs-number">581</span>e-<span class="hljs-number">322</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">13</span>   <span class="hljs-number">1</span>.<span class="hljs-number">087</span>e-<span class="hljs-number">321</span>  <span class="hljs-number">1</span>.<span class="hljs-number">087</span>e-<span class="hljs-number">321</span>  <span class="hljs-number">1</span>.<span class="hljs-number">976</span>e-<span class="hljs-number">323</span>  <span class="hljs-number">1</span>.<span class="hljs-number">356</span>e-<span class="hljs-number">313</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">14</span>   <span class="hljs-number">7</span>.<span class="hljs-number">771</span>e-<span class="hljs-number">320</span>  <span class="hljs-number">9</span>.<span class="hljs-number">794</span>e-<span class="hljs-number">320</span>  <span class="hljs-number">9</span>.<span class="hljs-number">794</span>e-<span class="hljs-number">320</span>  <span class="hljs-number">3</span>.<span class="hljs-number">241</span>e-<span class="hljs-number">321</span>  <span class="hljs-number">3</span>.<span class="hljs-number">241</span>e-<span class="hljs-number">321</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">15</span>   <span class="hljs-number">4</span>.<span class="hljs-number">741</span>e-<span class="hljs-number">307</span>  -<span class="hljs-number">3</span>.<span class="hljs-number">510</span>e-<span class="hljs-number">39</span> -<span class="hljs-number">2</span>.<span class="hljs-number">156</span>e-<span class="hljs-number">126</span>  <span class="hljs-number">1</span>.<span class="hljs-number">026</span>e-<span class="hljs-number">313</span>  <span class="hljs-number">2</span>.<span class="hljs-number">122</span>e-<span class="hljs-number">314</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">16</span>   <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">4</span>.<span class="hljs-number">941</span>e-<span class="hljs-number">324</span>  <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">17</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>  <span class="hljs-number">6</span>.<span class="hljs-number">953</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">6</span>.<span class="hljs-number">953</span>e-<span class="hljs-number">310</span>       <span class="hljs-number">0</span>.<span class="hljs-number">000</span>        -nan       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">18</span>        <span class="hljs-number">0</span>.<span class="hljs-number">000</span>  <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">2</span>.<span class="hljs-number">470</span>e-<span class="hljs-number">323</span>  <span class="hljs-number">1</span>.<span class="hljs-number">061</span>e-<span class="hljs-number">313</span>  <span class="hljs-number">4</span>.<span class="hljs-number">941</span>e-<span class="hljs-number">324</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">19</span>   <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">7</span>.<span class="hljs-number">411</span>e-<span class="hljs-number">323</span>  <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">6</span>.<span class="hljs-number">907</span>e-<span class="hljs-number">310</span>  <span class="hljs-number">1</span>.<span class="hljs-number">109</span>e-<span class="hljs-number">314</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br>   <span class="hljs-attribute">20</span>       <span class="hljs-number">0</span>.<span class="hljs-number">5455</span>      <span class="hljs-number">0</span>.<span class="hljs-number">6364</span>      <span class="hljs-number">0</span>.<span class="hljs-number">7273</span>      <span class="hljs-number">0</span>.<span class="hljs-number">8182</span>      <span class="hljs-number">0</span>.<span class="hljs-number">9091</span>       <span class="hljs-number">1</span>.<span class="hljs-number">000</span><br><span class="hljs-attribute">wall</span> clock time (omp_get_wtime) =      <span class="hljs-number">0</span>.<span class="hljs-number">05844</span> sec<br><span class="hljs-attribute">wall</span> clock time (gettimeofday) =      <span class="hljs-number">0</span>.<span class="hljs-number">05844</span> sec<br></code></pre></td></tr></table></figure><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ol><li><p>进入练习，将代码并行化。</p></li><li><p>将所有的for循环并行化，并使用全局最大值的关键部分。想一想哪些变量应该放在私有子句中。</p></li></ol><p>然后运行这个例子。在1、2、3、4个线程中运行它，看看执行时间。<br>你可能会看到，在更多的线程中，它比预期的要慢。通过观察代码，你是否知道为什么并行版本会慢一些？</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">for (k = 1; k &lt; kmax; k++)&#123;<br>    for (i = 1; i &lt; imax; i++)&#123;<br>        dphi = (phi<span class="hljs-comment">[i+1]</span><span class="hljs-comment">[k]</span>+phi<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[k]</span>-2.*phi<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span>)*dy2i<br>            +(phi<span class="hljs-comment">[i]</span><span class="hljs-comment">[k+1]</span>+phi<span class="hljs-comment">[i]</span><span class="hljs-comment">[k-1]</span>-2.*phi<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span>)*dx2i;<br>        dphi = dphi*dt;<br>        dphimax0 = max(dphimax0,dphi);<br>        phin<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span> = phi<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span>+dphi;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个嵌套循环的顺序是错误的。在C&#x2F;C++中，最后一个数组索引的运行速度是最快的，所以k循环应该是内循环。这个问题在OpenMP编译器中没有得到解决，所以你需要</p><ol start="3"><li>改变嵌套循环的顺序。</li></ol><p>用1、2、3、4个线程再次运行该代码，看看执行时间。<br>现在，并行版本应该会快一点。只有一点改善的原因可能是问题太小，而并行化的开销太大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(i,k,dphi,dphimax0) \</span><br><span class="hljs-meta">        shared(phi,phin,dx2i,dy2i,dt,dphimax)</span><br>        &#123;<br>            dphimax0 = dphimax;<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for</span><br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; imax; i++)&#123;<br>                <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; kmax; k++)&#123;<br>                    dphi = (phi[i+<span class="hljs-number">1</span>][k]+phi[i<span class="hljs-number">-1</span>][k]<span class="hljs-number">-2.</span>*phi[i][k])*dy2i<br>                        +(phi[i][k+<span class="hljs-number">1</span>]+phi[i][k<span class="hljs-number">-1</span>]<span class="hljs-number">-2.</span>*phi[i][k])*dx2i;<br>                    dphi = dphi*dt;<br>                    dphimax0 = max(dphimax0,dphi);<br>                    phin[i][k] = phi[i][k]+dphi;<br>                &#125;<br>            &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp critical</span><br>            &#123;<br>                dphimax = max(dphimax,dphimax0);<br>            &#125;<br>            <span class="hljs-comment">/* save values */</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for</span><br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; imax; i++)&#123;<br>                <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; kmax; k++)&#123;<br>                    phi[i][k] = phin[i][k];<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="七、quiz"><a href="#七、quiz" class="headerlink" title="七、quiz"></a>七、quiz</h3><p><strong>nowait子句的作用是什么？</strong><br>跳到下一个OpenMP构造<br>优先处理下面的OpenMP构造<br>移除前一个构造的同步屏障<br>移除当前构造中的同步屏障✅</p><h2 id="第四节、Tasking"><a href="#第四节、Tasking" class="headerlink" title="第四节、Tasking"></a>第四节、<strong>Tasking</strong></h2><h3 id="一、Tasking-model"><a href="#一、Tasking-model" class="headerlink" title="一、Tasking model"></a>一、Tasking model</h3><p>任务分配允许动态生成工作单元的应用程序的并行化，如递归结构或while循环中。</p><p>在OpenMP中，一个明确的任务是用任务指令定义的。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#pragma omp task<span class="hljs-comment">[clause<span class="hljs-comment">[<span class="hljs-comment">[,]</span>clause]</span>...]</span><br>     structured-block<br></code></pre></td></tr></table></figure><p>任务指令定义了与任务相关的代码和它的数据环境。<strong>当线程遇到一个任务指令时，就会产生一个新的任务。该任务可以立即执行或在稍后的时间执行。</strong>如果任务的执行被推迟，那么该任务就会被放在一个与当前并行区域相关的睡眠任务的概念池中。当前团队中的线程将从池中取出任务并执行它们，直到池中的任务被清空。执行任务的线程可能与最初遇到任务的线程不同。</p><p>与任务结构相关的代码将只被执行一次。如果一个任务从头到尾都是由同一个线程执行的，那么这个任务就被命名为绑定的。如果一个任务的代码可以由一个以上的线程执行，从而使不同的线程执行代码的不同部分，那么这个任务就是不绑定的。<strong>默认情况下，任务是绑定的。</strong></p><p>我们还想提及的是，有几个任务调度点，<strong>一个任务可以从生活状态进入睡眠状态，又从睡眠状态回到生活状态。</strong></p><ul><li>在生成任务中：在任务生成一个显式任务后，可以进入睡眠状态。</li><li>在生成任务中：在任务区域的最后一条指令之后。</li><li>如果任务被解绑：在任务内部的任何地方。</li><li>在隐性和显性障碍中。</li><li>在任务等待中。</li></ul><p>任务的完成可以通过任务同步构造（如taskwait指令）来保证。taskwait构造指定了对当前任务的子任务完成的等待。taskwait构造是一个独立的指令。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#pragma omp taskwait <span class="hljs-comment">[clause<span class="hljs-comment">[ <span class="hljs-comment">[,]</span> clause]</span> ... ]</span><br></code></pre></td></tr></table></figure><h3 id="二、Data-environment"><a href="#二、Data-environment" class="headerlink" title="二、Data environment"></a>二、Data environment</h3><p>有一些额外的条款可以与任务指令一起使用。</p><ul><li><code>untied</code></li></ul><p>如果任务是绑定的，就能保证同一个线程执行该任务的所有部分。所以，不绑定的子句允许代码被多个线程执行。</p><ul><li><code>default (shared | none | private | firstprivate)</code></li></ul><p>Default定义了每个任务中变量的默认数据范围。在一个OpenMP任务指令中只能指定一个默认子句。</p><ul><li><code>shared (list)</code></li></ul><p>Shared声明列表中以逗号分隔的数据变量的范围将在所有线程中共享。</p><ul><li><code>private (list)</code></li></ul><p>Private 声明 list 中的数据变量的范围在每个线程中是私有的。</p><ul><li><code>firstprivate (list)</code></li></ul><p>Firstprivate 声明数据变量的范围在每个线程中都是私有的。每个新的私有对象都用原始变量的值进行初始化。</p><ul><li><code>if (scalar expression)</code></li></ul><p>只有当标量表达式为真时，任务才会被启动，否则就会进行正常的顺序执行。这对良好的负载平衡很有用，但通过总共做有限数量的任务来限制并行化的开销。</p><h3 id="三、Fibonacci-example"><a href="#三、Fibonacci-example" class="headerlink" title="三、Fibonacci example"></a>三、Fibonacci example</h3><p>在下面的例子中，任务的概念被用来递归地计算斐波那契数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file fibonacci.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-type">int</span> x = fib(n - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> y = fib(n - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">8</span>;<br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;fib(%d) = %d\n&quot;</span>, n, fib(n));<br>&#125;<br></code></pre></td></tr></table></figure><p>并行指令被用来定义将由四个线程执行的并行区域。在并行结构中，单指令被用来表示只有一个线程将执行调用fib(n)的打印语句。</p><p>在代码中，使用任务指令生成了两个任务。其中一个任务计算 fib(n-1) ，另一个任务计算 fib(n-2)。然后两个任务的返回值相加，得到fib(n)的返回值。每次调用函数fib(n-1)和fib(n-2)时，都会递归地生成两个任务，直到传递给fib()的参数小于2。</p><p>此外，任务等待指令确保在进入递归计算的新阶段之前，首先完成生成的两个任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file fibonacci.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp task shared(x) firstprivate(n)</span><br>    &#123;<br>        x = fib(n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp task shared(y) firstprivate(n)</span><br>    &#123;<br>        y = fib(n - <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp taskwait</span><br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n_threads = <span class="hljs-number">4</span>;<br>    omp_set_num_threads(n_threads);<br><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">8</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel shared(n)</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp single</span><br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;fib(%d) = %d\n&quot;</span>, n, fib(n));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、Exercise-Traversing-of-a-tree"><a href="#四、Exercise-Traversing-of-a-tree" class="headerlink" title="四、Exercise: Traversing of a tree"></a>四、Exercise: Traversing of a tree</h3><p>下面的练习展示了如何使用显式任务来遍历一个树状结构。<br>在上一步中，我们看了斐波那契的例子，现在我们遍历一个链接列表，在每个节点计算斐波那契数的序列。<br>使用并行区域、任务和其他指令来并行化所提供的程序。然后比较你的解决方案与没有任务的方法的复杂性。</p><p>练习</p><ol><li>转到练习中，将我们为所有节点做处理工作的部分并行化。</li><li>打印线程的数量应该只由主线程完成。想一想还有什么必须由一个线程来完成。</li><li>添加一个任务指令。</li></ol><p>并行化后的结果是否更快？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file solution.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS 38</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> fibdata;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>* <span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">return</span> (n);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      x = fib(n - <span class="hljs-number">1</span>);<br>      y = fib(n - <span class="hljs-number">2</span>);<br>      <span class="hljs-keyword">return</span> x + y;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">processwork</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node* p)</span> <br>&#123;<br>    <span class="hljs-type">int</span> n;<br>    n = p-&gt;data;<br>    p-&gt;fibdata = fib(n);<br>&#125;<br><br><span class="hljs-keyword">struct</span> node* <span class="hljs-title function_">init_list</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node* p)</span> <br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>* <span class="hljs-title">head</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>* <span class="hljs-title">temp</span> =</span> <span class="hljs-literal">NULL</span>;<br><br>    head = (<span class="hljs-keyword">struct</span> node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>    p = head;<br>    p-&gt;data = FS;<br>    p-&gt;fibdata = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt; N; i++) &#123;<br>       temp  = (<span class="hljs-keyword">struct</span> node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>       p-&gt;next = temp;<br>       p = temp;<br>       p-&gt;data = FS + i + <span class="hljs-number">1</span>;<br>       p-&gt;fibdata = i+<span class="hljs-number">1</span>;<br>    &#125;<br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">2</span>;<br>    omp_set_num_threads(num_threads);<br><br>    <span class="hljs-type">double</span> start, end;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">p</span>=</span><span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">temp</span>=</span><span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">head</span>=</span><span class="hljs-literal">NULL</span>;<br><br>    p = init_list(p);<br>    head = p;<br><br>    start = omp_get_wtime();<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel </span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp master</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Threads:      %d\n&quot;</span>, omp_get_num_threads());<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp single</span><br>            &#123;<br>                p=head;<br>                <span class="hljs-keyword">while</span> (p) &#123;<br>                    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp task firstprivate(p) <span class="hljs-comment">//first private is required</span></span><br>                    &#123;<br>                        processwork(p);<br>                    &#125;<br>                  p = p-&gt;next;<br>               &#125;<br>            &#125;<br>    &#125;<br><br>    end = omp_get_wtime();<br>    p = head;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d : %d\n&quot;</span>,p-&gt;data, p-&gt;fibdata);<br>        temp = p-&gt;next;<br>        <span class="hljs-built_in">free</span> (p);<br>        p = temp;<br>    &#125;  <br>    <span class="hljs-built_in">free</span> (p);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Compute Time: %f seconds\n&quot;</span>, end - start);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="X、参考文献-x2F-课程"><a href="#X、参考文献-x2F-课程" class="headerlink" title="X、参考文献&#x2F;课程"></a>X、参考文献&#x2F;课程</h1><ul><li><a href="https://www.futurelearn.com/courses/interactive-hands-on-introduction-to-parallel-programming/1/todo/105942">Introduction to Parallel Programming</a></li><li><a href="https://zhuanlan.zhihu.com/p/488116143">NUMA 的平衡和调度</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MPI</category>
      
      <category>Introduction-to-Parallel-Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction to Parallel Programming</title>
    <link href="/MPI/Introduction-to-Parallel-Programming/Introduction/"/>
    <url>/MPI/Introduction-to-Parallel-Programming/Introduction/</url>
    
    <content type="html"><![CDATA[<h2 id="第一节、Intro-to-parallel-programming"><a href="#第一节、Intro-to-parallel-programming" class="headerlink" title="第一节、Intro to parallel programming"></a>第一节、Intro to parallel programming</h2><h3 id="一、Hello-World"><a href="#一、Hello-World" class="headerlink" title="一、Hello World!"></a>一、Hello World!</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!xx\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span>&#123;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(3)</span><br>    <span class="hljs-built_in">sayHello</span>();    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>output:<br>Hello World!<br>Hello World!xx<br>Hello World!xx<br>Hello World!xx<br></code></pre></td></tr></table></figure><h2 id="第二节、OpenMP-overview"><a href="#第二节、OpenMP-overview" class="headerlink" title="第二节、OpenMP overview"></a>第二节、OpenMP overview</h2><h3 id="一、Brief-intro-to-OpenMP"><a href="#一、Brief-intro-to-OpenMP" class="headerlink" title="一、Brief intro to OpenMP"></a>一、Brief intro to OpenMP</h3><p>OpenMP（Open specifications for Multi Processing）是一个用于共享内存并行计算的API。</p><p>OpenMP API由三个部分组成：</p><ul><li>Compiler Directives（编译器指令）</li><li>Runtime Library Routines（运行时库程序）</li><li>Environment Variables（环境变量）</li></ul><h4 id="编译器指令"><a href="#编译器指令" class="headerlink" title="编译器指令"></a>编译器指令</h4><p>编译器指令是以源代码中的注释形式出现的，只有在指定了适当的编译器标志时，才会在编译时被考虑进去。我们在以下方面使用OpenMP编译器：</p><ul><li>spawning a parallel region（催生一个并行区域）</li><li>dividing blocks of code among threads（在线程之间划分代码块）</li><li>distributing loop iterations between threads（在线程之间分配循环迭代）</li><li>serializing sections of code（串行化代码段）</li><li>synchronization of work among threads（线程之间的工作同步化）</li></ul><p>语法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sentinel</span> directive-name<span class="hljs-meta"> [clause, ...]</span><br></code></pre></td></tr></table></figure><h4 id="运行时库程序"><a href="#运行时库程序" class="headerlink" title="运行时库程序"></a>运行时库程序</h4><p>These routines can be used for:</p><ul><li>setting and querying:<ul><li>number of threads</li><li>dynamic threads feature</li><li>nested parallelism</li></ul></li><li>querying:<ul><li>thread ID</li><li>thread ancestor’s identifier</li><li>thread team size</li><li>wall clock time and resolution</li><li>a parallel region and its level</li></ul></li><li>setting, initializing and terminating:<ul><li>locks</li><li>nested locks</li></ul></li></ul><p>C&#x2F;C++中所有的运行库例程都是子程序，例如，C中查询线程数的运行库例程是一个子程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">omp_get_num_threads</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span><br></code></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>OpenMP环境变量可以通过以下方式在运行时控制并行代码的执行：</p><ul><li>setting:<ul><li>number of threads</li><li>thread stack size</li><li>thread wait policy</li><li>maximum levels of nested parallelism</li></ul></li><li>specifying how loop interations are divided</li><li>binding threads to processors</li><li>enabling&#x2F;disabling:<ul><li>nested parallelism</li><li>dynamic threads</li></ul></li></ul><p>OpenMP环境变量的设置与其他环境变量一样，取决于所使用的shell，例如，你可以在bash中设置OpenMP线程的数量。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">OMP_NUM_THREADS</span>=2<br></code></pre></td></tr></table></figure><p>在csh中则用：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setenv</span> OMP_NUM_THREADS <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="用OpenMP指令编译代码"><a href="#用OpenMP指令编译代码" class="headerlink" title="用OpenMP指令编译代码"></a>用OpenMP指令编译代码</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc hello_world.c -o hello_world -fopenmp<br></code></pre></td></tr></table></figure><p>编译器与对应的编译器标志</p><table><thead><tr><th align="left">Vendor&#x2F;Provider</th><th align="left">Compiler</th><th align="left">Flag</th></tr></thead><tbody><tr><td align="left">GNU</td><td align="left"><code>gcc</code></td><td align="left"><code>-fopenmp</code></td></tr><tr><td align="left"></td><td align="left"><code>g++</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>g77</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>gfortran</code></td><td align="left"></td></tr><tr><td align="left">Intel</td><td align="left"><code>icc</code></td><td align="left"><code>-openmp</code></td></tr><tr><td align="left"></td><td align="left"><code>icpc</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>ifort</code></td><td align="left"></td></tr><tr><td align="left">PGI</td><td align="left"><code>pgcc</code></td><td align="left"><code>-mp</code></td></tr><tr><td align="left"></td><td align="left"><code>pgCC</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>pgf77</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>pgf90</code></td><td align="left"></td></tr></tbody></table><h3 id="二、OpenMP-memory-programming-and-execution-model"><a href="#二、OpenMP-memory-programming-and-execution-model" class="headerlink" title="二、OpenMP memory, programming and execution model"></a>二、OpenMP memory, programming and execution model</h3><p>OpenMP是基于<strong>多处理器或多核机器的共享内存模型</strong>。共享内存类型可以是统一内存访问（UMA）或非统一内存访问（NUMA）。<strong>在OpenMP中，程序完全通过使用线程来完成并行化</strong>，即所谓的基于线程的并行化。</p><p>OpenMP是一种进行 “自动 “并行化的简单方法。实际上，OpenMP是一个显式编程模型，它为用户提供了对并行化的完全控制。尽管从严格意义上讲不是自动的，但并行化只是通过在一个串行程序中插入编译器指令来实现，从而 “自动 “将其转化为一个并行程序</p><p>OpenMP的执行模型的基础是并行执行的<strong>fork-join模型</strong>。</p><p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/hero_f5b1f9fd-0077-43e0-88b-aef0edbf468f.png" alt="OpenMP fork-join"></p><p>OpenMP 术语表:</p><table><thead><tr><th align="left">Term</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">OpenMP thread</td><td align="left">一个由OpenMP指定的运行中的进程</td></tr><tr><td align="left">thread team</td><td align="left">一组合作完成任务的线程</td></tr><tr><td align="left">master thread</td><td align="left">协调各线程的主线程</td></tr><tr><td align="left">thread safety</td><td align="left">指的是多线程的正确执行</td></tr><tr><td align="left">OpenMP directive</td><td align="left">OpenMP编译器的代码行，用于OpenMP的编译器</td></tr><tr><td align="left">construct</td><td align="left">一个OpenMP可执行指令</td></tr><tr><td align="left">clause</td><td align="left">控制执行过程中变量的范围</td></tr></tbody></table><h3 id="三、For-loop"><a href="#三、For-loop" class="headerlink" title="三、For loop"></a>三、For loop</h3><p>在这个例子中，你将学习如何在C语言中使用OpenMP construct（指令名）进行向量加法。</p><p>数组求和示例：&#x2F;&#x2F; 注：parallel和for取名随意，可删？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel shared(a,b,c,chunk) private(i)</span><br>  &#123;<br><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for schedule(dynamic,chunk) nowait</span><br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i &lt;= N; i++)<br>    c[i] = a[i] + b[i];<br><br>  &#125;  <span class="hljs-comment">/* end of parallel section */</span><br></code></pre></td></tr></table></figure><p>让我们详细解释一下这段代码。</p><ul><li>在parallel construct中<ul><li>shared(a,b,c,chunk)子句表示数组a、b、c和变量chunk将被所有线程共享。</li><li>private(i)子句表示变量i对每个线程都是私有的，每个线程都有自己的唯一副本。</li></ul></li><li>在for construct中<ul><li>子句schedule(dynamic,chunk)表示for循环的迭代将按chunk大小动态分布。</li><li>子句nowait表示线程在完成各自的工作后将不进行同步。</li></ul></li></ul><p>完整示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file vector_add.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE 202</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N     2021</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span>&#123;<br><br><span class="hljs-type">int</span> i, chunk;<br><span class="hljs-type">int</span> a[N], b[N], c[N];<br><br><span class="hljs-comment">/* Some initializations */</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i &lt;= N; i++)&#123;<br>  a[i] = i ;<br>  b[i] = <span class="hljs-number">2020</span> - a[i];<br>&#125;<br>chunk = CHUNKSIZE;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel shared(a,b,c,chunk) private(i)</span><br>  &#123;<br><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for schedule(dynamic,chunk) nowait</span><br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i &lt;= N; i++)<br>    c[i] = a[i] + b[i];<br><br>  &#125;  <span class="hljs-comment">/* end of parallel section */</span><br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= N; i++)&#123;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">101</span> == <span class="hljs-number">0</span>)<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d + %d = %d\n&quot;</span>, a[i], b[i], c[i]);<br>    &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>output:<br><span class="hljs-number">101</span> + <span class="hljs-number">1919</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">202</span> + <span class="hljs-number">1818</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">303</span> + <span class="hljs-number">1717</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">404</span> + <span class="hljs-number">1616</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">505</span> + <span class="hljs-number">1515</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">606</span> + <span class="hljs-number">1414</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">707</span> + <span class="hljs-number">1313</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">808</span> + <span class="hljs-number">1212</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">909</span> + <span class="hljs-number">1111</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1010</span> + <span class="hljs-number">1010</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1111</span> + <span class="hljs-number">909</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1212</span> + <span class="hljs-number">808</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1313</span> + <span class="hljs-number">707</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1414</span> + <span class="hljs-number">606</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1515</span> + <span class="hljs-number">505</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1616</span> + <span class="hljs-number">404</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1717</span> + <span class="hljs-number">303</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1818</span> + <span class="hljs-number">202</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">1919</span> + <span class="hljs-number">101</span> = <span class="hljs-number">2020</span><br><span class="hljs-number">2020</span> + <span class="hljs-number">0</span> = <span class="hljs-number">2020</span><br></code></pre></td></tr></table></figure><h3 id="四、Quiz-Intro-to-OpenMP"><a href="#四、Quiz-Intro-to-OpenMP" class="headerlink" title="四、Quiz: Intro to OpenMP"></a>四、Quiz: Intro to OpenMP</h3><p><strong>关于OpenMP执行模型的哪些说法是正确的？</strong><br>线程只能存在于单个进程的资源中。❌<br>线程可以存在于多个进程的资源中。✅<br>线程的最大数量等于处理器核的数量乘以每核可用的线程。✅<br>要使用的线程数不能由用户定义。❌<br>一个主线程是平行执行的，直到遇到第一个顺序区域构造。❌<br>一个主线程是按顺序执行的，直到遇到第一个并行区域结构。✅</p><p><strong>将OpenMP程序的可用线程数设置为4，哪个是正确的方法？</strong><br>在一个OpenMP程序中，使用库函数mp_get_num_threads(4)，在主函数的开始部分将线程数设置为4。❌<br>在一个OpenMP程序中，使用库函数num_threads(4)在主函数的开头将线程数设置为4。❌<br>在bash中，export OMP_NUM_THREADS&#x3D;4。✅<br>在一个OpenMP程序中，使用库函数omp_max_threads(4)在主函数的开始部分将线程数设置为4。❌</p><h2 id="第三节、MPI-overview"><a href="#第三节、MPI-overview" class="headerlink" title="第三节、MPI overview"></a>第三节、MPI overview</h2><h3 id="一、Brief-intro-to-MPI"><a href="#一、Brief-intro-to-MPI" class="headerlink" title="一、Brief intro to MPI"></a>一、Brief intro to MPI</h3><p>消息传递接口（MPI）是一个为开发者和用户提供的消息传递库的规范。<strong>MPI主要解决并行消息传递编程模型</strong>。存在许多开源的MPI实现，它们被用于开发可移植和可扩展的大规模并行应用。</p><p>两个最常用的MPI库实现以及Linux系统的相应编译器：</p><table><thead><tr><th align="left">MPI library</th><th align="left">Language</th><th align="left">Compiler</th></tr></thead><tbody><tr><td align="left">MVAPICH2</td><td align="left">C</td><td align="left"><code>mpicc</code></td></tr><tr><td align="left"></td><td align="left">C++</td><td align="left"><code>mpicxx</code></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>mpic++</code></td></tr><tr><td align="left"></td><td align="left">Fortran</td><td align="left"><code>mpif77</code></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>mpif90</code></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>mpifort</code></td></tr><tr><td align="left">Open MPI</td><td align="left">C</td><td align="left"><code>mpicc</code></td></tr><tr><td align="left"></td><td align="left">C++</td><td align="left"><code>mpiCC</code></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>mpic++</code></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>mpicxx</code></td></tr><tr><td align="left"></td><td align="left">Fortran</td><td align="left"><code>mpif77</code></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>mpif90</code></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>mpifort</code></td></tr></tbody></table><p>消息传递编程范式可以用以下几点来描述。</p><ul><li>数据分布在处理器（核）之间</li><li>每个处理器（核）同时对不同的数据进行操作</li><li>处理器（核）可能需要彼此互动</li></ul><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125161210210.png" alt="image-20221125161210210" style="zoom:50%;"><p>MPI程序中的每个处理器（核）都运行一个子程序，这个子程序在每个处理器（核）上通常是相同的。每个子程序的变量都有相同的名称，但位置和数据不同（分布式内存），即所有变量都是私有的。处理器（核）通过特殊的发送和接收程序（消息传递）进行通信。MPI提供点对点以及集体通信。</p><p><strong>在MPI中，点对点操作通常涉及在两个且仅有两个不同的MPI任务之间进行切换。</strong></p><p>一个任务执行发送操作，而另一个任务执行匹配的接收操作。<br>有不同的发送和接收功能，用于不同的目的，如：</p><ul><li>阻塞式发送&#x2F;阻塞式接收</li><li>非阻塞式发送&#x2F;非阻塞式接收</li><li>缓冲式发送</li><li>联合发送&#x2F;接收</li><li>准备发送</li></ul><h3 id="二、Messages-and-communication"><a href="#二、Messages-and-communication" class="headerlink" title="二、Messages and communication"></a>二、Messages and communication</h3><p>MPI中的通信类型一般与涉及的进程数量有关。最简单的消息传递形式是点对点通信，即一个进程向另一个进程发送消息。在集体通信中，一次有几个进程参与。这种通信有3类：<strong>同步、数据移动和集体计算</strong>。关于操作的完成，存在两种类型：<strong>阻塞和非阻塞操作</strong>。</p><p>信息是在子程序之间移动的数据包。<br><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125162120271.png" alt="image-20221125162120271" style="zoom:50%;"></p><p>一个消息传递系统的必要信息如下。</p><ul><li>数据大小和类型</li><li>发送或接收数据的指针</li><li>发送过程和接收过程，即等级</li><li>消息的标签</li><li>通信器，即MPI_COMM_WORLD</li></ul><h4 id="点对点通信"><a href="#点对点通信" class="headerlink" title="点对点通信"></a>点对点通信</h4><p>这种类型与两个进程之间的通信有关。源进程向目的进程发送一个消息。进程由它们在通信器中的等级来识别。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125162442247.png" alt="image-20221125162442247" style="zoom:50%;"><p><strong>发送和接收信息的阻塞例程（仅在操作完成后返回）。</strong><br>MPI_Send(…)<br>MPI_Recv(…)</p><p><strong>用于发送和接收消息的非阻塞例程（立即返回并允许子程序执行其他工作）。</strong><br>MPI_Isend(…)<br>MPI_Irecv(…)</p><h4 id="集体通信"><a href="#集体通信" class="headerlink" title="集体通信"></a>集体通信</h4><p>集体操作有以下类型：</p><p><strong>同步</strong>：进程等待，直到该组的所有成员都达到同步点<br><strong>数据移动</strong>：广播、分散&#x2F;收集、所有对所有<br><strong>集体计算（还原）</strong>：组中的一个成员从其他成员那里收集数据，并对这些数据进行操作（最小、最大、加、乘……）。</p><p>几个集体通信例子：</p><ol><li><em>Broadcast</em>（广播）<br>广播可以通过使用MPI_Bcast(…)来完成。一个进程向一个通信器中的所有进程发送相同的数据。它可以用来向所有进程发送用户输入或参数。广播的通信模式在下图中描述。</li></ol><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125162702891.png" alt="image-20221125162702891" style="zoom:50%;"><ol start="2"><li><em>Scatter</em>（散射）<br>散射可以通过使用MPI_Scatter(…)来完成。这个操作涉及到一个根进程向通信器中的所有进程发送数据。MPI_Bcast和MPI_Scatter的区别如下。<br>MPI_Bcast向所有进程发送同一条数据<br>MPI_Scatter向不同的进程发送大块的数据：在调用之后，发送方将不同部分发送给所有的进程。</li></ol><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125162753139.png" alt="image-20221125162753139" style="zoom:50%;"><ol start="3"><li><p><em>Gather</em>（聚集）<br>Gather可以通过使用MPI_Gather(…)来完成。这个操作是Scatter的逆向操作：它从许多进程中获取元素，并将它们聚集到一个单一的进程中。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125163927595.png" alt="image-20221125163927595" style="zoom:50%;"></li><li><p><em>Reduce</em><br>减少可以通过使用MPI_Reduce(…)来完成。这个操作在每个进程上接收一个输入元素的数组，并向根进程返回一个输出元素的数组。输出元素包含还原的结果。下面的图片描述了总和还原，即一个有四个整数类型元素的数组被还原成一个有一个元素的数组，包含源数组的元素之和。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125164418123.png" alt="image-20221125164418123" style="zoom:50%;"></li></ol><h3 id="三、Programming-point-of-view"><a href="#三、Programming-point-of-view" class="headerlink" title="三、Programming point of view"></a>三、Programming point of view</h3><p>在这一节，我们将介绍MPI程序的结构，如何编译它们，最后是如何运行它们。</p><h4 id="MPI程序结构"><a href="#MPI程序结构" class="headerlink" title="MPI程序结构"></a>MPI程序结构</h4><p>一个典型的C&#x2F;C++中的MPI程序有如下结构（见下图）：</p><ul><li>包含一个MPI头</li><li>变量和函数的声明，定义原型等。</li><li>带有的主程序。<ul><li>串行代码</li><li>并行代码：MPI环境的初始化，MPI代码（工作、调用等），MPI环境的终止</li></ul></li></ul><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125164615916.png" alt="image-20221125164615916" style="zoom:50%;"><p>An MPI program in C is something like:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>  MPI_Init(<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br><br>  MPI_Xxxxxx(parameter, ...);<br><br>  MPI_Finalize();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个通用的例子中，头文件&lt;mpi.h&gt;被包括在内。MPI是用MPI_Init()初始化的，这个例程必须在任何其他MPI例程之前调用。所有的MPI函数或例程的格式都是MPI_Xxxxxx(参数，…)。MPI是通过MPI_Finalize()来最终确定的。这个例程必须由所有进程最后调用。在它之后，不得再调用任何MPI调用。</p><h4 id="MPI程序的编译"><a href="#MPI程序的编译" class="headerlink" title="MPI程序的编译"></a>MPI程序的编译</h4><p>必须使用支持MPI的合适的编译器或特殊的MPI编译器进行编译，例如，可以使用：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>mpicc hello_world.c -o hello_world<br></code></pre></td></tr></table></figure><p>来编译mpi程序</p><h4 id="运行MPI程序"><a href="#运行MPI程序" class="headerlink" title="运行MPI程序"></a>运行MPI程序</h4><p>要在num个进程（处理器）中运行一个MPI程序prg，应该使用以下命令。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ mpirun -<span class="hljs-built_in">np</span> <span class="hljs-built_in">num</span> ./prg<br></code></pre></td></tr></table></figure><p>例如，如上节所示产生的可执行文件可以用4个进程（处理器）来运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mpirun -np 4 ./hello_world</span><br></code></pre></td></tr></table></figure><h3 id="四、MPI-Hello-World"><a href="#四、MPI-Hello-World" class="headerlink" title="四、MPI Hello World!"></a>四、MPI Hello World!</h3><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221125171557174.png" alt="image-20221125171557174" style="zoom:50%;"><h3 id="五、Quiz-Intro-to-MPI"><a href="#五、Quiz-Intro-to-MPI" class="headerlink" title="五、Quiz: Intro to MPI"></a>五、Quiz: Intro to MPI</h3><p><strong>关于MPI中的点对点通信和集体通信，哪些说法是正确的？</strong><br>在点对点通信中，只有两个处理器参与。✅<br>在点对点通信中，许多处理器可以参与。❌<br>集体通信可以是一对一，一对多，多对一，或多对多的处理器。❌<br>集体通信可以从一个到多个，许多到一个，或许多到许多处理器。✅</p><h2 id="第四节、Accelerators-overview"><a href="#第四节、Accelerators-overview" class="headerlink" title="第四节、Accelerators overview"></a>第四节、Accelerators overview</h2><h3 id="一、Graphics-accelerators"><a href="#一、Graphics-accelerators" class="headerlink" title="一、Graphics accelerators"></a>一、Graphics accelerators</h3><p>图形加速器或图形处理单元（GPU）是具有许多高度并行处理单元（也称为流式多处理器）和非常高带宽内存的设备。有了这两个特点，它们与传统的处理器（CPU）不同。除了它们最初的用途，即用于密集型3D图形渲染（图形应用）外，另一个用途是用于GPGPU（通用图形处理器）计算（科学和工程应用）。</p><p>GPU在高性能计算（HPC）领域的应用越来越多，因为与传统的处理器相比，它们的功率效率要高得多（在超级计算机Top500名单中，Top10中有7个集群使用GPU）。例如，最快的最有效的集群是Perlmutter，它目前在世界超级计算机Top500名单上排名第5（基于Flops的性能指标，即每秒浮点运算），但也在Green500名单上排名第7（基于Flops&#x2F;watt的功率效率指标，即每瓦特每秒浮点运算）。</p><p>在通用计算方面，GPU被称为密集计算任务的加速器。与CPU相比，GPU的主要优势是更大的计算能力和高带宽内存，但另一方面，GPU也以延迟问题而闻名。因此，高效计算算法利用了 “两全其美 “的方法。GPU用于并行任务并实现吞吐性能，而CPU则用于串行任务和低延迟访问。因此，GPU可以被看作是CPU的协处理器，如下图所示。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221127193047421.png" alt="image-20221127193047421" style="zoom:50%;"><p>计算加速可以通过以下方式实现。</p><ul><li>现有的GPU应用程序</li><li>GPU库</li><li>基于指令的方法（如OpenMP和OpenACC）</li><li>特殊编程语言或扩展（如CUDA和OpenCL）。</li></ul><h3 id="二、GPU-Hello-World"><a href="#二、GPU-Hello-World" class="headerlink" title="二、GPU Hello World"></a>二、GPU Hello World</h3><p>被放到GPU上的并行代码是在所谓的内核中运行的。在CUDA C中，我们用__global__前缀来定义一个内核，例如，对于 “Hello World!”的例子，我们可以定义以下内核hello()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以从CPU端调用这个内核，作为一个普通的函数，使用三叉戟语法&lt;&lt;&lt;…&gt;&gt;，例如：。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hello</span>&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&gt;&gt;&gt;();<br></code></pre></td></tr></table></figure><p>在这个语法中，第一个数字表示块的数量，第二个数字表示块中线程的数量，也就是说，在上面的例子中，我们定义了1个有4个线程的块，在一个GPU上并行运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file hello_world.cu<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br>__global__ <span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-comment">// launch the kernel</span><br>    hello&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&gt;&gt;&gt;();<br> <br>    <span class="hljs-comment">// force the printf()s to flush</span><br>    cudaDeviceSynchronize();<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/cuda-10.1/</span>bin:<span class="hljs-variable">$&#123;PATH&#125;</span> nvcc -o hello_cuda_C hello_world.cu &amp;&amp; ./hello_cuda_C<br></code></pre></td></tr></table></figure><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">output:<br>Hello World!<br>Hello World!<br>Hello World!<br>Hello World!<br></code></pre></td></tr></table></figure><h1 id="第二周、OpenMP"><a href="#第二周、OpenMP" class="headerlink" title="第二周、OpenMP"></a>第二周、OpenMP</h1><h2 id="第一节、Getting-started-with-OpenMP"><a href="#第一节、Getting-started-with-OpenMP" class="headerlink" title="第一节、Getting started with OpenMP"></a>第一节、Getting started with OpenMP</h2><h3 id="一、Welcome-to-Week-2"><a href="#一、Welcome-to-Week-2" class="headerlink" title="一、Welcome to Week 2"></a>一、Welcome to Week 2</h3><p>OpenMP是一个共享内存的线程编程模型，可以用来逐步升级现有的代码以实现并行执行。升级后的代码仍然可以进行串行编译。这是OpenMP的一个很大的特点，它让你有机会检查并行执行是否提供了与串行版本相同的结果。为了更好地理解自动并行化，我们首先要看一下运行时函数。在简单的OpenMP程序中通常不需要这些函数。我们将介绍一些基本的编译器或pragma指令和变量的范围，以了解对内存的线程访问逻辑。</p><p>工作共享指令和线程的同步将在几个例子中讨论。如何从线程中收集结果，将用常见的减少条款来说明。在本周结束时，我们将介绍有趣的基于任务的并行化方法。不要忘了用练习来做实验，因为这些是你主要的学习机会。让我们开始吧。<br>本周的结构受到了HLRS OpenMP课程的启发（礼尚往来。Rolf Rabenseifner（HLRS））。</p><h3 id="二、Runtime-functions"><a href="#二、Runtime-functions" class="headerlink" title="二、Runtime functions"></a>二、Runtime functions</h3><p>运行时函数（Runtime functions）的目的是管理或修改我们想在代码中使用的并行进程。它们随OpenMP库而来。</p><p>对于C++和C，你可以添加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> &lt;omp.h</span><br></code></pre></td></tr></table></figure><p>头文件到你的代码的开头，然后这个库包括所有你需要的和你想使用的标准运行时函数。我们今天将在教程中使用的函数可以从成绩单中的链接或资源中获取。</p><ul><li>要设置所需的线程数，使用</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_set_num_threads</span><span class="hljs-params">(n)</span></span><br></code></pre></td></tr></table></figure><p>例如，如果你想用12个线程来并行化你的程序，你可以用函数指定程序中的线程数，比如说</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_set_num_threads</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span><br></code></pre></td></tr></table></figure><ul><li>要返回当前的线程数，请使用</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_get_num_threads</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><ul><li>要返回这个线程的ID，使用</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_get_thread_num</span><span class="hljs-params">()</span></span> <br></code></pre></td></tr></table></figure><ul><li>To return <code>true</code> if inside parallel region, use</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">omp_in_parallel</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>如果它被指定在一个平行区域内，该函数返回true。如果不是，也就是说，如果它被指定在串行区域内，它将返回false。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>Let’s observe the following example.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>    omp_set_num_threads(num_threads);<br>    <span class="hljs-type">int</span> rank;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>    &#123;<br>        rank = omp_get_thread_num();<br>        <span class="hljs-type">int</span> nr_threads = omp_get_num_threads();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am thread %i of %i threads\n&quot;</span>,<br>        rank,<br>        nr_threads);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>花点时间，试着理解上面的代码中发生了什么。</p><ul><li><p>预期的输出是什么？rank和nr_threads的值是多少？</p><p>I am thread 0 of 4 threads</p><p>I am thread 1 of 4 threads</p><p>I am thread 2 of 4 threads</p><p>I am thread 3 of 4 threads</p></li><li><p>输出总是一样的吗？线程的打印顺序是什么？</p><p>不一样，打印顺序应该随机</p></li><li><p>如果我们把线程的数量改为12，会发生什么？</p><p>会打印十二次</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221127203248794.png" alt="image-20221127203248794" style="zoom:50%;"></li></ul><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>使用私有变量设置线程数</p><h3 id="三、Variables-and-constructs"><a href="#三、Variables-and-constructs" class="headerlink" title="三、Variables and constructs"></a>三、Variables and constructs</h3><h4 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h4><p>接下来我们要看的是环境变量。与运行时函数相反，环境变量不是在代码中使用的，而是在环境中指定的，在那里你正在编译和运行你的代码。环境变量的目的是为了在运行时控制并行程序的执行。由于这些变量不是在代码中指定的，你可以在编译和运行你的程序之前，例如在Linux终端指定它们。让我们来看看三个最常见的环境变量：</p><ul><li><strong>指定要使用的线程数</strong></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">OMP_NUM_THREADS</span>=4<br></code></pre></td></tr></table></figure><ul><li><strong>指定线程应该放在哪个CPU上，可以使用</strong></li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">OMP_PLACES</span> <br></code></pre></td></tr></table></figure><ul><li><strong>要显示OpenMP的版本和环境，使用</strong></li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">OMP_DISPLAY_ENV</span>  <br></code></pre></td></tr></table></figure><h4 id="Parallel-constructs"><a href="#Parallel-constructs" class="headerlink" title="Parallel constructs"></a>Parallel constructs</h4><p>并行结构是使用OpenMP时的基本结构。所以，每个线程基本上都同时执行平行区域内的相同语句，正如你在这张图片上看到的。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221128153335944.png" alt="image-20221128153335944" style="zoom:50%;"><p>所以，首先我们有一个主线程，执行代码的串行部分。然后我们来到了一个pragma omp语句。我们在这里可以看到，主线程首先遇到了这个omp结构，并创建了多个线程，也就是我们所说的并行运行的从线程。随后，主线程和从线程在彼此之间划分了任务。最后，我们指定了一个隐含的障碍，所以当达到这个障碍时，线程结束，我们等待所有线程完成执行。在这之后，当所有的线程都完成了执行，我们回到主线程，最终恢复代码的执行。当然，在这一步骤中，从属线程已经消失了，因为它们已经完成了自己的任务。</p><p>在C语言中，这个隐含的屏障被指定为</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>&#123;<br>...<br> &#125;<br></code></pre></td></tr></table></figure><p>Let’s observe the following code.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span> <br>&#123;<br>  <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>  omp_set_num_threads(num_threads);<br>  <span class="hljs-type">int</span> rank;<br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>  &#123;<br>  rank = omp_get_thread_num();<br>  <span class="hljs-type">int</span> nr_threads = omp_get_num_threads();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am thread %i of %i threads\n&quot;</span>,<br> rank,<br> nr_threads);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、Clauses-and-directive-format"><a href="#四、Clauses-and-directive-format" class="headerlink" title="四、Clauses and directive format"></a>四、Clauses and directive format</h3><h4 id="Directive-format（指令格式）"><a href="#Directive-format（指令格式）" class="headerlink" title="Directive format（指令格式）"></a>Directive format（指令格式）</h4><p>到目前为止，我们只是指定了一个并行区域，并且代码是以串行方式执行的。现在我们将继续前进，看看OpenMP的指令。使用指令的格式如下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp directive_name [clause[clause]...]</span><br></code></pre></td></tr></table></figure><p>我们已经看到并使用了pragma omp parallel，它是一个并行执行区域的指令。在这种格式中，我们也有一些子句，以指定不同的参数。例如，私有变量是指对每个线程都是私有的变量，而共享变量是指对所有线程共享的变量，任何线程都可以访问和修改它。</p><p>我们将在下面的小节中更多地探讨这些条款。现在，我们将学习一下条件语句。与任何编程语言类似，OpenMP也有条件语句。因此，举例来说，我们也可以在OpenMP中以如下方式指定一个if语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _OPENMP</span><br><span class="hljs-comment">//block of code to be executed if code was compiled with OpenMP, for example</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Number of threads: %d&quot;</span>, omp_get_num_threads);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">//block of code to be executed if code was compiled without OpenMP</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>下面的例子说明了条件编译的使用。通过OpenMP编译，_OPENMP被定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span> <br>&#123;<br>  <span class="hljs-type">int</span> rank;<br>  <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _OPENMP</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(4) private(rank)</span><br>  &#123;<br>    rank = omp_get_thread_num();<br>    <span class="hljs-type">int</span> nr_threads = omp_get_num_threads();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am thread %i of %i threads\n&quot;</span>,<br>   rank,<br>   nr_threads);<br>  &#125;<br>  <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This program is not compiled with OpenMP\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><blockquote><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ gcc example.c<br>This program is not compiled with OpenMP<br><br>$ gcc -fopenmp example.c<br>I am thread<span class="hljs-number"> 3 </span>of<span class="hljs-number"> 4 </span>threads<br>I am thread<span class="hljs-number"> 2 </span>of<span class="hljs-number"> 4 </span>threads<br>I am thread<span class="hljs-number"> 1 </span>of<span class="hljs-number"> 4 </span>threads<br>I am thread<span class="hljs-number"> 0 </span>of<span class="hljs-number"> 4 </span>threads<br></code></pre></td></tr></table></figure></blockquote></blockquote><h4 id="Clauses（条款）"><a href="#Clauses（条款）" class="headerlink" title="Clauses（条款）"></a>Clauses（条款）</h4><p>我们刚刚学习的指令格式</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp directive_name [clause[clause]...]</span><br></code></pre></td></tr></table></figure><p>是OpenMP的一个重要的关键字，我们把它放在代码的开头，放在我们想让并行区域开始的那一行，然后我们提到指令名称和子句。在本小节中，我们将学习条款。</p><p>基本上有两种条款，即：私有或共享。一个私有变量将是一个对每个线程都是私有的变量。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221128155745412.png" alt="image-20221128155745412" style="zoom:50%;"><p>So, we execute, e.g.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> A;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(A)</span><br>&#123;<br>    A=<span class="hljs-built_in">omp_get_thread_num</span>();<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们在C代码中定义了一个整数A。然后我们定义了OpenMP指令，omp parallel和private A。因此，这里发生的情况是，任何时候我们都会得到一个新的线程，这个变量A将被单独分配给每个线程。这意味着，A的值将与线程的数量有关。因此，在第一个线程中，它将是0，在第二个线程中，这个变量的值将是1，因为这将是线程的ID，在第三个线程中的值将是2，以此类推。我们可以清楚地看到，这些变量基本上是私有的，这意味着它们存在于每个线程中。这意味着，第一个线程中的变量A（0）不能被第二个线程中的变量A（1）访问。所以，这就推断出这个变量对我们程序中的每个单独的线程来说基本上是私有的。当然，与此相反的是共享变量。如果我们指定一个变量是共享变量，这将标志着该变量将在线程之间共享。如果我们在并行区域之外指定该变量，那么就在</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br></code></pre></td></tr></table></figure><p>这个变量将被每个线程访问。举例来说，如果我们有一个for循环，并且我们在每次迭代中都向它添加一个数字，我们可以直接指定它为一个共享变量。在这种情况下，每当任何线程更新共享变量时，它都会向其中添加数字。这是一种使用for循环的适当方式，我们将在下面的小节中看到。<br>因此，总结一下，私有和共享的区别：私有变量只对一个线程可用，不能被其他任何线程访问，而共享变量不仅可以被程序中的每个线程访问，而且还可以被每个线程同时更新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span> <br>&#123;<br>  <span class="hljs-type">int</span> num_threads = <span class="hljs-number">10</span>;<br>  omp_set_num_threads(num_threads);<br><br>  <span class="hljs-type">int</span> private_var = <span class="hljs-number">1000</span>;<br>  <span class="hljs-type">int</span> shared_var = <span class="hljs-number">5000</span>;<br>  <span class="hljs-type">int</span> rank;<br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(private_var, rank) shared(shared_var)</span><br>  &#123;<br>    rank = omp_get_thread_num();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread ID is: %d\n&quot;</span>, rank);  <br>    private_var = private_var + num_threads;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of private_var is: %d\n&quot;</span>, private_var);<br>    shared_var = shared_var + num_threads;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of shared_var is: %d\n&quot;</span>, shared_var);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的代码并观察输出。当被不同的线程访问时，私有和共享变量的值如何变化？当被多个线程修改时，共享变量的值是否增加？为什么？</p><p>被不同线程访问时私有变量private_var初始值不变，共享变量初始值shared_var会改变。</p><p><strong>多个线程修改时，共享变量的值不一定增加，可能发生并发修改and修改丢失。</strong>❌</p><p>这里可能还存在一个竞赛条件。并行区域内的变量的写入和立即读取是一个写-读竞赛条件。两个或多个线程访问同一个共享变量并对其进行修改，这些访问是不同步的。我们将在并行区域练习中看到一个更清晰的竞赛条件的例子。</p><p>！！结果显示，并没有发生并发问题</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">5</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5010</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">8</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5020</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5030</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5040</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">9</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5050</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">2</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5060</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">6</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5070</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">4</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5080</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">3</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5090</span><br><span class="hljs-attr">Thread ID is:</span> <span class="hljs-number">7</span><br><span class="hljs-attr">Value of private_var is:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">Value of shared_var is:</span> <span class="hljs-number">5100</span><br></code></pre></td></tr></table></figure><h3 id="五、Clauses"><a href="#五、Clauses" class="headerlink" title="五、Clauses"></a>五、Clauses</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">4</span>;<br>    omp_set_num_threads(num_threads);<br><br>    <span class="hljs-type">int</span> private_var = <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">int</span> shared_var = <span class="hljs-number">5000</span>;<br>    <span class="hljs-type">int</span> rank;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(private_var) shared(shared_var)</span><br>    &#123;<br>        rank = omp_get_thread_num();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread ID is: %d\n&quot;</span>, rank);  <br>        private_var = private_var + num_threads;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of private_var is: %d\n&quot;</span>, private_var);<br>        shared_var = shared_var + num_threads;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of shared_var is: %d\n&quot;</span>, shared_var);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>花点时间，试着理解上面的代码中发生了什么。</p><ul><li><p>当被不同的线程访问时，私有和共享变量的值如何变化？</p><p>被不同线程访问时私有变量private_var初始值不变（<strong>为0！</strong>），共享变量初始值shared_var会改变。</p></li><li><p>当被多个线程修改时，共享变量的值是否增加？为什么？</p><p><strong>多个线程修改时，共享变量的值不一定增加，可能发生并发修改and修改丢失？</strong></p><p><strong>运行没有出现这个现象，但是助教在评论中提到了会出现race condition</strong> </p></li><li><p>当被多个线程修改时，私有变量的值是否会增加？</p></li></ul><p>现在去做练习，试一试，检查你的答案是否正确。</p><h3 id="六、Parallel-region"><a href="#六、Parallel-region" class="headerlink" title="六、Parallel region"></a>六、Parallel region</h3><p>在这个练习中，你将得到练习使用基本的运行时函数、指令格式、并行结构和条款，这些都是我们到目前为止学到的。</p><p>这个练习的代码在Jupyter笔记本的以下说明中。你将从这个提供的Hello world模板开始。预期的输出是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    i = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world %d\n&quot;</span>, i );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><ol><li>进入练习，使用其中一个运行时函数将所需的线程数设置为4。✅</li><li>使用其中一个运行时函数将变量i设置为该线程的ID。✅</li><li>添加一个并行区域，使代码并行运行。✅</li><li>在包含OpenMP头文件和使用运行时函数时，添加OpenMP条件条款。✅</li></ol><p>在你运行这个程序之前，你认为会发生什么？<br>现在，运行该程序并观察输出。你可以将线程数改为12个或其他，观察输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file exercise.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br><br>    i = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> num_threads = <span class="hljs-number">12</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _OPENMP</span><br>    omp_set_num_threads(num_threads);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel </span><br>    &#123;<br>        i = omp_get_thread_num();<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world openmp %d\n&quot;</span>, i );<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world gcc %d\n&quot;</span>, i );<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221128210815541.png" alt="image-20221128210815541" style="zoom:50%;"><ol><li>为变量i的并行区域添加一个私有子句。</li></ol><p>会发生什么？观察输出的差异。为什么输出会不同？检查你是否得到一个竞赛条件。</p><p>竞赛条件(Race condition):</p><ul><li>两个线程访问同一个共享变量，并且至少有一个线程修改了该变量，并且访问没有同步化。</li><li>程序的结果取决于团队中各线程的时间。</li><li>这是由非故意的数据共享造成的。</li></ul><p><strong>不要担心你是否总是得到正确的输出，因为编译器可能在每个线程上使用一个私有寄存器，而不是直接写入内存中</strong></p><ul><li>If compiled with OpenMP, the program should output »hello world« and the ID of each thread.</li></ul><h2 id="第二节、Worksharing-directives（工作共享指令）"><a href="#第二节、Worksharing-directives（工作共享指令）" class="headerlink" title="第二节、Worksharing directives（工作共享指令）"></a>第二节、Worksharing directives（工作共享指令）</h2><h3 id="一、Which-thread-executes-which-statement-or-operation"><a href="#一、Which-thread-executes-which-statement-or-operation" class="headerlink" title="一、Which thread executes which statement or operation?"></a>一、Which thread executes which statement or operation?</h3><p>在下面的步骤中，我们要学习如何真正地平行组织我们的工作。请分享你对我们如何实现这一目标的想法。</p><p>你知道有哪些可能的并行组织工作的方法吗？如何在线程之间分配操作？有什么方法可以控制线程的顺序吗？</p><h3 id="二、OpenMP-constructs"><a href="#二、OpenMP-constructs" class="headerlink" title="二、OpenMP constructs"></a>二、OpenMP constructs</h3><h4 id="Worksharing-constructs（工作共享结构）"><a href="#Worksharing-constructs（工作共享结构）" class="headerlink" title="Worksharing constructs（工作共享结构）"></a>Worksharing constructs（工作共享结构）</h4><p>工作共享结构将代码区域的执行在团队线程的不同成员之间进行划分。这些结构不启动新的线程，它们被动态地包围在并行区域内。工作共享结构体的一些例子是。</p><ul><li>sections</li><li>for</li><li>task</li><li>single</li></ul><h4 id="Section-construct"><a href="#Section-construct" class="headerlink" title="Section construct"></a>Section construct</h4><p>我们首先将看到一个使用section结构的代码例子，我们可以通过指令性的section来指定它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp sections</span><br>    &#123;<br>      <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>      &#123;<br>        function_1();<span class="hljs-comment">// a=... b=...</span><br>      &#125;<br>      <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>      &#123; <br>        function_2();<span class="hljs-comment">// c=... d=...</span><br>      &#125;<br>    &#125;<br>&#125;<span class="hljs-comment">// end of parallel</span><br></code></pre></td></tr></table></figure><p>当我们使用section结构时，多个代码块被并行执行。当我们指定章节并将一个任务放入其中时，这个特定的任务将在一个线程中执行。然后，当我们进入另一个部分时，它将在不同的线程中执行其任务。这样，我们就可以在pragma omp并行代码中添加这些部分，为每个线程指定一个部分，这些部分将在每个单独的线程中执行。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221128212103284.png" alt="image-20221128212103284" style="zoom:50%;"><p>在上面的示例代码中，我们可以看到，在这一节中，我们指定了变量a和b。当这段代码被执行时，一个新的线程会带着这些变量产生，同样的，变量c和d也被指定在不同的一节中，因此也在不同的线程中。</p><p>Eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c">%%file sections.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">function_1</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Function 1 done by thread %d \n&quot;</span> , omp_get_thread_num());<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">function_2</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j != <span class="hljs-number">2</span>; j++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Function 2 done by thread %d \n&quot;</span> , omp_get_thread_num());<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>; <span class="hljs-comment">//number of threads</span><br>    omp_set_num_threads(n);<br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp sections</span><br>        &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>            &#123;<br>                function_1();<br>            &#125;<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp section</span><br>            &#123; <br>                function_2();<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br>output:<br>Function <span class="hljs-number">2</span> done by thread <span class="hljs-number">0</span> <br>Function <span class="hljs-number">2</span> done by thread <span class="hljs-number">0</span> <br>Function <span class="hljs-number">1</span> done by thread <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="For-construct"><a href="#For-construct" class="headerlink" title="For construct"></a>For construct</h4><p>在计算机科学中，for-loop是一个指定迭代的控制流语句。这使得代码可以被反复执行。这样的任务，动作相似，多次执行，也可以被并行化。在OpenMP中，我们可以使用#pragma omp中的for结构。简单地说，for结构可以被看作是一个并行化的for循环。我们可以将for结构指定为</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#pragma omp for <span class="hljs-comment">[clause<span class="hljs-comment">[<span class="hljs-comment">[,]</span>clause]</span>...]</span><br></code></pre></td></tr></table></figure><p>这里我们也是以pragma omp开始，后面是for关键字，我们可以再次使用不同的子句，即私有的、共享的等等。相应的for-loop必须有一个规范的形状。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (int i<span class="hljs-operator">=</span>it<span class="hljs-comment">; i&lt;M; i++)</span><br></code></pre></td></tr></table></figure><p>由于每个迭代器默认是一个私有变量，并且只由一个线程共享，所以迭代器在循环体中不会被修改。如果它被每个线程访问，我们的for-loop就会被破坏。</p><p>除了private，我们还有一些其他的子句。比如说。</p><ul><li>schedule。它对循环的迭代如何在线程之间分配进行分类。</li><li>collapse(n)。n个循环的迭代被折叠成一个更大的迭代空间。</li></ul><p>我们可以看到代码中使用for结构的一个例子。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel private(f)</span><br>&#123;<br>    f=<span class="hljs-number">10</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>        a[i] = b[i]*f;<br>    &#125; <span class="hljs-comment">// end of for</span><br>&#125; <span class="hljs-comment">// end of parallel</span><br></code></pre></td></tr></table></figure><p>我们用pragma omp parallel开始，然后是名为f的私有变量。然后我们用pragma omp for构造，接着是一个从0到10的for循环（10次不同的迭代）。然后，私有变量f在每个线程中都是固定的，列表a被并行更新。这是因为每个数组需要的索引都是不同的。所以，每个线程只能访问数组的一个地方，允许我们并行更新这个列表。</p><img src="/MPI/Introduction-to-Parallel-Programming/Introduction/image-20221128212831945.png" alt="image-20221128212831945" style="zoom:50%;"><p>在这里我们可以看到，如果我们在两个线程上工作，有10个迭代，那么这些迭代将被分成两个线程，分别从0到4和5到9。列表a上的每个地方都将被自己更新，由于迭代器是相互独立的，它们只修改一个地方，所以我们可以很容易地更新列表a的每个地方。</p><p>Eg:</p><pre><code class="hljs">%%file forloop.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;omp.h&gt;int main()&#123;    int n = 4; //number of threads    omp_set_num_threads(n);int* iterations; //count iterations for each threaditerations = (int *) malloc (n*sizeof(int));int f = 100;//set array values to 0for(int loop = 0; loop &lt; n; loop++)&#123;    iterations[loop] = 0;&#125;#pragma omp parallel shared(iterations, f)&#123;        #pragma omp for     for (int i = 0; i &lt; f; i++)    &#123;        iterations[omp_get_thread_num()]++;    &#125;&#125;for(int loop = 0; loop &lt; n; loop++)&#123;    printf(&quot;%d &quot;, iterations[loop]);&#125;free(iterations);&#125;</code></pre><h1 id="X、参考文献-x2F-课程"><a href="#X、参考文献-x2F-课程" class="headerlink" title="X、参考文献&#x2F;课程"></a>X、参考文献&#x2F;课程</h1><ul><li><a href="https://www.futurelearn.com/courses/interactive-hands-on-introduction-to-parallel-programming/1/todo/105942">Introduction to Parallel Programming</a></li><li>[NUMA 的平衡和调度](</li></ul>]]></content>
    
    
    <categories>
      
      <category>MPI</category>
      
      <category>Introduction-to-Parallel-Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并行编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI和Cuda学习</title>
    <link href="/MPI/MPI%20and%20Cuda/"/>
    <url>/MPI/MPI%20and%20Cuda/</url>
    
    <content type="html"><![CDATA[<p>一、基本介绍</p><p>X、参考文献</p><ul><li><a href="https://www.bilibili.com/video/BV16b4y1E74f/?spm_id_from=333.337.search-card.all.click&vd_source=fb926f3550cd847435afc066c3343d2e">（b站）CUDA在现代C++中如何运用？看这一个就够了！</a></li><li><a href="https://blog.csdn.net/Rong_Toa/article/details/77871833">Mpi与Cuda混合编程（Makefile）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MPI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
      <tag>CUDA</tag>
      
      <tag>并行编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka</title>
    <link href="/Architecture/kafka/"/>
    <url>/Architecture/kafka/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>消息驱动</title>
    <link href="/Architecture/event-streaming/"/>
    <url>/Architecture/event-streaming/</url>
    
    <content type="html"><![CDATA[<p><img src="/Architecture/event-streaming/385fb2888d6446749de2016e0cdaf521.png" alt="Kafka的通信流程梳理"></p><ol><li>怎么记录数据的类型</li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/506577165">“消息驱动、事件驱动、流 ”基础概念解析</a></li><li><a href="https://blog.csdn.net/LemonSnm/article/details/125325163">分布式消息中间件设计</a></li><li><a href="https://www.jianshu.com/p/f13844f815f0">深入理解Kafka事件流（Event Streaming）平台（一）</a></li><li><a href="https://blog.csdn.net/m0_65931372/article/details/125971395">kafka简介</a></li><li><a href="https://blog.csdn.net/pass_JMC/article/details/126716003">Kafka全面学习</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试问题</title>
    <link href="/others/problems/"/>
    <url>/others/problems/</url>
    
    <content type="html"><![CDATA[<p><strong>每个问题请展开五到十分钟的回答</strong></p><h2 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h2><h3 id="RPC项目"><a href="#RPC项目" class="headerlink" title="RPC项目"></a>RPC项目</h3><ol><li><p>简单介绍一下这个项目***</p></li><li><p>服务的发布与获取流程***</p></li><li><p>为什么要做这个项目***</p></li><li><p>什么是RPC</p></li><li><p>一个RPC框架需要一些什么内容</p></li><li><p>这个框架和其他的RPC框架有什么区别</p></li><li><p>是否进行过性能测试</p></li><li><p>在做项目的过程中遇到过什么问题***</p></li><li><p>项目中难点哪里</p></li><li><p>项目中同步与并发是如何实现的</p></li><li><p>RPC项目是怎么设计编码的</p></li><li><p>用的什么序列化框架</p></li><li><p>简单介绍一下netty</p></li><li><p>NIO和BIO有什么区别***</p></li><li><p>什么是IO多路复用*******</p></li><li><p>select、poll、epoll有什么区别****</p></li><li><p>NIO是水平触发还是边缘触发</p></li><li><p>注册中心是用的什么做的</p></li><li><p>如何用zookeeper实现注册中心***</p></li><li><p>如何保持客户端与服务端通信***</p></li><li><p>服务变更（上下线）如何通知客户端</p></li><li><p>负载均衡如何做的</p></li><li><p>你知道一些什么负载均衡算法</p></li><li><p>CAP理论知道吗</p></li><li><p>zookeeper是AP系统还是CP系统</p></li><li><p>这个框架是AP系统还是CP系统，为什么</p></li><li><p>如何保持通信</p></li><li><p>介绍一下Reactor模型</p></li><li><p>rpc与http的区别***</p></li><li><p>zookeeper的主从状态怎么传播</p></li><li><p>zookeeper主节点宕机如何处理</p></li><li><p>服务调用是同步还是异步的</p></li><li><p>项目中用到了线程池吗，怎么用的</p></li><li><p>有服务的自动化编码过程吗？（如thrift通过idl生成api）</p></li><li><p>如何发现服务宕机</p></li></ol><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol><li><p>进程和线程区别</p></li><li><p>什么是协程，与进程和线程有什么区别</p></li><li><p>操作系统层面怎么判断是否发生了死锁</p><p>资源分配图and gdb</p></li><li><p>进程调度策略</p></li><li><p>死锁概念：什么是死锁，产生原因，必要条件，死锁检测等</p></li><li><p>操作系统5种IO模型 and java3种IO模型</p></li><li><p>操作系统的虚拟内存机制（从虚拟地址空间到物理地址空间怎么做到的？底层？地址翻译？）</p></li><li><p>引用空指针会导致segment fault，此时操作系统背后做了什么？</p></li><li><p>知道mmap嘛？</p><p>1）调用mmap是将文件的内容拷贝到进程的地址空间去了嘛？</p><p>2）mmap涉及磁盘的IO么？</p><p>3）mmap映射动作，会去读映射的文件嘛？</p><p>4）mmap操作会返回一个指针，访问指针会发生什么？</p></li><li><p>什么是缺页异常</p></li><li><p>遍历数组和链表性能为什么差那么多（缓存行相关概念）</p></li><li><p>使用fprintf时操作系统做了什么？（c++）</p></li><li><p>什么是线程安全？</p></li><li><p>什么情况会导致线程不安全</p></li><li><p>可执行文件加载到内存中，描述地址分配情况（可执行程序的空间分布）</p></li><li><p>动态库和静态库的区别（动态库优点）（c++）</p></li><li><p>进程间通信方式</p></li><li><p>缓存溢出概念</p></li><li><p>linux命令，网络端口占用</p></li><li><p>进程的组成</p></li><li><p>进程切换哪些资源需要保存</p></li><li><p>线程和协程的切换需要内核态的参与吗？具体描述</p></li><li><p>什么是叶表？为什么要有页表？</p></li><li><p>虚拟内存</p></li><li><p>进程间通信、线程间通信的方式</p></li><li><p>cache line大小</p></li><li><p>进程&#x2F;线程&#x2F;协程上下文切换，数据有哪些，是一样的嘛？</p></li><li><p>如何malloc申请1G，那这1G是立即可以使用的嘛？（c++）</p></li><li><p>哪些情况下，会从用户态切换到内核态</p></li><li><p>如果在协程上做了阻塞IO，会有什么问题？</p></li><li><p>计算机怎么存储浮点数</p></li><li><p>计算机怎么存储负数</p></li><li><p>原码、反码、补码</p></li><li><p>a &#x3D; b + c</p><p>1）变量怎么获取数据，操作系统寻址过程</p><p>2）怎么由操作系统提交到CPU执行</p></li><li><p>虚拟地址</p><p>1）概念</p><p>2）如何转换</p></li><li><p>段式管理和页式管理</p></li><li><p>MMU如何进行翻译-&gt;页表结构&#x2F;多级页表</p></li><li><p>源代码到可执行文件的过程</p></li><li><p>进程间同步手段（提到了互斥锁，问不同进程怎么访问同一个互斥锁）</p></li><li><p>静态库与动态库优缺点</p></li><li><p>堆栈写爆了</p></li><li><p>socket和管道区别</p></li><li><p>局部性原理会在计算机的哪些机制下生效</p></li><li><p>Linux文件系统的权限模型设计</p></li><li><p>对于目录来说，执行权限有哪些</p></li><li><p>多线程开发注意点</p></li><li><p>epoll使用限制&#x2F;缺点</p></li><li><p>Linux下有epoll，Windows下有么？</p></li><li><p>协程最终是附着在进程还是线程？</p></li><li><p>协程为什么比线程快？为什么支持高并发</p></li><li><p>线程上下文切换的开销体现在哪？</p></li><li><p>进程&#x2F;线程上下文切换，哪些数据需要切换？切换之后数据保存在哪里？</p></li><li><p>两个线程交替打印1至100</p></li><li><p>线程有几种状态</p></li><li><p>怎么让一个线程销毁？</p></li><li><p>如何主动关闭一个线程？</p></li><li><p>什么是零拷贝？</p></li><li><p>mmap和sendfile有什么区别？</p></li><li><p>变量分配在堆和栈有什么区别么？</p></li><li><p>分页的页面大小，可以改么？怎么改？</p></li><li><p>页面置换算法</p></li><li><p>CPU密集和IO密集</p></li><li><p>提高服务器并发能力的方法论</p></li><li><p>Linux使用哪种方法进行进程调度</p></li><li><p>阻塞IO和非阻塞IO</p></li><li><p>同步和异步</p></li><li><p>中断、陷阱</p></li></ol><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol><li><p>TCP三次握手过程</p></li><li><p>HTTP中GET和POST区别</p></li><li><p>TCP与UDP区别</p></li><li><p>IO多路复用</p></li><li><p>介绍一下select，优缺点</p></li><li><p>epoll种LT与ET区别</p></li><li><p>epoll基本原理</p></li><li><p>epoll中红黑树和链表怎么协作？</p><p>1）如何从红黑树到双向链表？</p><p>2）节点会同时存在红黑树和链表里面嘛？</p></li><li><p>浏览器输入baidu.com发生了什么</p><p>1）IP头部中，源IP和目的IP怎么填？（内容）</p><p>2）MAC头部中，源MAC地址和目的MAC怎么填？（主机怎么判断，同局域网和不同局域网）</p><p>3）路由器如何转发，会对包进行何种改变？</p><p>4）交换机会做什么改动？</p></li><li><p>http和https区别</p></li><li><p>http https双重加密</p></li><li><p>TCP四次挥手</p></li><li><p>TCP协议如何保证可靠传输</p></li><li><p>TCP网络拥塞算法</p></li><li><p>Linux有多少个端口可用？是否可能被占满？</p></li><li><p>cookie和session区别，使用场景</p><p>（17～29阿里云二面）</p></li><li><p>HTTP协议里面内容（比如什么字段决定传输的内容，文本&#x2F;图片？）</p></li><li><p>OSI的七层和五层协议的区别，为什么实际用的是五层协议</p></li><li><p>wireshark和tcpdump抓包</p></li><li><p>如何判断包是否是乱序的？</p></li><li><p>随机序列号对应于头部哪个字段</p></li><li><p>如何传输大报文？（5000数据，但MTU只有1500）</p></li><li><p>第一个报文和第二个报文头的字段说一下</p></li><li><p>会有IP分片嘛？IP头部</p></li><li><p>应用层传输UDP报文，过程说一下，和TCP有什么区别嘛？怎么进行分割的？</p></li><li><p>IP哪个字段确定是否分片？</p></li><li><p>多个报文如何进行合并（组成发送的数据）</p></li><li><p>IP层路由默认路由没有了，会影响上网或访问同一局域网的机器嘛？</p></li><li><p>同一个子网下，但是没有MAC地址，会出现什么情况</p></li><li><p>http状态码</p></li><li><p>cookie不同网站是否可以共享，为什么</p></li><li><p>广播地址是什么意思</p></li><li><p>子网掩码</p></li><li><p>mac地址特点</p></li><li><p>socket情况下，tcp三次握手如何连接</p></li><li><p>tcp报文格式</p></li><li><p>socket函数bind，listen，connect</p></li><li><p>四元组为什么服务器端只需要建立一个端口</p></li><li><p>socket的文件描述符</p></li><li><p>socket缓冲区</p></li><li><p>socket缓冲区什么时候建立：每个socket被创建后，无论使用的是TCP协议还是UDP协议，都会创建自己的接收缓冲区和发送缓冲区。</p></li><li><p>客户端和服务器通过HTTP进行通信服务器任何人都可以访问，需要甄别出我认可的客户端</p></li><li><p>滑动窗口&#x2F;拥塞窗口为了解决什么问题（滑动窗口和拥塞窗口都是为了解决发送量的问题，那最终又谁决定？）</p></li><li><p>HTTP能用UDP传输嘛？</p></li><li><p>http1.0，http1.1，http2.0，http3.0，https分别有什么</p></li><li><p>select和epoll区别</p></li><li><p>全连接队列中的socket怎么消费</p></li><li><p>ICMP协议</p><p>1）设计是为了做哪些事情</p><p>2）除了ping还知道哪些？</p></li><li><p>IP头部中flag字段</p></li><li><p>IP分片的作用，哪个常见的命令是通过分片实现？</p></li><li><p>CLOSE_WAIT状态</p><p>1）发生在什么时候？</p><p>2）什么时候结束</p><p>3）出现了很多这个状态，原因</p></li><li><p>TIME_WAIT状态</p><p>1）发生在什么时候？</p><p>2）什么时候结束</p><p>3）为什么需要这个状态</p><p>4）出现了很多这个状态</p></li><li><p>怎么设置socket保持长连接</p></li><li><p>keepalive作用</p><p>1）不主动CLOSE也不会断开，为什么还需要这个状态</p><p>2）什么情况下需要主动断开连接（内部通讯）</p></li><li><p>OSI七层模型</p></li><li><p>netty的io多路复用是怎么实现</p></li><li><p>连接和IO事件是如何流转的（reactor模型）</p></li><li><p>日常生活中tcp和udp</p></li><li><p>TCP编程的注意点</p><p>1）发送1000个字节，如何区分这1000个字节？（哪里是1000个字节结束）</p><p>2）TCP客户端通信，如何识别报文，怎么定义报文长度，怎么发送及接收？</p><p>3）两者通信，想要一次性收到1000字节，但每次只收到了1字节，怎么处理？</p></li><li><p>HTTP和socket</p></li><li><p>HTTPS通信过程（SSL握手过程）</p></li><li><p>如何判断是否是一个子网？</p></li><li><p>子网掩码怎么获取</p></li><li><p>HTTP报文格式（常见的Header）</p></li><li><p>TCP头部信息</p></li><li><p>IP头部包含信息</p></li><li><p>HTTP头部</p><p>1）返回文件和返回图片的差异-&gt;想问content-type</p><p>2）显示图片而非下载-&gt;想问content-type</p></li><li><p>TCP建立连接的步骤</p></li><li><p>同步和异步的模型有哪些？</p></li><li><p>滑动窗口的调节算法</p></li><li><p>TCP和UDP调用connect区别</p></li><li><p>TCP&#x2F;UDP调用connet后，会真正的发送网络包嘛？</p></li><li><p>判断路由是否畅通的机制，使用TCP&#x2F;UDP</p></li><li><p>HTTP队头阻塞</p></li><li><p>TCP和UDP哪种速度更快，延时更低</p></li><li><p>Reactor和Proacte模式</p><p>1）为什么用这个？</p><p>2）并发性能</p></li><li><p>select监听文件描述符上限可以修改么？怎么修改</p></li><li><p>空轮训问题，NIO的空轮询bug是什么？netty是如何解决NIO空轮询bug的？</p></li><li><p>套接字通信的大致步骤</p></li><li><p>数据链路层有哪些协议</p></li><li><p>IPV4，IPV5和IPV6</p><p>1）含义</p><p>2）多少位</p></li><li><p>为什么绝大部分还在用IPV4而不是IPV6</p></li><li><p>网络攻击：SYN攻击</p></li><li><p>如何检测和解决SYN攻击</p></li><li><p>TCP超时重传时间如何计算？</p></li><li><p>复位报文（RST）</p></li><li><p>TCP定时器</p></li></ol><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2>]]></content>
    
    
    <categories>
      
      <category>others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker代码开发调试 mpi环境</title>
    <link href="/Docker/docker-develop/"/>
    <url>/Docker/docker-develop/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-代码开发调试流程"><a href="#docker-代码开发调试流程" class="headerlink" title="docker 代码开发调试流程"></a><a href="https://blog.csdn.net/condom10010/article/details/126742399">docker 代码开发调试流程</a></h1><ol><li>运行docker容器(同时把本地代码挂载到容器内)</li><li>使用vscode进入容器,并打开代码,修改代码,运行和调试.</li><li>在宿主机一端,使用git管理代码.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Basics of Autotools</title>
    <link href="/others/makefile-and-configure/"/>
    <url>/others/makefile-and-configure/</url>
    
    <content type="html"><![CDATA[<p><img src="/others/makefile-and-configure/diagram.png" alt="How autotools fits together"></p><p>[^A basic overview of how the main autotools components fit together]: </p><p>在一个简单的设置中。</p><ul><li>autoconf程序从configure.in或configure.ac中产生一个configure脚本（见下文注释）。</li><li>automake程序从Makefile.am中产生一个Makefile.in。</li><li>configure脚本被运行，以便从Makefile.in文件产生一个或多个Makefile文件。</li><li>make程序使用Makefile文件来编译程序</li></ul><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://devmanual.gentoo.org/general-concepts/autotools/index.html">The Basics of Autotools</a></p>]]></content>
    
    
    <categories>
      
      <category>others</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>编译相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/Java/Design_Mode/"/>
    <url>/Java/Design_Mode/</url>
    
    <content type="html"><![CDATA[<h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><h3 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a><strong>1、开闭原则（Open Close Principle）</strong></h3><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p><p>样例一：<a href="https://blog.csdn.net/m0_54485604/article/details/113502478">六大原则之开闭原则</a></p><p>将画笔类的draw()方法的实现放入对应的形状中，则新增形状无需修改画笔类的draw()方法，只需要在类中定义自己的draw()方法即可</p><p>样例二：<a href="https://blog.csdn.net/fry3309/article/details/123582415">开闭原则（开放封闭原则）</a></p><p>子类覆盖父类中需要修改的方法，通过子类代替父类来减少修改</p><h3 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></h3><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong></p><p>样例一：<a href="https://blog.csdn.net/weixin_39327556/article/details/125268590">里氏替换原则</a></p><p>对于需要修改父类内容的子类，找到更加通用的父类（父类的超类）替代其父类</p><h3 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></h3><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><h3 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a><strong>4、接口隔离原则（Interface Segregation Principle）</strong></h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h3 id="5、迪米特法则，又称最少知道原则（Demeter-Principle）"><a href="#5、迪米特法则，又称最少知道原则（Demeter-Principle）" class="headerlink" title="5、迪米特法则，又称最少知道原则（Demeter Principle）"></a><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></h3><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h3 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a><strong>6、合成复用原则（Composite Reuse Principle）</strong></h3><h2 id="二十三种常用设计模式"><a href="#二十三种常用设计模式" class="headerlink" title="二十三种常用设计模式"></a>二十三种常用设计模式</h2><table><thead><tr><th>1</th><th>创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</th><th>工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern）</th></tr></thead><tbody><tr><td>2</td><td><strong>结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td>适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern）</td></tr><tr><td>3</td><td><strong>行为型模式</strong> 这些设计模式特别关注对象之间的通信。</td><td>责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）</td></tr><tr><td>4</td><td><strong>J2EE 模式</strong> 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td><td>MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a><strong>创建型模式</strong></h3><h4 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h4><p>创造对象时无需new对象，而是用一个factory来创建，这样不会暴露产品的创建逻辑，也可以用统一的处理方式来管理产品的新建。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Factory</span>.</span></span>make(xxx);<br><br><span class="hljs-comment">// or like Executors</span><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Factory</span>.</span></span>make<span class="hljs-constructor">A()</span>;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Factory</span>.</span></span>make<span class="hljs-constructor">B()</span>;<br></code></pre></td></tr></table></figure><p>三要素：抽象产品（Shape）、具体产品（Circle、Square、Rectangle）、具体工厂（ShapeFactory）</p><p><img src="/Java/Design_Mode/image-20221121201018165.png" alt="image-20221121201018165"></p><h4 id="模版工厂模式"><a href="#模版工厂模式" class="headerlink" title="模版工厂模式"></a>模版工厂模式</h4><p>对于普通工厂模式来说，一个工厂可以生产几个不同的产品，如果需要新增产品，则需要修改factory的逻辑，不符合开闭原则。故可以使用抽象工厂模式，一个工厂对应一个产品，新增产品的同时新增工厂即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FactoryA</span> <span class="hljs-variable">factoryA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FactoryA</span>();<br><span class="hljs-type">FactoryB</span> <span class="hljs-variable">factoryB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FactoryB</span>();<br><span class="hljs-type">Product</span> <span class="hljs-variable">product1</span> <span class="hljs-operator">=</span> factoryA.make();<br><span class="hljs-type">Product</span> <span class="hljs-variable">product2</span> <span class="hljs-operator">=</span> factoryB.make();<br></code></pre></td></tr></table></figure><p>但对于模版工厂模式每一个产品都对应一个工厂，当产品种类数目较多时，系统中会存在过多的工厂，增加了系统的开销，让系统变得过于庞大。</p><h4 id="抽象工厂模式（Abstract-Factory-Pattern）"><a href="#抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="抽象工厂模式（Abstract Factory Pattern）"></a>抽象工厂模式（Abstract Factory Pattern）</h4><p>抽象工厂模式较于模版工厂模式新增了一个产品family的概念，一个具体的工厂类对应一个产品组。</p><p><img src="/Java/Design_Mode/image-20221121204536398.png" alt="image-20221121204536398"></p><h4 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h4><ul><li><p>一个类只能有一个实例对象，该对象一般可被全局访问</p></li><li><p>饿汉式and懒汉式（上锁+双重判断保证线程安全）</p></li><li><p>用private修饰构造函数</p></li><li><p>static修饰实例对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 饿汉式 建议使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingleObject</span> &#123;<br> <br>   <span class="hljs-comment">//创建 SingleObject 的一个对象</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleObject instance = <span class="hljs-keyword">new</span> SingleObject();<br> <br>   <span class="hljs-comment">//让构造函数为 private，这样该类就不会被实例化</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleObject</span>()</span>&#123;&#125;<br> <br>   <span class="hljs-comment">//获取唯一可用的对象</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleObject <span class="hljs-title">getInstance</span>()</span>&#123;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMessage</span>()</span>&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="原型模式（Prototype-Pattern）"><a href="#原型模式（Prototype-Pattern）" class="headerlink" title="原型模式（Prototype Pattern）"></a>原型模式（Prototype Pattern）</h4><p>在保障性能的情况下重复创造对象</p><ol><li>实现Cloneable接口</li><li>调用对象clone()方法（强转）</li></ol><p>缺点如下：</p><ol><li><p>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</p></li><li><p>当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆。</p></li></ol><h4 id="建造者模式（Builder-Pattern）（todo）"><a href="#建造者模式（Builder-Pattern）（todo）" class="headerlink" title="建造者模式（Builder Pattern）（todo）"></a>建造者模式（Builder Pattern）（todo）</h4><p>使用多个简单的对象一步一步构建成一个复杂的对象</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">kfd</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">DoContact</span> <span class="hljs-built_in">object</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoContact</span>.<span class="hljs-title class_">Builder</span>(<span class="hljs-string">&quot;MChopin&quot;</span>).<span class="hljs-title function_">age</span>(<span class="hljs-number">18</span>)<br>                .<span class="hljs-title function_">address</span>(<span class="hljs-string">&quot;shanghai&quot;</span>).<span class="hljs-title function_">build</span>();<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;name=&quot;</span> + <span class="hljs-built_in">object</span>.<span class="hljs-title function_">getName</span>() + <span class="hljs-string">&quot; age=&quot;</span> + <span class="hljs-built_in">object</span>.<span class="hljs-title function_">getAge</span>()<br>                + <span class="hljs-string">&quot; address=&quot;</span> + <span class="hljs-built_in">object</span>.<span class="hljs-title function_">getAddress</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><h4 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>用户通过代理对象来调用真实对象的方法，代理类类似中介</p><h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><p>由三个部分组成：公共接口、被代理对象、代理对象</p><img src="/Java/Design_Mode/image-20221124194103417.png" alt="image-20221124194103417" style="zoom:50%;"><p>Agent中rentHouse()方法实际调用了owner中的rentHouse()方法，可以在调用的前后增加操作，如收中介费等。</p><p>优点：简单</p><p>缺点：对于类中每个方法都要创建代理方法，新增与删除方法时要同步修改代理类方法，被代理对象与代理对象耦合严重</p><h5 id="jdk代理"><a href="#jdk代理" class="headerlink" title="jdk代理"></a>jdk代理</h5><p>动态代理中的一种，一个代理类可以代理多个类</p><img src="/Java/Design_Mode/image-20221124200742966.png" alt="image-20221124200742966" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Owner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandleForHouse</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rentHouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;房东租房&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellHouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;房东卖房&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">HandleForHouse</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rentHouse</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellHouse</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyOwner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span>&#123;<br>    <span class="hljs-keyword">private</span> Object object;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyOwner</span><span class="hljs-params">(Object object)</span>&#123;<br>        <span class="hljs-built_in">this</span>.object = object;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 不同类不同处理</span><br>        System.out.println(<span class="hljs-string">&quot;xxx&quot;</span>);<br>        <span class="hljs-keyword">if</span> (proxy <span class="hljs-keyword">instanceof</span> HandleForHouse)&#123;<br>            <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;rentHouse&quot;</span>))&#123;<br>                System.out.println(<span class="hljs-string">&quot;中介收租房中介费&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;sellHouse&quot;</span>))&#123;<br>                System.out.println(<span class="hljs-string">&quot;中介收卖房中介费&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> method.invoke(object, args);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Owner</span> <span class="hljs-variable">owner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Owner</span>();<br>        <span class="hljs-type">ProxyOwner</span> <span class="hljs-variable">proxyOwner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyOwner</span>(owner);<br>        <span class="hljs-type">HandleForHouse</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> (HandleForHouse) Proxy.newProxyInstance(<br>                proxyOwner.getClass().getClassLoader(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;HandleForHouse.class&#125;,<br>                proxyOwner);<br>        test1.rentHouse();<br>        test1.sellHouse();<br>    &#125;<br>&#125;<br><br>output:<br>xxx<br>中介收租房中介费<br>房东租房<br>xxx<br>中介收卖房中介费<br>房东卖房<br></code></pre></td></tr></table></figure><h5 id="cglib代理-todo"><a href="#cglib代理-todo" class="headerlink" title="cglib代理(todo)"></a>cglib代理(todo)</h5><h4 id="装饰器模式（Decorator-Pattern）"><a href="#装饰器模式（Decorator-Pattern）" class="headerlink" title="装饰器模式（Decorator Pattern）"></a>装饰器模式（Decorator Pattern）</h4><p>装饰器模式通过装饰类在不改变现有类结构的情况下对其添加新的功能，装饰类包装现有类。</p><p>由一下几个部分组成：</p><p>被装饰对象接口、被装饰对象、装饰器抽象类、装饰器具体实现</p><img src="/Java/Design_Mode/image-20221125210720349.png" alt="image-20221125210720349" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Clothes</span> <span class="hljs-variable">clothes</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeautifulClothes</span>();<br>        <span class="hljs-type">Decorator</span> <span class="hljs-variable">decorator1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoratorImplRed</span>(clothes);<br>        <span class="hljs-type">Decorator</span> <span class="hljs-variable">decorator2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoratorImplBlue</span>(clothes);<br>        decorator1.dress();<br>        decorator2.dress();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 被装饰对象接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Clothes</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dress</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 被装饰对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BeautifulClothes</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Clothes</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dress</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;穿漂亮衣服～&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 装饰器抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Clothes</span>&#123;<br>    <span class="hljs-keyword">private</span> Clothes clothes;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Clothes clothes)</span>&#123;<br>        <span class="hljs-built_in">this</span>.clothes = clothes;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dress</span><span class="hljs-params">()</span> &#123;<br>        clothes.dress();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 装饰器具体实现1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorImplRed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecoratorImplRed</span><span class="hljs-params">(Clothes clothes)</span> &#123;<br>        <span class="hljs-built_in">super</span>(clothes);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dress</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;红色装饰品&quot;</span>);<br>        <span class="hljs-built_in">super</span>.dress();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 装饰器具体实现2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorImplBlue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecoratorImplBlue</span><span class="hljs-params">(Clothes clothes)</span> &#123;<br>        <span class="hljs-built_in">super</span>(clothes);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dress</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;蓝色装饰品&quot;</span>);<br>        <span class="hljs-built_in">super</span>.dress();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h4><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。</p><p>比如说：电脑与内存卡中间需要一个读卡器作为桥梁，内存卡通过读卡器可以变成一个u盘</p><img src="/Java/Design_Mode/image-20221130225741583.png" alt="image-20221130225741583" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdapterTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();<br>        computer.readFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CardReader</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">(USBDrive usbDrive)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;电脑读取数据&quot;</span>);<br>        System.out.println(usbDrive.getData());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">USBDrive</span>&#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getData</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CardReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MemoryCard</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">USBDrive</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> showData();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryCard</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;数据&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">showData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="享元模式（Flyweight-Pattern）"><a href="#享元模式（Flyweight-Pattern）" class="headerlink" title="享元模式（Flyweight Pattern）"></a>享元模式（Flyweight Pattern）</h4><p>享元模式可以理解为带缓存的工厂模式，可以减少创建对象的数目。如String的串池、mysql的缓冲池。</p><img src="/Java/Design_Mode/image-20221201164438455.png" alt="image-20221201164438455" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span>&#123;<br>    <span class="hljs-keyword">private</span> String key;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(String key)</span>&#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;画一个圆圈，key为：&quot;</span>+key);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyWeightFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> ConcurrentHashMap&lt;String, Shape&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> Shape <span class="hljs-title function_">getShape</span><span class="hljs-params">(String key)</span>&#123;<br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">shape</span> <span class="hljs-operator">=</span> map.get(key);<br>        <span class="hljs-keyword">if</span> (shape != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> shape;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (map)&#123;<br>            <span class="hljs-keyword">if</span> (map.get(key) != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> map.get(key);<br>            &#125;<br>            <span class="hljs-type">Shape</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(key);<br>            map.put(key, circle);<br>            <span class="hljs-keyword">return</span> circle;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="xxx"><a href="#xxx" class="headerlink" title="xxx"></a>xxx</h3><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式&#x2F;模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p><h2 id="UML关系"><a href="#UML关系" class="headerlink" title="UML关系"></a>UML关系</h2><img src="/Java/Design_Mode/image-20221201215226048.png" alt="image-20221201215226048" style="zoom:50%;"><p>composition：心脏与人</p><p>aggregation：个人与班级</p><h2 id="Design-Smells"><a href="#Design-Smells" class="headerlink" title="Design Smells"></a><strong>Design Smells</strong></h2><ol><li><p>Rigidity僵化：软件太难改变即使是简单的方式，一个变化会导致其他依赖模块的连锁变化</p></li><li><p>Fragility易碎性：一个单一的变化导致软件很多地方中断</p></li></ol><p>Rigidity和fragility相辅相成，在设计新功能&#x2F;变换时以造成最小的影响为目标</p><ol start="3"><li><p>Immobility不动性：设计难以被重复使用</p></li><li><p>概念简介</p></li></ol><p>Viscosity粘度：</p><p>Concept introduction环境层面：开发环境缓慢效率低下；</p><p>软件层面：改变通过黑客的方法比保留设计的方法更容易实现</p><ol start="5"><li><p>Opacity不透明：模块难以理解</p></li><li><p>Meaningless Complexity 无意义的复杂：事情做得比它们应该做的更复杂</p></li><li><p>Meaningless Repetition 无意义的重复：缺乏统一的结构</p></li><li><p>Coupling耦合：各部分之间的相互依存关系</p></li></ol><h2 id="Code-Smell"><a href="#Code-Smell" class="headerlink" title="Code Smell"></a>Code Smell</h2><p><strong>Long Method</strong>：一个方法的内容过多，过复杂</p><p><strong>解决办法</strong>：将部分操作拆分成独立方法</p><p><strong>Long Parameter List</strong>：一个方法需要引入的变量过多，过复杂</p><p><strong>解决办法</strong>：充分利用已有变量的资源</p><p><strong>Data Classes</strong>：一个类除了 getter 和 setter 之外没有其他的方法&#x2F;行为了</p><p><strong>解决办法</strong>：充分利用已有变量的资源</p><p><strong>Lazy Class</strong>：一个类的存在不是很有必要 （一个类的子类如果没有任何覆写的方法或</p><p>者新增的方法，那么这个类有可能是一个 Lazy Class）</p><p><strong>Refused Request 被拒绝的遗赠</strong>：子类和父类的关系一开始很简单，但随着时间的推</p><p>移可能会变得越来越复杂。一个子类通常需要紧密的依赖其父类，但有时会矫枉过正。</p><p><strong>Feature Envy</strong> (依恋情结)：某个函数为了计算某个值，从另一个对象那儿调用几乎半打的取值函数。</p><p><strong>Shotgun Surgery</strong> (散弹式修改)：任何修改都需要在许多不同类上做小幅度修改。</p><p>• 原因：单一职责被拆分成大量的散类</p><p>• <strong>解决方法</strong>：运用搬移函数和搬移字段来讲不同类中的相同行为放到一个对立的类中。</p><p><strong>Divergent Change</strong> </p><p>概念简介 (发散式变化)：修个某个功能，要在一个类中改动多处</p><p>Concept introduction</p><p>• <strong>解决方法：</strong>找到造成所有变化的特定原因，将他们放到一个类中。</p><p><img src="/Java/Design_Mode/image-20221201220504057.png" alt="image-20221201220504057"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.runoob.com/design-pattern/design-pattern-intro.html">菜鸟教程-设计模式简介</a></li><li><a href="https://www.jianshu.com/p/a3e09071c44f">重构（Refactoring）学习笔记</a></li><li><a href="https://zhuanlan.zhihu.com/p/475486025">设计模式之【工厂模式】</a></li><li><a href="https://blog.csdn.net/yucaixiang/article/details/90379525">原型模式</a></li><li><a href="https://blog.csdn.net/ChineseSoftware/article/details/123256575">建造者模式(Builder Pattern)</a></li><li><a href="https://www.zhihu.com/question/21857130">什么是建造者模式？</a></li><li><a href="https://www.bilibili.com/read/cv14604081/">18设计模式——建造者模式详解</a></li><li><a href="https://blog.csdn.net/uuuyy_/article/details/122433110">25种代码坏味道总结+优化示例</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
      <tag>系统架构</tag>
      
      <tag>整理总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阻塞队列（BlockingQueue）</title>
    <link href="/Java/Block-queue/"/>
    <url>/Java/Block-queue/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>实现类</th><th>特点</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>基于环形数组实现的有界阻塞队列</td></tr><tr><td>LinkedBlockingQueue</td><td>基于单链表实现的无界阻塞队列，有两个锁，可同时存取</td></tr><tr><td>LinkedBlockingDeque</td><td>基于双链表实现的无界阻塞队列，双向读写</td></tr><tr><td>DelayQueue</td><td>基于优先队列实现的延迟阻塞队列，队列中数据需要到达延迟时间才能取出</td></tr><tr><td>PriorityBlockingQueue</td><td>线程安全优先队列，底层为堆排序</td></tr><tr><td>SynchronousQueue</td><td>无缓存阻塞队列</td></tr><tr><td>LinkedTransferQueue</td><td>基于CAS和单链表实现的无界队列</td></tr></tbody></table><h2 id="二、常用方法"><a href="#二、常用方法" class="headerlink" title="二、常用方法"></a>二、常用方法</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p>以上四个方法都是将数据添加进队列</p><ul><li>add和offer，如果成功则<strong>直接（不阻塞）</strong>返回true，否则，add方法抛出IllegalStateException，而offer方法直接返回false。故对于有界的阻塞队列使用offer通常效果更佳，因为其不会抛出异常阻塞线程。</li><li>put，如果队列剩余空间不足导致加入不成功，会<strong>一直阻塞等待</strong>。</li><li>带参数offer，如果队列剩余空间不足导致加入不成功，会<strong>在时间限期内</strong>阻塞等待添加数据。</li></ul><h3 id="取出数据"><a href="#取出数据" class="headerlink" title="取出数据"></a>取出数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>E <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p>以上两个方法都是将队首数据从队列取出</p><ul><li>take如果没有数据可以取出，则会<strong>一直阻塞等待</strong>。</li><li>poll会<strong>在时间限期内</strong>阻塞等待。</li></ul><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br></code></pre></td></tr></table></figure><h3 id="批量传递数据"><a href="#批量传递数据" class="headerlink" title="批量传递数据"></a>批量传递数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">drainTo</span><span class="hljs-params">(Collection&lt;? <span class="hljs-built_in">super</span> E&gt; c)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">drainTo</span><span class="hljs-params">(Collection&lt;? <span class="hljs-built_in">super</span> E&gt; c, <span class="hljs-type">int</span> maxElements)</span>;<br></code></pre></td></tr></table></figure><p>drainTo实现将当前阻塞队列中的信息全部转移到集合c中</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>查看队列剩余容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">remainingCapacity</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>查看是否包含某个数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>;<br></code></pre></td></tr></table></figure><h2 id="三、实现类及其源码"><a href="#三、实现类及其源码" class="headerlink" title="三、实现类及其源码"></a>三、实现类及其源码</h2><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><ul><li>有界阻塞队列，底层通过Object数组以及ReentrantLock等工具实现，初始化ArrayBlockingQueue时会传入数组长度</li><li>无法存放null值</li><li>入队与出队<strong>共享同一个锁</strong></li><li><strong>while配合condition使用，等待唤醒</strong>（BlockingQueue通用）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Object[] items;<br><span class="hljs-keyword">final</span> ReentrantLock lock;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(fair);<br>    notEmpty = lock.newCondition();<br>    notFull =  lock.newCondition();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">capacity：队列容量</span><br><span class="hljs-comment">fair：是否是公平锁，默认非公平，可省略</span><br><span class="hljs-comment">c：通过集合c初始化队列数值，将c中数据全部取出放入队列中，可省略</span><br><span class="hljs-comment">⚠️</span><br><span class="hljs-comment">1. c中数据不能为null，否则会出现NullPointerException</span><br><span class="hljs-comment">2. c的长度不能大于队列容量，否则会出现IllegalArgumentException</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair, Collection&lt;? extends E&gt; c)</span> &#123; <br>     <span class="hljs-built_in">this</span>(capacity, fair);<br>      <br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>      lock.lock(); <span class="hljs-comment">// Lock only for visibility, not mutual exclusion</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">for</span> (E e : c)<br>            items[i++] = Objects.requireNonNull(e);<br>        &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>        &#125;<br>        count = i; <span class="hljs-comment">// 队列中元素个数</span><br>        putIndex = (i == capacity) ? <span class="hljs-number">0</span> : i; <span class="hljs-comment">// 下一个数据插入时存放位置</span><br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>      &#125;<br>&#125;<br><br><span class="hljs-comment">// 入队</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    items[putIndex] = e;<br>    <span class="hljs-keyword">if</span> (++putIndex == items.length) putIndex = <span class="hljs-number">0</span>;<br>    count++;<br>    notEmpty.signal(); <span class="hljs-comment">// 唤醒取数据等待队列</span><br>&#125;<br><br><span class="hljs-comment">// 出队</span><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) items[takeIndex];<br>    items[takeIndex] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="hljs-number">0</span>;<br>    count--;<br>    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-literal">null</span>)<br>      itrs.elementDequeued();<br>    notFull.signal(); <span class="hljs-comment">// 唤醒插入数据等待队列</span><br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br><br><span class="hljs-comment">//================插入数据================</span><br><span class="hljs-comment">// 插入数据，lock上锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    Objects.requireNonNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (count == items.length)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 队列满了的情况直接返回false</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        enqueue(e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Objects.requireNonNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// lockInterruptibly 与 lock比较区别在于 lockInterruptibly优先考虑响应中断，再去获取锁。 </span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (count == items.length)<br>        notFull.await(); <span class="hljs-comment">// 队列满了的情况阻塞等待</span><br>      enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//================取出数据================</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">return</span> (count == <span class="hljs-number">0</span>) ? <span class="hljs-literal">null</span> : dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>        notEmpty.await();<br>      <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><ul><li>无界阻塞队列，但也可传入capacity限定容量，默认Integer.MAX_VALUE作为最大容量（近似无界），底层通过链表以及ReentrantLock等工具实现</li><li>入队与出队<strong>分别拥有不同的锁</strong>，takeLock和putLock，故写出与取出可以同时进行</li><li>count类型为AtomicInteger，防止发生并发问题</li><li>add，offer，put，take，poll等操作实现与ArrayBlockingQueue类似</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 与ArrayBlockingQueue不同，因为添加和删除元素可以同步进行，为防止发生并发问题，此处count不能使用简单int</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(); <br><span class="hljs-keyword">transient</span> Node&lt;E&gt; head;<span class="hljs-comment">// head为哨兵节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.capacity = capacity;<br>    last = head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(<span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> &#123;<br>   last = last.next = node;<br>&#125;<br><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    Node&lt;E&gt; h = head;<br>    Node&lt;E&gt; first = h.next;<br>    h.next = h; <span class="hljs-comment">// help GC</span><br>    head = first;<br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> first.item;<br>    first.item = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><ul><li>双向队列，LinkedBlockingQueue类似，用双链表+ReentrantLock实现</li><li>用一个锁对两端的入队出队进行并发控制</li><li>linkXXX、unlinkXXX与enqueue、dequque功能及实现类似</li><li>addLFirst、addLast等同理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; prev;<br>    Node&lt;E&gt; next;<br>    Node(E x) &#123;<br>      item = x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><ul><li>带延迟的无界的阻塞队列，通过PriorityQueue（优先队列）、Delayed与ReentrantLock实现</li><li>用一个锁对PriorityQueue的入队出队进行并发控制</li><li>入队操作的add和put直接调用offer方法</li><li>出队操作返回延迟期满后的第一个元素，如果队列中没有元素或者没有延迟期满的元素，则poll操作返回null，take操作阻塞等待</li><li>使用leader线程避免大量线程在同一时间点唤醒产生大量竞争 &#x2F;&#x2F; todo：理解具体实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Delayed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Delayed&gt; &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span>; <span class="hljs-comment">// 返回剩余延迟时间</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayQueue</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Delayed</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;E&gt;();<br>  <br>  <span class="hljs-comment">// 避免大量线程在同一时间点唤醒，导致大量的竞争，影响性能</span><br>  <span class="hljs-comment">// Leader-Follower模式的变体</span><br>    <span class="hljs-keyword">private</span> Thread leader;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            q.offer(e);<br>            <span class="hljs-keyword">if</span> (q.peek() == e) &#123;<br>                leader = <span class="hljs-literal">null</span>;<br>                available.signal();<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> q.peek();<br>            <span class="hljs-keyword">return</span> (first == <span class="hljs-literal">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="hljs-number">0</span>)<br>                ? <span class="hljs-literal">null</span><br>                : q.poll();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> q.peek();<br>                <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>)<br>                    available.await();<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);<br>                    <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0L</span>)<br>                        <span class="hljs-keyword">return</span> q.poll();<br>                    first = <span class="hljs-literal">null</span>; <span class="hljs-comment">// don&#x27;t retain ref while waiting</span><br>                    <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>)<br>                        available.await();<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                        leader = thisThread;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            available.awaitNanos(delay);<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-keyword">if</span> (leader == thisThread)<br>                                leader = <span class="hljs-literal">null</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; q.peek() != <span class="hljs-literal">null</span>)<br>                available.signal();<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>  <br>     <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> q.peek();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br> <br></code></pre></td></tr></table></figure><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><ul><li>并发安全的优先队列</li><li><a href="https://www.cnblogs.com/sergeantFat/p/14492538.html">阻塞优先队列（PriorityBlockingQueue）详解</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><ul><li>容量为0的阻塞队列</li><li>基于CAS无锁算法实现</li><li><a href="https://www.jianshu.com/p/d5e2e3513ba3">12. SynchronousQueue</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><ul><li>相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。可以算是 <code>LinkedBolckingQueue</code> 和 <code>SynchronousQueue</code> 和合体</li><li>底层基于单链表实现,其内部节点分为数据结点、请求结点；基于CAS无锁算法实现</li><li><a href="https://blog.csdn.net/weixin_49561445/article/details/120599614">LinkedTransferQueue</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedTransferQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransferQueue</span>&lt;E&gt;, java.io.Serializable &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h2><ol><li><p>在线程池作为任务队列</p></li><li><p>延迟队列（DelayQueue）</p><p>场景：大批量的任务处理，比如说卖票，一次性放出太多情况下系统无法承受压力</p></li><li><p>定时任务（DelayQueue）</p></li><li><p>缓存系统的设计（DelayQueue）</p><p>一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</p></li><li><p>信息同步传递[消费线程和生产线程 1:1]（SynchronousQueue）</p><p>场景：核心线程数为0的线程池</p></li></ol><h2 id="五、参考文档"><a href="#五、参考文档" class="headerlink" title="五、参考文档"></a>五、参考文档</h2><p>本文的部分内容参考或者引用以下文章，在此表示感谢，如果有涉及知识产权的问题，请联系我及时修改。</p><ul><li>jdk-11.0.2.jdk</li><li><a href="https://blog.csdn.net/c15158032319/article/details/118636233">延迟队列DelayQueue原理</a></li><li><a href="https://www.cnblogs.com/sergeantFat/p/14492538.html">阻塞优先队列（PriorityBlockingQueue）详解</a></li><li><a href="https://www.jianshu.com/p/d5e2e3513ba3">12. SynchronousQueue</a></li><li><a href="https://blog.csdn.net/weixin_49561445/article/details/120599614">LinkedTransferQueue</a></li><li><a href="https://blog.csdn.net/csfun1/article/details/122524692">并发编程-06 BlockingQueue及应用场景详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库锁机制</title>
    <link href="/Mysql/locking/"/>
    <url>/Mysql/locking/</url>
    
    <content type="html"><![CDATA[<h1 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h1><ul><li>行级锁<ul><li>共享锁</li><li>排他锁</li></ul></li><li>表级锁</li><li>意向锁</li></ul><h1 id="查看锁情况"><a href="#查看锁情况" class="headerlink" title="查看锁情况"></a>查看锁情况</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">FULL</span> PROCESSLIST<br></code></pre></td></tr></table></figure><h3 id="InnoDB-1-0开始在INFORMATION-SCHEMA架构添加了三张表可以查看"><a href="#InnoDB-1-0开始在INFORMATION-SCHEMA架构添加了三张表可以查看" class="headerlink" title="InnoDB 1.0开始在INFORMATION_SCHEMA架构添加了三张表可以查看"></a>InnoDB 1.0开始在INFORMATION_SCHEMA架构添加了三张表可以查看</h3><p>INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS</p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>锁</tag>
      
      <tag>数据库</tag>
      
      <tag>MySql</tag>
      
      <tag>InnoDB存储引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程池</title>
    <link href="/Java/Thread_pool/"/>
    <url>/Java/Thread_pool/</url>
    
    <content type="html"><![CDATA[<h2 id="一、基本参数"><a href="#一、基本参数" class="headerlink" title="一、基本参数"></a>一、基本参数</h2><p>新建一个线程池实例可调用Executors的newCachedThreadPool()、newFixedThreadPool()等方法，实际上这些方法的底层都是调用的ThreadPoolExecutor的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              TimeUnit unit,</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              ThreadFactory threadFactory,</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>corePoolSize</strong>：指定线程池的核心线程数，核心线程能够一直存活在线程池中。</li><li><strong>maximumPoolSize</strong>：指定线程池能存活的最大线程数，要求maximumPoolSize &gt;&#x3D; corePoolSize，最大线程数与核心线程数的差值为线程池内临时线程的最大数目。</li><li>keepAliveTime：临时线程存活时间，<strong>临时线程</strong>在<strong>空闲</strong>超过当前时间时会被销毁。</li><li>unit：keepAliveTime的时间单位。</li><li><strong>workQueue</strong>：任务队列，被提交到线程池的尚未被执行的任务。</li><li>threadFactory：用于创建线程的线程工厂，一般使用默认工厂。 非必需传入。</li><li><strong>handler</strong>：拒绝策略，任务太多情况下使用拒绝策略处理超出任务。非必需传入。</li></ul><p>具体信息见源码解读&gt;关键参数</p><h2 id="二、线程池状态"><a href="#二、线程池状态" class="headerlink" title="二、线程池状态"></a>二、线程池状态</h2><p>线程池有五种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure><h2 id="三、执行机制"><a href="#三、执行机制" class="headerlink" title="三、执行机制"></a>三、执行机制</h2><p><img src="/Java/Thread_pool/f228f23338ef4a0ebd615b965fd94894.png" alt="线程池执行机制"></p><h2 id="四、源码解读"><a href="#四、源码解读" class="headerlink" title="四、源码解读"></a>四、源码解读</h2><h3 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h3><h4 id="1-corePoolSize"><a href="#1-corePoolSize" class="headerlink" title="1. corePoolSize"></a>1. corePoolSize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> corePoolSize;<br></code></pre></td></tr></table></figure><ul><li>volatile修饰</li><li>最小值为0</li><li>不允许超时销毁，会一直存活在线程池内，除非设置了允许核心线程超时（allowCoreThreadTimeOut &#x3D; true）</li></ul><h4 id="2-maximumPoolSize"><a href="#2-maximumPoolSize" class="headerlink" title="2. maximumPoolSize"></a>2. maximumPoolSize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> maximumPoolSize;<br></code></pre></td></tr></table></figure><ul><li>最大线程数目</li><li>超时销毁</li><li>值大于等于核心线程数目</li></ul><h4 id="3-workQueue"><a href="#3-workQueue" class="headerlink" title="3. workQueue"></a>3. workQueue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br></code></pre></td></tr></table></figure><p>The queue used for holding tasks and handing off to worker threads.  We do not require that workQueue.poll() returning null necessarily means that workQueue.isEmpty(), so rely solely on isEmpty to see if the queue is empty (which we must do for example when deciding whether to transition from SHUTDOWN to TIDYING).  This accommodates special-purpose queues such as DelayQueues for which poll() is allowed to return null even if it may later return non-null when delays expire.</p><ul><li>存放待工作线程处理的任务</li></ul><p><strong>BlockQueue的继承与实现</strong></p><p><img src="/Java/Thread_pool/image-20221021111242474.png" alt="image-20221021111242474"></p><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </p><h3 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h3><h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><h2 id="五、使用场景与优缺点"><a href="#五、使用场景与优缺点" class="headerlink" title="五、使用场景与优缺点"></a>五、使用场景与优缺点</h2><p>空间换时间</p><h2 id="六、面试与思考"><a href="#六、面试与思考" class="headerlink" title="六、面试与思考"></a>六、面试与思考</h2><ol><li><strong>线程池参数及含义。</strong></li><li><strong>向线程池提交一个任务会直接运行吗？</strong></li><li>线程池任务提交流程。</li><li>线程池是如何保持池内线程存活的。</li></ol><h2 id="七、参考文档"><a href="#七、参考文档" class="headerlink" title="七、参考文档"></a>七、参考文档</h2><p>本文的部分内容参考或者引用以下文章，在此表示感谢，如果有涉及知识产权的问题，请联系我及时修改。</p><ul><li>《实战Java高并发程序设计》</li><li><a href="https://blog.csdn.net/qq_37602560/article/details/123845442">线程池的-任务执行机制</a></li><li>jdk-11.0.2.jdk</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
      <tag>源码</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣2312. 卖木头块</title>
    <link href="/Algorithm/selling-pieces-of-wood/"/>
    <url>/Algorithm/selling-pieces-of-wood/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/selling-pieces-of-wood/description/">https://leetcode.cn/problems/selling-pieces-of-wood/description/</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP</title>
    <link href="/Algorithm/KMP/"/>
    <url>/Algorithm/KMP/</url>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>字符串匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/Architecture/docker/"/>
    <url>/Architecture/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h1><h2 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h2><p>Docker是一个<strong>轻量级</strong>的可以将应用及其依赖进行打包并发布到不同操作系统的Linux<strong>容器</strong>的一种封装。Docker本身并不是容器，它是创建容器的工具，是应用容器引擎。</p><h2 id="Docker的核心概念"><a href="#Docker的核心概念" class="headerlink" title="Docker的核心概念"></a>Docker的核心概念</h2><p>• 镜像（Image）：一组应用及其依赖的打包，是一个只读的提供容器运行时所需的程序、库、资源、配置等文件以及一些为运行时准备的配置参数的环境打包。</p><p>• 容器（Container）：是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除</p><p>• 仓库（Repository）：是docker存放镜像的场所</p><h2 id="操作系统、虚拟机、容器和进程有什么区别"><a href="#操作系统、虚拟机、容器和进程有什么区别" class="headerlink" title="操作系统、虚拟机、容器和进程有什么区别"></a>操作系统、虚拟机、容器和进程有什么区别</h2><p>操作系统</p><p><img src="/Architecture/docker/v2-145c3cb904f8696ea68dbcb54b24938b_1440w.webp" alt="img"></p><h2 id="关于k8s"><a href="#关于k8s" class="headerlink" title="关于k8s"></a>关于k8s</h2><h1 id="Docker怎么用"><a href="#Docker怎么用" class="headerlink" title="Docker怎么用"></a>Docker怎么用</h1><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>本文的部分内容参考或者引用以下文章，在此表示感谢，如果有涉及知识产权的问题，请联系我及时修改。</p><ul><li><a href="https://blog.csdn.net/crazymakercircle/article/details/120747767">Docker原理（图解+秒懂+史上最全）</a></li><li><a href="https://zhuanlan.zhihu.com/p/144292368">云原生时代（四）：容器和Docker</a></li><li><a href="https://www.cnblogs.com/My-zhanglulu/p/16274319.html">什么是Docker容器?(全面了解使用)</a></li></ul><p>未完待续。。。</p>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>云计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/Algorithm/Knapsack%20problem/"/>
    <url>/Algorithm/Knapsack%20problem/</url>
    
    <content type="html"><![CDATA[<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>可转换为取或者不取第i个物品的问题，递推公式为：dp[i][v]&#x3D; Max(dp[i-1][v], dp[i-1][v-c[i]] + w[i])，其中dp[i][v]为对于前i个物品有一个容量为v的背包，此时能装入的最大价值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 注：0是补充对齐的</span><br>        <span class="hljs-type">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>, V = <span class="hljs-number">5</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; v &lt;= V; v++) &#123;<br>                dp[i][v] = dp[i-<span class="hljs-number">1</span>][v];<br>                <span class="hljs-keyword">if</span>(v &gt;= c[i])&#123;<br>                    dp[i][v] = Math.max(dp[i][v], dp[i-<span class="hljs-number">1</span>][v-c[i]] + w[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            System.out.println(Arrays.toString(dp[i]));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">output：<br><span class="hljs-string">[0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 2]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 2]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 3]</span><br><span class="hljs-string">[0, 0, 2, 4, 4, 6]</span><br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span>[] dp2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[V+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> V; v &gt;= c[i] ; v--) &#123;<br>    dp2[v] = Math.max(dp2[v-c[i]]+w[i],dp2[v]);<br>  &#125;<br>  System.out.println(Arrays.toString(dp2));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[0, 0, 0, 0, 0, 0]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 2]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 2]</span><br><span class="hljs-string">[0, 0, 2, 2, 2, 3]</span><br><span class="hljs-string">[0, 0, 2, 4, 4, 6]</span><br></code></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li><a href="https://leetcode-cn.com/problems/target-sum/">目标和</a>：转化问题以后为0-1背包方案数问题。</li><li><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a>：转化后为0-1背包可行性问题。</li><li><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后一块石头的重量 II</a>：转化后为0-1背包最小值问题。</li></ul><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><ul><li><p><input checked disabled type="checkbox"> <a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a>：完全背包最小值</p></li><li><p><input checked disabled type="checkbox"> <a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a>：完全背包最小值</p></li></ul><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><ul><li><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">01 字符构成最多的字符串</a>：多维费用的 0-1 背包最大值，两个背包大小：0和1的数量</li><li><a href="https://leetcode-cn.com/problems/profitable-schemes/">盈利计划</a>：多维费用的 0-1 背包最大值</li></ul><h2 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h2><h2 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h2><ul><li><a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/">掷骰子的N种方法</a>：每一组是一个骰子，每个骰子只能拿一个体积为1到6的物品</li></ul><h2 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h2><h2 id="背包问题求方案数"><a href="#背包问题求方案数" class="headerlink" title="背包问题求方案数"></a>背包问题求方案数</h2><ul><li><input disabled type="checkbox"> <a href="https://leetcode.cn/problems/coin-change-ii/">零钱兑换 II</a>：完全背包方案数</li><li><input disabled type="checkbox"> <a href="https://leetcode-cn.com/problems/combination-sum-iv/">组合总和 Ⅳ</a>：考虑物品顺序的完全背包方案数。每个物品可以重复拿，有几种装满背包的方案？</li></ul><h2 id="背包问题求具体方案"><a href="#背包问题求具体方案" class="headerlink" title="背包问题求具体方案"></a>背包问题求具体方案</h2><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li><a href="https://github.com/tianyicui/pack">背包问题九讲 2.0 beta1.2 崔添翼 (Tianyi Cui)*</a></li><li><a href="https://blog.csdn.net/e891377/article/details/117639203">LeetCode背包问题—题目列表</a></li></ul><p>未完待续。。。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统IO详解</title>
    <link href="/OS/IO/"/>
    <url>/OS/IO/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
